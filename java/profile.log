SCRIPT  /home/root99/.vim/plugged/vim-devicons/autoload/airline/extensions/tabline/formatters/webdevicons.vim
Sourced 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                            " Version: 0.11.0
                            " Webpage: https://github.com/ryanoasis/vim-devicons
                            " Maintainer: Ryan McIntyre <ryanoasis@gmail.com>
                            " License: see LICENSE
                            
    1              0.000003 function! airline#extensions#tabline#formatters#webdevicons#format(bufnr, buffers) abort
                              " Call original formatter.
                              let originalFormatter = airline#extensions#tabline#formatters#{g:_webdevicons_airline_orig_formatter}#format(a:bufnr, a:buffers)
                              return originalFormatter . g:WebDevIconsTabAirLineBeforeGlyphPadding .
                                     \ WebDevIconsGetFileTypeSymbol(bufname(a:bufnr)) . g:WebDevIconsTabAirLineAfterGlyphPadding
                            endfunction
                            
                            " modeline syntax:
                            " vim: fdm=marker tabstop=2 softtabstop=2 shiftwidth=2 expandtab:

SCRIPT  /home/root99/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim
Sourced 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2021 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2 et
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000006 if !exists(":def") || !airline#util#has_vim9_script()
    1              0.000002   function! airline#extensions#tabline#formatters#default#format(bufnr, buffers)
                                let fnametruncate = get(g:, 'airline#extensions#tabline#fnametruncate', 0)
                                let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
                                let _ = ''
                            
                                let name = bufname(a:bufnr)
                                if empty(name)
                                  let _ = '[No Name]'
                                elseif name =~ 'term://'
                                  " Neovim Terminal
                                  let _ = substitute(name, '\(term:\)//.*:\(.*\)', '\1 \2', '')
                                else
                                  if get(g:, 'airline#extensions#tabline#fnamecollapse', 1)
                                    " Does not handle non-ascii characters like Cyrillic: 'D/Учёба/t.c'
                                    "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
                                    let _ = pathshorten(fnamemodify(name, fmod))
                                  else
                                    let _ = fnamemodify(name, fmod)
                                  endif
                                  if a:bufnr != bufnr('%') && fnametruncate && strlen(_) > fnametruncate
                                    let _ = airline#util#strcharpart(_, 0, fnametruncate)
                                  endif
                                endif
                            
                                return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)
                              endfunction
                            
    1              0.000002   function! airline#extensions#tabline#formatters#default#wrap_name(bufnr, buffer_name)
                                let buf_nr_format = get(g:, 'airline#extensions#tabline#buffer_nr_format', '%s: ')
                                let buf_nr_show = get(g:, 'airline#extensions#tabline#buffer_nr_show', 0)
                            
                                let _ = buf_nr_show ? printf(buf_nr_format, a:bufnr) : ''
                                let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
                                if getbufvar(a:bufnr, '&modified') == 1
                                  let _ .= g:airline_symbols.modified
                                endif
                                return _
                              endfunction
    1              0.000001   finish
                            else
                              " Vim9 Script implementation
                              def airline#extensions#tabline#formatters#default#format(bufnr: number, buffers: list<number>): string
                            		var fnametruncate = get(g:, 'airline#extensions#tabline#fnametruncate', 0)
                                var fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
                                var result = ''
                            
                                var name = bufname(bufnr)
                                if empty(name)
                                  result = '[No Name]'
                                elseif name =~ 'term://'
                                  # Neovim Terminal
                                  result = substitute(name, '\(term:\)//.*:\(.*\)', '\1 \2', '')
                                else
                                  if get(g:, 'airline#extensions#tabline#fnamecollapse', 1)
                                     result = pathshorten(fnamemodify(name, fmod))
                                  else
                                     result = fnamemodify(name, fmod)
                                  endif
                                  if bufnr != bufnr('%') && fnametruncate && strlen(result) > fnametruncate
                                    result = airline#util#strcharpart(result, 0, fnametruncate)
                                  endif
                                endif
                                return airline#extensions#tabline#formatters#default#wrap_name(bufnr, result)
                              enddef
                            
                              def airline#extensions#tabline#formatters#default#wrap_name(bufnr: number, buffer_name: string): string
                                var buf_nr_format = get(g:, 'airline#extensions#tabline#buffer_nr_format', '%s: ')
                                var buf_nr_show = get(g:, 'airline#extensions#tabline#buffer_nr_show', 0)
                            
                                var result = buf_nr_show ? printf(buf_nr_format, bufnr) : ''
                                result ..= substitute(buffer_name, '\\', '/', 'g')
                            
                                if getbufvar(bufnr, '&modified') == 1
                                  result ..= g:airline_symbols.modified
                                endif
                                return result
                              enddef
                            endif

SCRIPT  /usr/share/nvim/runtime/ftplugin/java.vim
Sourced 1 time
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	Java
                            " Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
                            " Last Change:  2012 Mar 11
                            " URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin
                            
    1              0.000006 if exists("b:did_ftplugin") | finish | endif
    1              0.000003 let b:did_ftplugin = 1
                            
                            " Make sure the continuation lines below do not cause problems in
                            " compatibility mode.
    1              0.000007 let s:save_cpo = &cpo
    1              0.000010 set cpo-=C
                            
                            " For filename completion, prefer the .java extension over the .class
                            " extension.
    1              0.000004 set suffixes+=.class
                            
                            " Enable gf on import statements.  Convert . in the package
                            " name to / and append .java to the name, then search the path.
    1              0.000003 setlocal includeexpr=substitute(v:fname,'\\.','/','g')
    1              0.000003 setlocal suffixesadd=.java
    1              0.000003 if exists("g:ftplugin_java_source_path")
                                let &l:path=g:ftplugin_java_source_path . ',' . &l:path
    1              0.000001 endif
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000004 setlocal formatoptions-=t formatoptions+=croql
                            
                            " Set 'comments' to format dashed lists in comments. Behaves just like C.
    1              0.000009 setlocal comments& comments^=sO:*\ -,mO:*\ \ ,exO:*/
                            
    1              0.000003 setlocal commentstring=//%s
                            
                            " Change the :browse e filter to primarily show Java-related files.
    1              0.000006 if has("gui_win32")
                                let  b:browsefilter="Java Files (*.java)\t*.java\n" .
                            		\	"Properties Files (*.prop*)\t*.prop*\n" .
                            		\	"Manifest Files (*.mf)\t*.mf\n" .
                            		\	"All Files (*.*)\t*.*\n"
    1              0.000001 endif
                            
                            " Undo the stuff we changed.
    1              0.000004 let b:undo_ftplugin = "setlocal suffixes< suffixesadd<" .
                            		\     " formatoptions< comments< commentstring< path< includeexpr<" .
                            		\     " | unlet! b:browsefilter"
                            
                            " Restore the saved compatibility options.
    1              0.000005 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo

SCRIPT  /usr/share/nvim/runtime/indent/java.vim
Sourced 1 time
Total time:   0.000162
 Self time:   0.000162

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Java
                            " Previous Maintainer: Toby Allsopp <toby.allsopp@peace.com>
                            " Current Maintainer: Hong Xu <hong@topbug.net>
                            " Homepage: http://www.vim.org/scripts/script.php?script_id=3899
                            "           https://github.com/xuhdev/indent-java.vim
                            " Last Change:	2016 Mar 7
                            " Version: 1.1
                            " License: Same as Vim.
                            " Copyright (c) 2012-2016 Hong Xu
                            " Before 2012, this file was maintained by Toby Allsopp.
                            
                            " Only load this indent file when no other was loaded.
    1              0.000005 if exists("b:did_indent")
                              finish
    1              0.000001 endif
    1              0.000003 let b:did_indent = 1
                            
                            " Indent Java anonymous classes correctly.
    1              0.000012 setlocal cindent cinoptions& cinoptions+=j1
                            
                            " The "extends" and "implements" lines start off with the wrong indent.
    1              0.000007 setlocal indentkeys& indentkeys+=0=extends indentkeys+=0=implements
                            
                            " Set the function to do the work.
    1              0.000002 setlocal indentexpr=GetJavaIndent()
                            
    1              0.000003 let b:undo_indent = "set cin< cino< indentkeys< indentexpr<"
                            
                            " Only define the function once.
    1              0.000003 if exists("*GetJavaIndent")
                              finish
    1              0.000001 endif
                            
    1              0.000007 let s:keepcpo= &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000009 function! SkipJavaBlanksAndComments(startline)
                              let lnum = a:startline
                              while lnum > 1
                                let lnum = prevnonblank(lnum)
                                if getline(lnum) =~ '\*/\s*$'
                                  while getline(lnum) !~ '/\*' && lnum > 1
                                    let lnum = lnum - 1
                                  endwhile
                                  if getline(lnum) =~ '^\s*/\*'
                                    let lnum = lnum - 1
                                  else
                                    break
                                  endif
                                elseif getline(lnum) =~ '^\s*//'
                                  let lnum = lnum - 1
                                else
                                  break
                                endif
                              endwhile
                              return lnum
                            endfunction
                            
    1              0.000002 function GetJavaIndent()
                            
                              " Java is just like C; use the built-in C indenting and then correct a few
                              " specific cases.
                              let theIndent = cindent(v:lnum)
                            
                              " If we're in the middle of a comment then just trust cindent
                              if getline(v:lnum) =~ '^\s*\*'
                                return theIndent
                              endif
                            
                              " find start of previous line, in case it was a continuation line
                              let lnum = SkipJavaBlanksAndComments(v:lnum - 1)
                            
                              " If the previous line starts with '@', we should have the same indent as
                              " the previous one
                              if getline(lnum) =~ '^\s*@.*$'
                                return indent(lnum)
                              endif
                            
                              let prev = lnum
                              while prev > 1
                                let next_prev = SkipJavaBlanksAndComments(prev - 1)
                                if getline(next_prev) !~ ',\s*$'
                                  break
                                endif
                                let prev = next_prev
                              endwhile
                            
                              " Try to align "throws" lines for methods and "extends" and "implements" for
                              " classes.
                              if getline(v:lnum) =~ '^\s*\(throws\|extends\|implements\)\>'
                                    \ && getline(lnum) !~ '^\s*\(throws\|extends\|implements\)\>'
                                let theIndent = theIndent + shiftwidth()
                              endif
                            
                              " correct for continuation lines of "throws", "implements" and "extends"
                              let cont_kw = matchstr(getline(prev),
                                    \ '^\s*\zs\(throws\|implements\|extends\)\>\ze.*,\s*$')
                              if strlen(cont_kw) > 0
                                let amount = strlen(cont_kw) + 1
                                if getline(lnum) !~ ',\s*$'
                                  let theIndent = theIndent - (amount + shiftwidth())
                                  if theIndent < 0
                                    let theIndent = 0
                                  endif
                                elseif prev == lnum
                                  let theIndent = theIndent + amount
                                  if cont_kw ==# 'throws'
                                    let theIndent = theIndent + shiftwidth()
                                  endif
                                endif
                              elseif getline(prev) =~ '^\s*\(throws\|implements\|extends\)\>'
                                    \ && (getline(prev) =~ '{\s*$'
                                    \  || getline(v:lnum) =~ '^\s*{\s*$')
                                let theIndent = theIndent - shiftwidth()
                              endif
                            
                              " When the line starts with a }, try aligning it with the matching {,
                              " skipping over "throws", "extends" and "implements" clauses.
                              if getline(v:lnum) =~ '^\s*}\s*\(//.*\|/\*.*\)\=$'
                                call cursor(v:lnum, 1)
                                silent normal! %
                                let lnum = line('.')
                                if lnum < v:lnum
                                  while lnum > 1
                                    let next_lnum = SkipJavaBlanksAndComments(lnum - 1)
                                    if getline(lnum) !~ '^\s*\(throws\|extends\|implements\)\>'
                                          \ && getline(next_lnum) !~ ',\s*$'
                                      break
                                    endif
                                    let lnum = prevnonblank(next_lnum)
                                  endwhile
                                  return indent(lnum)
                                endif
                              endif
                            
                              " Below a line starting with "}" never indent more.  Needed for a method
                              " below a method with an indented "throws" clause.
                              let lnum = SkipJavaBlanksAndComments(v:lnum - 1)
                              if getline(lnum) =~ '^\s*}\s*\(//.*\|/\*.*\)\=$' && indent(lnum) < theIndent
                                let theIndent = indent(lnum)
                              endif
                            
                              return theIndent
                            endfunction
                            
    1              0.000009 let &cpo = s:keepcpo
    1              0.000002 unlet s:keepcpo
                            
                            " vi: sw=2 et

SCRIPT  /usr/share/nvim/runtime/syntax/java.vim
Sourced 1 time
Total time:   0.004490
 Self time:   0.002589

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Java
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " URL:          https://github.com/fleiner/vim/blob/master/runtime/syntax/java.vim
                            " Last Change:	2018 July 26
                            
                            " Please check :help java.vim for comments on some of the options available.
                            
                            " quit when a syntax file was already loaded
    1              0.000006 if !exists("main_syntax")
    1              0.000002   if exists("b:current_syntax")
                                finish
    1              0.000001   endif
                              " we define it here so that included files can test for it
    1              0.000004   let main_syntax='java'
    1              0.000024   syn region javaFold start="{" end="}" transparent fold
    1              0.000001 endif
                            
    1              0.000008 let s:cpo_save = &cpo
    1              0.000008 set cpo&vim
                            
                            " some characters that cannot be in a java program (outside a string)
    1              0.000009 syn match javaError "[\\@`]"
    1              0.000004 syn match javaError "<<<\|\.\.\|=>\|||=\|&&=\|\*\/"
                            
    1              0.000005 syn match javaOK "\.\.\."
                            
                            " use separate name so that it can be deleted in javacc.vim
    1              0.000004 syn match   javaError2 "#\|=<"
    1              0.000002 hi def link javaError2 javaError
                            
                            " keyword definitions
    1              0.000004 syn keyword javaExternal	native package
    1              0.000004 syn match javaExternal		"\<import\>\(\s\+static\>\)\?"
    1              0.000002 syn keyword javaError		goto const
    1              0.000004 syn keyword javaConditional	if else switch
    1              0.000004 syn keyword javaRepeat		while for do
    1              0.000007 syn keyword javaBoolean		true false
    1              0.000003 syn keyword javaConstant	null
    1              0.000004 syn keyword javaTypedef		this super
    1              0.000003 syn keyword javaOperator	var new instanceof
    1              0.000004 syn keyword javaType		boolean char byte short int long float double
    1              0.000001 syn keyword javaType		void
    1              0.000003 syn keyword javaStatement	return
    1              0.000004 syn keyword javaStorageClass	static synchronized transient volatile final strictfp serializable
    1              0.000025 syn keyword javaExceptions	throw try catch finally
    1              0.000004 syn keyword javaAssert		assert
    1              0.000004 syn keyword javaMethodDecl	synchronized throws
    1              0.000008 syn keyword javaClassDecl	extends implements interface
                            " to differentiate the keyword class from MyClass.class we use a match here
    1              0.000005 syn match   javaTypedef		"\.\s*\<class\>"ms=s+1
    1              0.000002 syn keyword javaClassDecl	enum
    1              0.000002 syn match   javaClassDecl	"^class\>"
    1              0.000003 syn match   javaClassDecl	"[^.]\s*\<class\>"ms=s+1
    1              0.000016 syn match   javaAnnotation	"@\([_$a-zA-Z][_$a-zA-Z0-9]*\.\)*[_$a-zA-Z][_$a-zA-Z0-9]*\>" contains=javaString
    1              0.000003 syn match   javaClassDecl	"@interface\>"
    1              0.000011 syn keyword javaBranch		break continue nextgroup=javaUserLabelRef skipwhite
    1              0.000002 syn match   javaUserLabelRef	"\k\+" contained
    1              0.000004 syn match   javaVarArg		"\.\.\."
    1              0.000007 syn keyword javaScopeDecl	public protected private abstract
                            
                            " Java Modules(Since Java 9, for "module-info.java" file)
    1              0.000006 if fnamemodify(bufname("%"), ":t") == "module-info.java"
                                syn keyword javaModuleStorageClass	module transitive
                                syn keyword javaModuleStmt		open requires exports opens uses provides
                                syn keyword javaModuleExternal	to with
                                syn cluster javaTop add=javaModuleStorageClass,javaModuleStmt,javaModuleExternal
    1              0.000001 endif
                            
    1              0.000002 if exists("java_highlight_java_lang_ids")
                              let java_highlight_all=1
    1              0.000001 endif
    1              0.000004 if exists("java_highlight_all")  || exists("java_highlight_java")  || exists("java_highlight_java_lang")
                              " java.lang.*
                              syn match javaLangClass "\<System\>"
                              syn keyword javaR_JavaLang NegativeArraySizeException ArrayStoreException IllegalStateException RuntimeException IndexOutOfBoundsException UnsupportedOperationException ArrayIndexOutOfBoundsException ArithmeticException ClassCastException EnumConstantNotPresentException StringIndexOutOfBoundsException IllegalArgumentException IllegalMonitorStateException IllegalThreadStateException NumberFormatException NullPointerException TypeNotPresentException SecurityException
                              syn cluster javaTop add=javaR_JavaLang
                              syn cluster javaClasses add=javaR_JavaLang
                              hi def link javaR_JavaLang javaR_Java
                              syn keyword javaC_JavaLang Process RuntimePermission StringKeySet CharacterData01 Class ThreadLocal ThreadLocalMap CharacterData0E Package Character StringCoding Long ProcessImpl ProcessEnvironment Short AssertionStatusDirectives 1PackageInfoProxy UnicodeBlock InheritableThreadLocal AbstractStringBuilder StringEnvironment ClassLoader ConditionalSpecialCasing CharacterDataPrivateUse StringBuffer StringDecoder Entry StringEntry WrappedHook StringBuilder StrictMath State ThreadGroup Runtime CharacterData02 MethodArray Object CharacterDataUndefined Integer Gate Boolean Enum Variable Subset StringEncoder Void Terminator CharsetSD IntegerCache CharacterCache Byte CharsetSE Thread SystemClassLoaderAction CharacterDataLatin1 StringValues StackTraceElement Shutdown ShortCache String ConverterSD ByteCache Lock EnclosingMethodInfo Math Float Value Double SecurityManager LongCache ProcessBuilder StringEntrySet Compiler Number UNIXProcess ConverterSE ExternalData CaseInsensitiveComparator CharacterData00 NativeLibrary
                              syn cluster javaTop add=javaC_JavaLang
                              syn cluster javaClasses add=javaC_JavaLang
                              hi def link javaC_JavaLang javaC_Java
                              syn keyword javaE_JavaLang IncompatibleClassChangeError InternalError UnknownError ClassCircularityError AssertionError ThreadDeath IllegalAccessError NoClassDefFoundError ClassFormatError UnsupportedClassVersionError NoSuchFieldError VerifyError ExceptionInInitializerError InstantiationError LinkageError NoSuchMethodError Error UnsatisfiedLinkError StackOverflowError AbstractMethodError VirtualMachineError OutOfMemoryError
                              syn cluster javaTop add=javaE_JavaLang
                              syn cluster javaClasses add=javaE_JavaLang
                              hi def link javaE_JavaLang javaE_Java
                              syn keyword javaX_JavaLang CloneNotSupportedException Exception NoSuchMethodException IllegalAccessException NoSuchFieldException Throwable InterruptedException ClassNotFoundException InstantiationException
                              syn cluster javaTop add=javaX_JavaLang
                              syn cluster javaClasses add=javaX_JavaLang
                              hi def link javaX_JavaLang javaX_Java
                            
                              hi def link javaR_Java javaR_
                              hi def link javaC_Java javaC_
                              hi def link javaE_Java javaE_
                              hi def link javaX_Java javaX_
                              hi def link javaX_		     javaExceptions
                              hi def link javaR_		     javaExceptions
                              hi def link javaE_		     javaExceptions
                              hi def link javaC_		     javaConstant
                            
                              syn keyword javaLangObject clone equals finalize getClass hashCode
                              syn keyword javaLangObject notify notifyAll toString wait
                              hi def link javaLangObject		     javaConstant
                              syn cluster javaTop add=javaLangObject
    1              0.000000 endif
                            
    1              0.000013 if filereadable(expand("<sfile>:p:h")."/javaid.vim")
                              source <sfile>:p:h/javaid.vim
    1              0.000000 endif
                            
    1              0.000002 if exists("java_space_errors")
                              if !exists("java_no_trail_space_error")
                                syn match	javaSpaceError	"\s\+$"
                              endif
                              if !exists("java_no_tab_space_error")
                                syn match	javaSpaceError	" \+\t"me=e-1
                              endif
    1              0.000000 endif
                            
    1              0.000022 syn region  javaLabelRegion	transparent matchgroup=javaLabel start="\<case\>" matchgroup=NONE end=":" contains=javaNumber,javaCharacter,javaString
    1              0.000009 syn match   javaUserLabel	"^\s*[_$a-zA-Z][_$a-zA-Z0-9_]*\s*:"he=e-1 contains=javaLabel
    1              0.000001 syn keyword javaLabel		default
                            
                            " highlighting C++ keywords as errors removed, too many people find it
                            " annoying.  Was: if !exists("java_allow_cpp_keywords")
                            
                            " The following cluster contains all java groups except the contained ones
    1              0.000020 syn cluster javaTop add=javaExternal,javaError,javaError,javaBranch,javaLabelRegion,javaLabel,javaConditional,javaRepeat,javaBoolean,javaConstant,javaTypedef,javaOperator,javaType,javaType,javaStatement,javaStorageClass,javaAssert,javaExceptions,javaMethodDecl,javaClassDecl,javaClassDecl,javaClassDecl,javaScopeDecl,javaError,javaError2,javaUserLabel,javaLangObject,javaAnnotation,javaVarArg
                            
                            
                            " Comments
    1              0.000006 syn keyword javaTodo		 contained TODO FIXME XXX
    1              0.000002 if exists("java_comment_strings")
                              syn region  javaCommentString    contained start=+"+ end=+"+ end=+$+ end=+\*/+me=s-1,he=s-1 contains=javaSpecial,javaCommentStar,javaSpecialChar,@Spell
                              syn region  javaComment2String   contained start=+"+	end=+$\|"+  contains=javaSpecial,javaSpecialChar,@Spell
                              syn match   javaCommentCharacter contained "'\\[^']\{1,6\}'" contains=javaSpecialChar
                              syn match   javaCommentCharacter contained "'\\''" contains=javaSpecialChar
                              syn match   javaCommentCharacter contained "'[^\\]'"
                              syn cluster javaCommentSpecial add=javaCommentString,javaCommentCharacter,javaNumber
                              syn cluster javaCommentSpecial2 add=javaComment2String,javaCommentCharacter,javaNumber
    1              0.000001 endif
    1              0.000009 syn region  javaComment		 start="/\*"  end="\*/" contains=@javaCommentSpecial,javaTodo,@Spell
    1              0.000003 syn match   javaCommentStar	 contained "^\s*\*[^/]"me=e-1
    1              0.000005 syn match   javaCommentStar	 contained "^\s*\*$"
    1              0.000007 syn match   javaLineComment	 "//.*" contains=@javaCommentSpecial2,javaTodo,@Spell
    1              0.000004 hi def link javaCommentString javaString
    1              0.000004 hi def link javaComment2String javaString
    1              0.000003 hi def link javaCommentCharacter javaCharacter
                            
    1              0.000005 syn cluster javaTop add=javaComment,javaLineComment
                            
    1              0.000004 if !exists("java_ignore_javadoc") && main_syntax != 'jsp'
    1              0.000001   syntax case ignore
                              " syntax coloring for javadoc comments (HTML)
    1   0.001967   0.000066   syntax include @javaHtml <sfile>:p:h/html.vim
    1              0.000003   unlet b:current_syntax
                              " HTML enables spell checking for all text that is not in a syntax item. This
                              " is wrong for Java (all identifiers would be spell-checked), so it's undone
                              " here.
    1              0.000004   syntax spell default
                            
    1              0.000099   syn region  javaDocComment	start="/\*\*"  end="\*/" keepend contains=javaCommentTitle,@javaHtml,javaDocTags,javaDocSeeTag,javaTodo,@Spell
    1              0.000034   syn region  javaCommentTitle	contained matchgroup=javaDocComment start="/\*\*"   matchgroup=javaCommentTitle keepend end="\.$" end="\.[ \t\r<&]"me=e-1 end="[^{]@"me=s-2,he=s-1 end="\*/"me=s-1,he=s-1 contains=@javaHtml,javaCommentStar,javaTodo,@Spell,javaDocTags,javaDocSeeTag
                            
    1              0.000011   syn region javaDocTags	 contained start="{@\(code\|link\|linkplain\|inherit[Dd]oc\|doc[rR]oot\|value\)" end="}"
    1              0.000031   syn match  javaDocTags	 contained "@\(param\|exception\|throws\|since\)\s\+\S\+" contains=javaDocParam
    1              0.000006   syn match  javaDocParam	 contained "\s\S\+"
    1              0.000008   syn match  javaDocTags	 contained "@\(version\|author\|return\|deprecated\|serial\|serialField\|serialData\)\>"
    1              0.000024   syn region javaDocSeeTag	 contained matchgroup=javaDocTags start="@see\s\+" matchgroup=NONE end="\_."re=e-1 contains=javaDocSeeTagParam
    1              0.000050   syn match  javaDocSeeTagParam  contained @"\_[^"]\+"\|<a\s\+\_.\{-}</a>\|\(\k\|\.\)*\(#\k\+\((\_[^)]\+)\)\=\)\=@ extend
    1              0.000004   syntax case match
    1              0.000002 endif
                            
                            " match the special comment /**/
    1              0.000008 syn match   javaComment		 "/\*\*/"
                            
                            " Strings and constants
    1              0.000027 syn match   javaSpecialError	 contained "\\."
    1              0.000015 syn match   javaSpecialCharError contained "[^']"
    1              0.000013 syn match   javaSpecialChar	 contained "\\\([4-9]\d\|[0-3]\d\d\|[\"\\'ntbrf]\|u\x\{4\}\)"
    1              0.000013 syn region  javaString		start=+"+ end=+"+ end=+$+ contains=javaSpecialChar,javaSpecialError,@Spell
                            " next line disabled, it can cause a crash for a long line
                            "syn match   javaStringError	  +"\([^"\\]\|\\.\)*$+
    1              0.000006 syn match   javaCharacter	 "'[^']*'" contains=javaSpecialChar,javaSpecialCharError
    1              0.000005 syn match   javaCharacter	 "'\\''" contains=javaSpecialChar
    1              0.000003 syn match   javaCharacter	 "'[^\\]'"
    1              0.000015 syn match   javaNumber		 "\<\(0[bB][0-1]\+\|0[0-7]*\|0[xX]\x\+\|\d\(\d\|_\d\)*\)[lL]\=\>"
    1              0.000013 syn match   javaNumber		 "\(\<\d\(\d\|_\d\)*\.\(\d\(\d\|_\d\)*\)\=\|\.\d\(\d\|_\d\)*\)\([eE][-+]\=\d\(\d\|_\d\)*\)\=[fFdD]\="
    1              0.000006 syn match   javaNumber		 "\<\d\(\d\|_\d\)*[eE][-+]\=\d\(\d\|_\d\)*[fFdD]\=\>"
    1              0.000006 syn match   javaNumber		 "\<\d\(\d\|_\d\)*\([eE][-+]\=\d\(\d\|_\d\)*\)\=[fFdD]\>"
                            
                            " unicode characters
    1              0.000004 syn match   javaSpecial "\\u\d\{4\}"
                            
    1              0.000046 syn cluster javaTop add=javaString,javaCharacter,javaNumber,javaSpecial,javaStringError
                            
    1              0.000019 if exists("java_highlight_functions")
                              if java_highlight_functions == "indent"
                                syn match  javaFuncDef "^\(\t\| \{8\}\)[_$a-zA-Z][_$a-zA-Z0-9_. \[\]<>]*([^-+*/]*)" contains=javaScopeDecl,javaType,javaStorageClass,@javaClasses,javaAnnotation
                                syn region javaFuncDef start=+^\(\t\| \{8\}\)[$_a-zA-Z][$_a-zA-Z0-9_. \[\]<>]*([^-+*/]*,\s*+ end=+)+ contains=javaScopeDecl,javaType,javaStorageClass,@javaClasses,javaAnnotation
                                syn match  javaFuncDef "^  [$_a-zA-Z][$_a-zA-Z0-9_. \[\]<>]*([^-+*/]*)" contains=javaScopeDecl,javaType,javaStorageClass,@javaClasses,javaAnnotation
                                syn region javaFuncDef start=+^  [$_a-zA-Z][$_a-zA-Z0-9_. \[\]<>]*([^-+*/]*,\s*+ end=+)+ contains=javaScopeDecl,javaType,javaStorageClass,@javaClasses,javaAnnotation
                              else
                                " This line catches method declarations at any indentation>0, but it assumes
                                " two things:
                                "	1. class names are always capitalized (ie: Button)
                                "	2. method names are never capitalized (except constructors, of course)
                                "syn region javaFuncDef start=+^\s\+\(\(public\|protected\|private\|static\|abstract\|final\|native\|synchronized\)\s\+\)*\(\(void\|boolean\|char\|byte\|short\|int\|long\|float\|double\|\([A-Za-z_][A-Za-z0-9_$]*\.\)*[A-Z][A-Za-z0-9_$]*\)\(<[^>]*>\)\=\(\[\]\)*\s\+[a-z][A-Za-z0-9_$]*\|[A-Z][A-Za-z0-9_$]*\)\s*([^0-9]+ end=+)+ contains=javaScopeDecl,javaType,javaStorageClass,javaComment,javaLineComment,@javaClasses
                                syn region javaFuncDef start=+^\s\+\(\(public\|protected\|private\|static\|abstract\|final\|native\|synchronized\)\s\+\)*\(<.*>\s\+\)\?\(\(void\|boolean\|char\|byte\|short\|int\|long\|float\|double\|\([A-Za-z_][A-Za-z0-9_$]*\.\)*[A-Z][A-Za-z0-9_$]*\)\(<[^(){}]*>\)\=\(\[\]\)*\s\+[a-z][A-Za-z0-9_$]*\|[A-Z][A-Za-z0-9_$]*\)\s*(+ end=+)+ contains=javaScopeDecl,javaType,javaStorageClass,javaComment,javaLineComment,@javaClasses,javaAnnotation
                              endif
                              syn match javaLambdaDef "[a-zA-Z_][a-zA-Z0-9_]*\s*->"
                              syn match  javaBraces  "[{}]"
                              syn cluster javaTop add=javaFuncDef,javaBraces,javaLambdaDef
    1              0.000003 endif
                            
    1              0.000104 if exists("java_highlight_debug")
                            
                              " Strings and constants
                              syn match   javaDebugSpecial		contained "\\\d\d\d\|\\."
                              syn region  javaDebugString		contained start=+"+  end=+"+  contains=javaDebugSpecial
                              syn match   javaDebugStringError	+"\([^"\\]\|\\.\)*$+
                              syn match   javaDebugCharacter	contained "'[^\\]'"
                              syn match   javaDebugSpecialCharacter contained "'\\.'"
                              syn match   javaDebugSpecialCharacter contained "'\\''"
                              syn match   javaDebugNumber		contained "\<\(0[0-7]*\|0[xX]\x\+\|\d\+\)[lL]\=\>"
                              syn match   javaDebugNumber		contained "\(\<\d\+\.\d*\|\.\d\+\)\([eE][-+]\=\d\+\)\=[fFdD]\="
                              syn match   javaDebugNumber		contained "\<\d\+[eE][-+]\=\d\+[fFdD]\=\>"
                              syn match   javaDebugNumber		contained "\<\d\+\([eE][-+]\=\d\+\)\=[fFdD]\>"
                              syn keyword javaDebugBoolean		contained true false
                              syn keyword javaDebugType		contained null this super
                              syn region javaDebugParen  start=+(+ end=+)+ contained contains=javaDebug.*,javaDebugParen
                            
                              " to make this work you must define the highlighting for these groups
                              syn match javaDebug "\<System\.\(out\|err\)\.print\(ln\)*\s*("me=e-1 contains=javaDebug.* nextgroup=javaDebugParen
                              syn match javaDebug "\<p\s*("me=e-1 contains=javaDebug.* nextgroup=javaDebugParen
                              syn match javaDebug "[A-Za-z][a-zA-Z0-9_]*\.printStackTrace\s*("me=e-1 contains=javaDebug.* nextgroup=javaDebugParen
                              syn match javaDebug "\<trace[SL]\=\s*("me=e-1 contains=javaDebug.* nextgroup=javaDebugParen
                            
                              syn cluster javaTop add=javaDebug
                            
                              hi def link javaDebug		 Debug
                              hi def link javaDebugString		 DebugString
                              hi def link javaDebugStringError	 javaError
                              hi def link javaDebugType		 DebugType
                              hi def link javaDebugBoolean		 DebugBoolean
                              hi def link javaDebugNumber		 Debug
                              hi def link javaDebugSpecial		 DebugSpecial
                              hi def link javaDebugSpecialCharacter DebugSpecial
                              hi def link javaDebugCharacter	 DebugString
                              hi def link javaDebugParen		 Debug
                            
                              hi def link DebugString		 String
                              hi def link DebugSpecial		 Special
                              hi def link DebugBoolean		 Boolean
                              hi def link DebugType		 Type
    1              0.000001 endif
                            
    1              0.000005 if exists("java_mark_braces_in_parens_as_errors")
                              syn match javaInParen		 contained "[{}]"
                              hi def link javaInParen	javaError
                              syn cluster javaTop add=javaInParen
    1              0.000000 endif
                            
                            " catch errors caused by wrong parenthesis
    1              0.000022 syn region  javaParenT	transparent matchgroup=javaParen  start="(" end=")" contains=@javaTop,javaParenT1
    1              0.000012 syn region  javaParenT1 transparent matchgroup=javaParen1 start="(" end=")" contains=@javaTop,javaParenT2 contained
    1              0.000007 syn region  javaParenT2 transparent matchgroup=javaParen2 start="(" end=")" contains=@javaTop,javaParenT  contained
    1              0.000005 syn match   javaParenError	 ")"
                            " catch errors caused by wrong square parenthesis
    1              0.000005 syn region  javaParenT	transparent matchgroup=javaParen  start="\[" end="\]" contains=@javaTop,javaParenT1
    1              0.000004 syn region  javaParenT1 transparent matchgroup=javaParen1 start="\[" end="\]" contains=@javaTop,javaParenT2 contained
    1              0.000004 syn region  javaParenT2 transparent matchgroup=javaParen2 start="\[" end="\]" contains=@javaTop,javaParenT  contained
    1              0.000001 syn match   javaParenError	 "\]"
                            
    1              0.000003 hi def link javaParenError	javaError
                            
    1              0.000002 if exists("java_highlight_functions")
                               syn match javaLambdaDef "([a-zA-Z0-9_<>\[\], \t]*)\s*->"
                               " needs to be defined after the parenthesis error catcher to work
    1              0.000000 endif
                            
    1              0.000002 if !exists("java_minlines")
    1              0.000003   let java_minlines = 10
    1              0.000000 endif
    1              0.000009 exec "syn sync ccomment javaComment minlines=" . java_minlines
                            
                            " The default highlighting.
    1              0.000008 hi def link javaLambdaDef		Function
    1              0.000006 hi def link javaFuncDef		Function
    1              0.000003 hi def link javaVarArg			Function
    1              0.000005 hi def link javaBraces			Function
    1              0.000003 hi def link javaBranch			Conditional
    1              0.000002 hi def link javaUserLabelRef		javaUserLabel
    1              0.000003 hi def link javaLabel			Label
    1              0.000003 hi def link javaUserLabel		Label
    1              0.000003 hi def link javaConditional		Conditional
    1              0.000002 hi def link javaRepeat			Repeat
    1              0.000003 hi def link javaExceptions		Exception
    1              0.000003 hi def link javaAssert			Statement
    1              0.000004 hi def link javaStorageClass		StorageClass
    1              0.000002 hi def link javaMethodDecl		javaStorageClass
    1              0.000001 hi def link javaClassDecl		javaStorageClass
    1              0.000001 hi def link javaScopeDecl		javaStorageClass
                            
    1              0.000003 hi def link javaBoolean		Boolean
    1              0.000003 hi def link javaSpecial		Special
    1              0.000003 hi def link javaSpecialError		Error
    1              0.000003 hi def link javaSpecialCharError	Error
    1              0.000003 hi def link javaString			String
    1              0.000003 hi def link javaCharacter		Character
    1              0.000003 hi def link javaSpecialChar		SpecialChar
    1              0.000003 hi def link javaNumber			Number
    1              0.000003 hi def link javaError			Error
    1              0.000003 hi def link javaStringError		Error
    1              0.000003 hi def link javaStatement		Statement
    1              0.000003 hi def link javaOperator		Operator
    1              0.000002 hi def link javaComment		Comment
    1              0.000002 hi def link javaDocComment		Comment
    1              0.000003 hi def link javaLineComment		Comment
    1              0.000003 hi def link javaConstant		Constant
    1              0.000002 hi def link javaTypedef		Typedef
    1              0.000003 hi def link javaTodo			Todo
    1              0.000003 hi def link javaAnnotation		PreProc
                            
    1              0.000003 hi def link javaCommentTitle		SpecialComment
    1              0.000002 hi def link javaDocTags		Special
    1              0.000002 hi def link javaDocParam		Function
    1              0.000002 hi def link javaDocSeeTagParam		Function
    1              0.000001 hi def link javaCommentStar		javaComment
                            
    1              0.000003 hi def link javaType			Type
    1              0.000003 hi def link javaExternal		Include
                            
    1              0.000003 hi def link htmlComment		Special
    1              0.000006 hi def link htmlCommentPart		Special
    1              0.000005 hi def link javaSpaceError		Error
                            
    1              0.000006 if fnamemodify(bufname("%"), ":t") == "module-info.java"
                                hi def link javaModuleStorageClass	StorageClass
                                hi def link javaModuleStmt		Statement
                                hi def link javaModuleExternal	Include
    1              0.000001 endif
                            
    1              0.000002 let b:current_syntax = "java"
                            
    1              0.000002 if main_syntax == 'java'
    1              0.000002   unlet main_syntax
    1              0.000000 endif
                            
    1              0.000001 let b:spell_options="contained"
    1              0.000012 let &cpo = s:cpo_save
    1              0.000001 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/share/nvim/runtime/syntax/html.vim
Sourced 1 time
Total time:   0.001881
 Self time:   0.001881

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:             HTML
                            " Previous Maintainer:  Jorge Maldonado Ventura <jorgesumle@freakspot.net>
                            " Previous Maintainer:  Claudio Fleiner <claudio@fleiner.com>
                            " Repository:           https://notabug.org/jorgesumle/vim-html-syntax
                            " Last Change:          2021 Mar 02
                            "			Included patch #7900 to fix comments
                            "			Included patch #7916 to fix a few more things
                            "
                            
                            " Please check :help html.vim for some comments and a description of the options
                            
                            " quit when a syntax file was already loaded
    1              0.000003 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'html'
    1              0.000000 endif
                            
    1              0.000008 let s:cpo_save = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000001 syntax spell toplevel
                            
    1              0.000001 syn case ignore
                            
                            " mark illegal characters
    1              0.000007 syn match htmlError "[<>&]"
                            
                            
                            " tags
    1              0.000015 syn region  htmlString   contained start=+"+ end=+"+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    1              0.000005 syn region  htmlString   contained start=+'+ end=+'+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    1              0.000007 syn match   htmlValue    contained "=[\t ]*[^'" \t>][^ \t>]*"hs=s+1   contains=javaScriptExpression,@htmlPreproc
    1              0.000012 syn region  htmlEndTag             start=+</+      end=+>+ contains=htmlTagN,htmlTagError
    1              0.000018 syn region  htmlTag                start=+<[^/]+   end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent,htmlCssDefinition,@htmlPreproc,@htmlArgCluster
    1              0.000011 syn match   htmlTagN     contained +<\s*[-a-zA-Z0-9]\++hs=s+1 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    1              0.000004 syn match   htmlTagN     contained +</\s*[-a-zA-Z0-9]\++hs=s+2 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    1              0.000002 syn match   htmlTagError contained "[^>]<"ms=s+1
                            
                            
                            " tag names
    1              0.000003 syn keyword htmlTagName contained address applet area a base basefont
    1              0.000002 syn keyword htmlTagName contained big blockquote br caption center
    1              0.000003 syn keyword htmlTagName contained cite code dd dfn dir div dl dt font
    1              0.000002 syn keyword htmlTagName contained form hr html img
    1              0.000002 syn keyword htmlTagName contained input isindex kbd li link map menu
    1              0.000002 syn keyword htmlTagName contained meta ol option param pre p samp span
    1              0.000002 syn keyword htmlTagName contained select small sub sup
    1              0.000009 syn keyword htmlTagName contained table td textarea th tr tt ul var xmp
    1              0.000005 syn match htmlTagName contained "\<\(b\|i\|u\|h[1-6]\|em\|strong\|head\|body\|title\)\>"
                            
                            " new html 4.0 tags
    1              0.000002 syn keyword htmlTagName contained abbr acronym bdo button col label
    1              0.000002 syn keyword htmlTagName contained colgroup fieldset iframe ins legend
    1              0.000002 syn keyword htmlTagName contained object optgroup q s tbody tfoot thead
                            
                            " new html 5 tags
    1              0.000002 syn keyword htmlTagName contained article aside audio bdi canvas data
    1              0.000002 syn keyword htmlTagName contained datalist details dialog embed figcaption
    1              0.000002 syn keyword htmlTagName contained figure footer header hgroup keygen main
    1              0.000002 syn keyword htmlTagName contained mark menuitem meter nav output picture
    1              0.000002 syn keyword htmlTagName contained progress rb rp rt rtc ruby section
    1              0.000002 syn keyword htmlTagName contained slot source summary template time track
    1              0.000001 syn keyword htmlTagName contained video wbr
                            
                            " legal arg names
    1              0.000001 syn keyword htmlArg contained action
    1              0.000002 syn keyword htmlArg contained align alink alt archive background bgcolor
    1              0.000001 syn keyword htmlArg contained border bordercolor cellpadding
    1              0.000003 syn keyword htmlArg contained cellspacing checked class clear code codebase color
    1              0.000002 syn keyword htmlArg contained cols colspan content coords enctype face
    1              0.000001 syn keyword htmlArg contained gutter height hspace id
    1              0.000002 syn keyword htmlArg contained link lowsrc marginheight
    1              0.000002 syn keyword htmlArg contained marginwidth maxlength method name prompt
    1              0.000002 syn keyword htmlArg contained rel rev rows rowspan scrolling selected shape
    1              0.000002 syn keyword htmlArg contained size src start target text type url
    1              0.000002 syn keyword htmlArg contained usemap ismap valign value vlink vspace width wrap
    1              0.000004 syn match   htmlArg contained "\<\(http-equiv\|href\|title\)="me=e-1
                            
                            " aria attributes
    1              0.000061 exe 'syn match htmlArg contained "\<aria-\%(' . join([
                                \ 'activedescendant', 'atomic', 'autocomplete', 'busy', 'checked', 'colcount',
                                \ 'colindex', 'colspan', 'controls', 'current', 'describedby', 'details',
                                \ 'disabled', 'dropeffect', 'errormessage', 'expanded', 'flowto', 'grabbed',
                                \ 'haspopup', 'hidden', 'invalid', 'keyshortcuts', 'label', 'labelledby', 'level',
                                \ 'live', 'modal', 'multiline', 'multiselectable', 'orientation', 'owns',
                                \ 'placeholder', 'posinset', 'pressed', 'readonly', 'relevant', 'required',
                                \ 'roledescription', 'rowcount', 'rowindex', 'rowspan', 'selected', 'setsize',
                                \ 'sort', 'valuemax', 'valuemin', 'valuenow', 'valuetext'
                                \ ], '\|') . '\)\>"'
    1              0.000002 syn keyword htmlArg contained role
                            
                            " Netscape extensions
    1              0.000002 syn keyword htmlTagName contained frame noframes frameset nobr blink
    1              0.000015 syn keyword htmlTagName contained layer ilayer nolayer spacer
    1              0.000018 syn keyword htmlArg     contained frameborder noresize pagex pagey above below
    1              0.000013 syn keyword htmlArg     contained left top visibility clip id noshade
    1              0.000002 syn match   htmlArg     contained "\<z-index\>"
                            
                            " Microsoft extensions
    1              0.000008 syn keyword htmlTagName contained marquee
                            
                            " html 4.0 arg names
    1              0.000003 syn match   htmlArg contained "\<\(accept-charset\|label\)\>"
    1              0.000015 syn keyword htmlArg contained abbr accept accesskey axis char charoff charset
    1              0.000010 syn keyword htmlArg contained cite classid codetype compact data datetime
    1              0.000010 syn keyword htmlArg contained declare defer dir disabled for frame
    1              0.000011 syn keyword htmlArg contained headers hreflang lang language longdesc
    1              0.000002 syn keyword htmlArg contained multiple nohref nowrap object profile readonly
    1              0.000002 syn keyword htmlArg contained rules scheme scope span standby style
    1              0.000002 syn keyword htmlArg contained summary tabindex valuetype version
                            
                            " html 5 arg names
    1              0.000002 syn keyword htmlArg contained allowfullscreen async autocomplete autofocus
    1              0.000002 syn keyword htmlArg contained autoplay challenge contenteditable contextmenu
    1              0.000002 syn keyword htmlArg contained controls crossorigin default dirname download
    1              0.000002 syn keyword htmlArg contained draggable dropzone form formaction formenctype
    1              0.000002 syn keyword htmlArg contained formmethod formnovalidate formtarget hidden
    1              0.000002 syn keyword htmlArg contained high icon inputmode keytype kind list loop low
    1              0.000002 syn keyword htmlArg contained max min minlength muted nonce novalidate open
    1              0.000002 syn keyword htmlArg contained optimum pattern placeholder poster preload
    1              0.000002 syn keyword htmlArg contained radiogroup required reversed sandbox spellcheck
    1              0.000002 syn keyword htmlArg contained sizes srcset srcdoc srclang step title translate
    1              0.000001 syn keyword htmlArg contained typemustmatch
                            
                            " special characters
    1              0.000006 syn match htmlSpecialChar "&#\=[0-9A-Za-z]\{1,8};"
                            
                            " Comments (the real ones or the old netscape ones)
    1              0.000002 if exists("html_wrong_comments")
                              syn region htmlComment        start=+<!--+    end=+--\s*>+    contains=@Spell
    1              0.000001 else
                              " The HTML 5.2 syntax 8.2.4.41: bogus comment is parser error; browser skips until next &gt
    1              0.000012   syn region htmlComment        start=+<!+      end=+>+         contains=htmlCommentError keepend
                              " Idem 8.2.4.42,51: Comment starts with <!-- and ends with -->
                              " Idem 8.2.4.43,44: Except <!--> and <!---> are parser errors
                              " Idem 8.2.4.52: dash-dash-bang (--!>) is error ignored by parser, also closes comment
    1              0.000011   syn region htmlComment matchgroup=htmlComment start=+<!--\%(-\?>\)\@!+        end=+--!\?>+    contains=htmlCommentNested,@htmlPreProc,@Spell keepend
                              " Idem 8.2.4.49: nested comment is parser error, except <!--> is all right
    1              0.000003   syn match htmlCommentNested contained "<!-->\@!"
    1              0.000003   syn match htmlCommentError  contained "[^><!]"
    1              0.000001 endif
    1              0.000005 syn region htmlComment  start=+<!DOCTYPE+       end=+>+ keepend
                            
                            " server-parsed commands
    1              0.000015 syn region htmlPreProc start=+<!--#+ end=+-->+ contains=htmlPreStmt,htmlPreError,htmlPreAttr
    1              0.000006 syn match htmlPreStmt contained "<!--#\(config\|echo\|exec\|fsize\|flastmod\|include\|printenv\|set\|if\|elif\|else\|endif\|geoguide\)\>"
    1              0.000002 syn match htmlPreError contained "<!--#\S*"ms=s+4
    1              0.000009 syn match htmlPreAttr contained "\w\+=[^"]\S\+" contains=htmlPreProcAttrError,htmlPreProcAttrName
    1              0.000006 syn region htmlPreAttr contained start=+\w\+="+ skip=+\\\\\|\\"+ end=+"+ contains=htmlPreProcAttrName keepend
    1              0.000002 syn match htmlPreProcAttrError contained "\w\+="he=e-1
    1              0.000005 syn match htmlPreProcAttrName contained "\(expr\|errmsg\|sizefmt\|timefmt\|var\|cgi\|cmd\|file\|virtual\|value\)="he=e-1
                            
    1              0.000002 if !exists("html_no_rendering")
                              " rendering
    1              0.000013   syn cluster htmlTop contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,javaScript,@htmlPreproc
                            
    1              0.000009   syn region htmlStrike start="<del\>" end="</del\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlStrike start="<strike\>" end="</strike\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000013   syn region htmlBold start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    1              0.000006   syn region htmlBold start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    1              0.000007   syn region htmlBoldUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderlineItalic
    1              0.000030   syn region htmlBoldItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlBoldItalicUnderline
    1              0.000009   syn region htmlBoldItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop,htmlBoldItalicUnderline
    1              0.000005   syn region htmlBoldUnderlineItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop
    1              0.000003   syn region htmlBoldUnderlineItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
    1              0.000004   syn region htmlBoldItalicUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderlineItalic
                            
    1              0.000012   syn region htmlUnderline start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBold,htmlUnderlineItalic
    1              0.000006   syn region htmlUnderlineBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBoldItalic
    1              0.000004   syn region htmlUnderlineBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBoldItalic
    1              0.000006   syn region htmlUnderlineItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineItalicBold
    1              0.000004   syn region htmlUnderlineItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineItalicBold
    1              0.000005   syn region htmlUnderlineItalicBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop
    1              0.000004   syn region htmlUnderlineItalicBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop
    1              0.000003   syn region htmlUnderlineBoldItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop
    1              0.000003   syn region htmlUnderlineBoldItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000012   syn region htmlItalic start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlItalicBold,htmlItalicUnderline
    1              0.000012   syn region htmlItalic start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
    1              0.000007   syn region htmlItalicBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlItalicBoldUnderline
    1              0.000005   syn region htmlItalicBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlItalicBoldUnderline
    1              0.000003   syn region htmlItalicBoldUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlItalicUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlItalicUnderlineBold
    1              0.000003   syn region htmlItalicUnderlineBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop
    1              0.000004   syn region htmlItalicUnderlineBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000005   syn match htmlLeadingSpace "^\s\+" contained
    1              0.000010   syn region htmlLink start="<a\>\_[^>]*\<href\>" end="</a\_s*>"me=s-1 contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLeadingSpace,javaScript,@htmlPreproc
    1              0.000007   syn region htmlH1 start="<h1\>" end="</h1\_s*>"me=s-1 contains=@htmlTop
    1              0.000007   syn region htmlH2 start="<h2\>" end="</h2\_s*>"me=s-1 contains=@htmlTop
    1              0.000011   syn region htmlH3 start="<h3\>" end="</h3\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlH4 start="<h4\>" end="</h4\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlH5 start="<h5\>" end="</h5\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlH6 start="<h6\>" end="</h6\_s*>"me=s-1 contains=@htmlTop
    1              0.000023   syn region htmlHead start="<head\>" end="</head\_s*>"me=s-1 end="<body\>"me=s-1 end="<h[1-6]\>"me=s-1 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,htmlTitle,javaScript,cssStyle,@htmlPreproc
    1              0.000008   syn region htmlTitle start="<title\>" end="</title\_s*>"me=s-1 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,javaScript,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000002 syn keyword htmlTagName         contained noscript
    1              0.000002 syn keyword htmlSpecialTagName  contained script style
    1              0.000003 if main_syntax != 'java' || exists("java_javascript")
                              " JAVA SCRIPT
                              syn include @htmlJavaScript syntax/javascript.vim
                              unlet b:current_syntax
                              syn region  javaScript start=+<script\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlJavaScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
                              syn region  htmlScriptTag     contained start=+<script+ end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent
                              hi def link htmlScriptTag htmlTag
                            
                              " html events (i.e. arguments that include javascript commands)
                              if exists("html_extended_events")
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ contains=htmlEventSQ
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ contains=htmlEventDQ
                              else
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ keepend contains=htmlEventSQ
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ keepend contains=htmlEventDQ
                              endif
                              syn region htmlEventSQ        contained start=+'+ms=s+1 end=+'+me=s-1 contains=@htmlJavaScript
                              syn region htmlEventDQ        contained start=+"+ms=s+1 end=+"+me=s-1 contains=@htmlJavaScript
                              hi def link htmlEventSQ htmlEvent
                              hi def link htmlEventDQ htmlEvent
                            
                              " a javascript expression is used as an arg value
                              syn region  javaScriptExpression contained start=+&{+ keepend end=+};+ contains=@htmlJavaScript,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000003 if main_syntax != 'java' || exists("java_vb")
                              " VB SCRIPT
                              syn include @htmlVbScript syntax/vb.vim
                              unlet b:current_syntax
                              syn region  javaScript start=+<script \_[^>]*language *=\_[^>]*vbscript\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlVbScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000003 syn cluster htmlJavaScript      add=@htmlPreproc
                            
    1              0.000002 if main_syntax != 'java' || exists("java_css")
                              " embedded style sheets
                              syn keyword htmlArg           contained media
                              syn include @htmlCss syntax/css.vim
                              unlet b:current_syntax
                              syn region cssStyle start=+<style+ keepend end=+</style>+ contains=@htmlCss,htmlTag,htmlEndTag,htmlCssStyleComment,@htmlPreproc
                              syn match htmlCssStyleComment contained "\(<!--\|-->\)"
                              syn region htmlCssDefinition matchgroup=htmlArg start='style="' keepend matchgroup=htmlString end='"' contains=css.*Attr,css.*Prop,cssComment,cssLength,cssColor,cssURL,cssImportant,cssError,cssString,@htmlPreproc
                              hi def link htmlStyleArg htmlString
    1              0.000004 endif
                            
    1              0.000008 if main_syntax == "html"
                              " synchronizing (does not always work if a comment includes legal
                              " html tags, but doing it right would mean to always start
                              " at the first line, which is too slow)
                              syn sync match htmlHighlight groupthere NONE "<[/a-zA-Z]"
                              syn sync match htmlHighlight groupthere javaScript "<script"
                              syn sync match htmlHighlightSkip "^.*['\"].*$"
                              syn sync minlines=10
    1              0.000002 endif
                            
                            " The default highlighting.
    1              0.000045 hi def link htmlTag                     Function
    1              0.000024 hi def link htmlEndTag                  Identifier
    1              0.000028 hi def link htmlArg                     Type
    1              0.000034 hi def link htmlTagName                 htmlStatement
    1              0.000026 hi def link htmlSpecialTagName          Exception
    1              0.000028 hi def link htmlValue                   String
    1              0.000030 hi def link htmlSpecialChar             Special
                            
    1              0.000027 if !exists("html_no_rendering")
    1              0.000052   hi def link htmlH1                      Title
    1              0.000004   hi def link htmlH2                      htmlH1
    1              0.000001   hi def link htmlH3                      htmlH2
    1              0.000002   hi def link htmlH4                      htmlH3
    1              0.000002   hi def link htmlH5                      htmlH4
    1              0.000002   hi def link htmlH6                      htmlH5
    1              0.000024   hi def link htmlHead                    PreProc
    1              0.000024   hi def link htmlTitle                   Title
    1              0.000008   hi def link htmlBoldItalicUnderline     htmlBoldUnderlineItalic
    1              0.000002   hi def link htmlUnderlineBold           htmlBoldUnderline
    1              0.000001   hi def link htmlUnderlineItalicBold     htmlBoldUnderlineItalic
    1              0.000006   hi def link htmlUnderlineBoldItalic     htmlBoldUnderlineItalic
    1              0.000001   hi def link htmlItalicUnderline         htmlUnderlineItalic
    1              0.000001   hi def link htmlItalicBold              htmlBoldItalic
    1              0.000001   hi def link htmlItalicBoldUnderline     htmlBoldUnderlineItalic
    1              0.000001   hi def link htmlItalicUnderlineBold     htmlBoldUnderlineItalic
    1              0.000005   hi def link htmlLink                    Underlined
    1              0.000005   hi def link htmlLeadingSpace            None
    1              0.000002   if !exists("html_my_rendering")
    1              0.000015     hi def htmlBold                term=bold cterm=bold gui=bold
    1              0.000057     hi def htmlBoldUnderline       term=bold,underline cterm=bold,underline gui=bold,underline
    1              0.000012     hi def htmlBoldItalic          term=bold,italic cterm=bold,italic gui=bold,italic
    1              0.000005     hi def htmlBoldUnderlineItalic term=bold,italic,underline cterm=bold,italic,underline gui=bold,italic,underline
    1              0.000004     hi def htmlUnderline           term=underline cterm=underline gui=underline
    1              0.000003     hi def htmlUnderlineItalic     term=italic,underline cterm=italic,underline gui=italic,underline
    1              0.000002     hi def htmlItalic              term=italic cterm=italic gui=italic
    1              0.000036     if v:version > 800 || v:version == 800 && has("patch1038")
    1              0.000011         hi def htmlStrike              term=strikethrough cterm=strikethrough gui=strikethrough
                                else
                                    hi def htmlStrike              term=underline cterm=underline gui=underline
    1              0.000001     endif
    1              0.000001   endif
    1              0.000000 endif
                            
    1              0.000051 hi def link htmlPreStmt            PreProc
    1              0.000010 hi def link htmlPreError           Error
    1              0.000005 hi def link htmlPreProc            PreProc
    1              0.000009 hi def link htmlPreAttr            String
    1              0.000007 hi def link htmlPreProcAttrName    PreProc
    1              0.000004 hi def link htmlPreProcAttrError   Error
    1              0.000005 hi def link htmlString             String
    1              0.000004 hi def link htmlStatement          Statement
    1              0.000003 hi def link htmlComment            Comment
    1              0.000001 hi def link htmlCommentNested      htmlError
    1              0.000001 hi def link htmlCommentError       htmlError
    1              0.000002 hi def link htmlTagError           htmlError
    1              0.000001 hi def link htmlEvent              javaScript
    1              0.000007 hi def link htmlError              Error
                            
    1              0.000005 hi def link javaScript             Special
    1              0.000003 hi def link javaScriptExpression   javaScript
    1              0.000003 hi def link htmlCssStyleComment    Comment
    1              0.000004 hi def link htmlCssDefinition      Special
                            
    1              0.000008 let b:current_syntax = "html"
                            
    1              0.000004 if main_syntax == 'html'
                              unlet main_syntax
    1              0.000001 endif
                            
    1              0.000031 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save
                            " vim: ts=8

SCRIPT  /home/root99/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim
Sourced 1 time
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    1              0.000012 let s:available = has('nvim') || (
                                  \   has('job') && (
                                  \     (has('patch-7-4-1826') && !has('gui_running')) ||
                                  \     (has('patch-7-4-1850') &&  has('gui_running')) ||
                                  \     (has('patch-7-4-1832') &&  has('gui_macvim'))
                                  \   )
                                  \ )
                            
    1              0.000001 let s:jobs = {}
                            
    1              0.000002 function! gitgutter#async#available()
                              return s:available
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#async#execute(cmd, bufnr, handler) abort
                              call gitgutter#debug#log('[async] '.a:cmd)
                            
                              let options = {
                                    \   'stdoutbuffer': [],
                                    \   'buffer': a:bufnr,
                                    \   'handler': a:handler
                                    \ }
                              let command = s:build_command(a:cmd)
                            
                              if has('nvim')
                                call jobstart(command, extend(options, {
                                      \   'on_stdout': function('s:on_stdout_nvim'),
                                      \   'on_stderr': function('s:on_stderr_nvim'),
                                      \   'on_exit':   function('s:on_exit_nvim')
                                      \ }))
                              else
                                let job = job_start(command, {
                                      \   'out_cb':   function('s:on_stdout_vim', options),
                                      \   'err_cb':   function('s:on_stderr_vim', options),
                                      \   'close_cb': function('s:on_exit_vim', options)
                                      \ })
                                let s:jobs[s:job_id(job)] = 1
                              endif
                            endfunction
                            
                            
    1              0.000002 function! s:build_command(cmd)
                              if has('unix')
                                return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'
                            endfunction
                            
                            
    1              0.000002 function! s:on_stdout_nvim(_job_id, data, _event) dict abort
                              if empty(self.stdoutbuffer)
                                let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] +
                                      \ [self.stdoutbuffer[-1] . a:data[0]] +
                                      \ a:data[1:]
                              endif
                            endfunction
                            
    1              0.000001 function! s:on_stderr_nvim(_job_id, data, _event) dict abort
                              if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
                              endif
                            endfunction
                            
    1              0.000001 function! s:on_exit_nvim(_job_id, exit_code, _event) dict abort
                              if !a:exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction
                            
                            
    1              0.000001 function! s:on_stdout_vim(_channel, data) dict abort
                              call add(self.stdoutbuffer, a:data)
                            endfunction
                            
    1              0.000001 function! s:on_stderr_vim(channel, _data) dict abort
                              call self.handler.err(self.buffer)
                            endfunction
                            
    1              0.000001 function! s:on_exit_vim(channel) dict abort
                              let job = ch_getjob(a:channel)
                              let jobid = s:job_id(job)
                              if has_key(s:jobs, jobid) | unlet s:jobs[jobid] | endif
                              while 1
                                if job_status(job) == 'dead'
                                  let exit_code = job_info(job).exitval
                                  break
                                endif
                                sleep 5m
                              endwhile
                            
                              if !exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction
                            
    1              0.000001 function! s:job_id(job)
                              " Vim
                              return job_info(a:job).process
                            endfunction

SCRIPT  /home/root99/.vim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim
Sourced 1 time
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    1              0.000008 let s:plugin_dir  = expand('<sfile>:p:h:h:h').'/'
    1              0.000002 let s:log_file    = s:plugin_dir.'gitgutter.log'
    1              0.000002 let s:channel_log = s:plugin_dir.'channel.log'
    1              0.000001 let s:new_log_session = 1
                            
                            
    1              0.000003 function! gitgutter#debug#debug()
                              " Open a scratch buffer
                              vsplit __GitGutter_Debug__
                              normal! ggdG
                              setlocal buftype=nofile
                              setlocal bufhidden=delete
                              setlocal noswapfile
                            
                              call s:vim_version()
                              call s:separator()
                            
                              call s:git_version()
                              call s:separator()
                            
                              call s:grep_version()
                              call s:separator()
                            
                              call s:option('updatetime')
                            endfunction
                            
                            
    1              0.000001 function! s:separator()
                              call s:output('')
                            endfunction
                            
    1              0.000001 function! s:vim_version()
                              redir => version_info
                                silent execute 'version'
                              redir END
                              call s:output(split(version_info, '\n')[0:2])
                            endfunction
                            
    1              0.000001 function! s:git_version()
                              let v = system(g:gitgutter_git_executable.' --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            endfunction
                            
    1              0.000001 function! s:grep_version()
                              let v = system(g:gitgutter_grep.' --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            
                              let v = system(g:gitgutter_grep.' --help')
                              call s:output( substitute(v, '\%x00', '', 'g') )
                            endfunction
                            
    1              0.000001 function! s:option(name)
                              if exists('+' . a:name)
                                let v = eval('&' . a:name)
                                call s:output(a:name . '=' . v)
                                " redir => output
                                "   silent execute "verbose set " . a:name . "?"
                                " redir END
                                " call s:output(a:name . '=' . output)
                              else
                                call s:output(a:name . ' [n/a]')
                              end
                            endfunction
                            
    1              0.000001 function! s:output(text)
                              call append(line('$'), a:text)
                            endfunction
                            
                            " assumes optional args are calling function's optional args
    1              0.000001 function! gitgutter#debug#log(message, ...) abort
                              if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif
                            endfunction
                            
    1              0.000001 function! s:format_for_log(data) abort
                              if type(a:data) == 1
                                return join(split(a:data,'\n'),"\n")
                              elseif type(a:data) == 3
                                return '['.join(a:data,"\n").']'
                              else
                                return a:data
                              endif
                            endfunction
                            

SCRIPT  /home/root99/.vim/plugged/vim-fugitive/autoload/fugitive.vim
Sourced 1 time
Total time:   0.004319
 Self time:   0.003910

count  total (s)   self (s)
                            " Location:     autoload/fugitive.vim
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            
                            " The functions contained within this file are for internal use only.  For the
                            " official API, see the commented functions in plugin/fugitive.vim.
                            
    1              0.000003 if exists('g:autoloaded_fugitive')
                              finish
    1              0.000001 endif
    1              0.000002 let g:autoloaded_fugitive = 1
                            
                            " Section: Utility
                            
    1              0.000003 function! s:function(name) abort
                              return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '.*\zs<SNR>\d\+_'),''))
                            endfunction
                            
    1              0.000002 function! s:sub(str,pat,rep) abort
                              return substitute(a:str,'\v\C'.a:pat,a:rep,'')
                            endfunction
                            
    1              0.000001 function! s:gsub(str,pat,rep) abort
                              return substitute(a:str,'\v\C'.a:pat,a:rep,'g')
                            endfunction
                            
    1              0.000001 function! s:Uniq(list) abort
                              let i = 0
                              let seen = {}
                              while i < len(a:list)
                                let str = string(a:list[i])
                                if has_key(seen, str)
                                  call remove(a:list, i)
                                else
                                  let seen[str] = 1
                                  let i += 1
                                endif
                              endwhile
                              return a:list
                            endfunction
                            
    1              0.000001 function! s:JoinChomp(list) abort
                              if empty(a:list[-1])
                                return join(a:list[0:-2], "\n")
                              else
                                return join(a:list, "\n")
                              endif
                            endfunction
                            
    1              0.000001 function! s:winshell() abort
                              return has('win32') && &shellcmdflag !~# '^-'
                            endfunction
                            
    1              0.000001 function! s:WinShellEsc(arg) abort
                              if type(a:arg) == type([])
                                return join(map(copy(a:arg), 's:WinShellEsc(v:val)'))
                              elseif a:arg =~# '^[A-Za-z0-9_/:.-]\+$'
                                return a:arg
                              else
                                return '"' . s:gsub(s:gsub(a:arg, '"', '""'), '\%', '"%"') . '"'
                              endif
                            endfunction
                            
    1              0.000001 function! s:shellesc(arg) abort
                              if type(a:arg) == type([])
                                return join(map(copy(a:arg), 's:shellesc(v:val)'))
                              elseif a:arg =~# '^[A-Za-z0-9_/:.-]\+$'
                                return a:arg
                              elseif s:winshell()
                                return '"' . s:gsub(s:gsub(a:arg, '"', '""'), '\%', '"%"') . '"'
                              else
                                return shellescape(a:arg)
                              endif
                            endfunction
                            
    1              0.000002 let s:fnameescape = " \t\n*?[{`$\\%#'\"|!<"
    1              0.000001 function! s:fnameescape(file) abort
                              if type(a:file) == type([])
                                return join(map(copy(a:file), 's:fnameescape(v:val)'))
                              elseif exists('*fnameescape')
                                return fnameescape(a:file)
                              else
                                return escape(a:file, s:fnameescape)
                              endif
                            endfunction
                            
    1              0.000001 function! s:throw(string) abort
                              throw 'fugitive: '.a:string
                            endfunction
                            
    1              0.000001 function! s:VersionCheck() abort
                              if v:version < 703
                                return 'return ' . string('echoerr "fugitive: Vim 7.3 or newer required"')
                              elseif empty(fugitive#GitVersion())
                                let exe = get(s:GitCmd(), 0, '')
                                if len(exe) && !executable(exe)
                                  return 'return ' . string('echoerr "fugitive: cannot find ' . string(exe) . ' in PATH"')
                                endif
                                return 'return ' . string('echoerr "fugitive: cannot execute Git"')
                              elseif !fugitive#GitVersion(1, 8, 5)
                                return 'return ' . string('echoerr "fugitive: Git 1.8.5 or newer required"')
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000002 let s:worktree_error = "core.worktree is required when using an external Git dir"
    1              0.000001 function! s:DirCheck(...) abort
                              let vcheck = s:VersionCheck()
                              if !empty(vcheck)
                                return vcheck
                              endif
                              let dir = call('FugitiveGitDir', a:000)
                              if !empty(dir) && FugitiveWorkTree(dir, 1) is# 0
                                return 'return ' . string('echoerr "fugitive: ' . s:worktree_error . '"')
                              elseif !empty(dir)
                                return ''
                              elseif empty(bufname(''))
                                return 'return ' . string('echoerr "fugitive: working directory does not belong to a Git repository"')
                              else
                                return 'return ' . string('echoerr "fugitive: file does not belong to a Git repository"')
                              endif
                            endfunction
                            
    1              0.000001 function! s:Mods(mods, ...) abort
                              let mods = substitute(a:mods, '\C<mods>', '', '')
                              let mods = mods =~# '\S$' ? mods . ' ' : mods
                              if a:0 && mods !~# '\<\%(aboveleft\|belowright\|leftabove\|rightbelow\|topleft\|botright\|tab\)\>'
                                let mods = a:1 . ' ' . mods
                              endif
                              return substitute(mods, '\s\+', ' ', 'g')
                            endfunction
                            
    1              0.000002 if exists('+shellslash')
                              function! s:Slash(path) abort
                                return tr(a:path, '\', '/')
                              endfunction
    1              0.000001 else
    1              0.000001   function! s:Slash(path) abort
                                return a:path
                              endfunction
    1              0.000001 endif
                            
    1              0.000001 function! s:Resolve(path) abort
                              let path = resolve(a:path)
                              if has('win32')
                                let path = FugitiveVimPath(fnamemodify(fnamemodify(path, ':h'), ':p') . fnamemodify(path, ':t'))
                              endif
                              return path
                            endfunction
                            
    1              0.000001 function! s:FileIgnoreCase(for_completion) abort
                              return (exists('+fileignorecase') && &fileignorecase)
                                    \ || (a:for_completion && exists('+wildignorecase') && &wildignorecase)
                            endfunction
                            
    1              0.000001 function! s:cpath(path, ...) abort
                              if s:FileIgnoreCase(0)
                                let path = FugitiveVimPath(tolower(a:path))
                              else
                                let path = FugitiveVimPath(a:path)
                              endif
                              return a:0 ? path ==# s:cpath(a:1) : path
                            endfunction
                            
    1              0.000001 let s:executables = {}
                            
    1              0.000001 function! s:executable(binary) abort
                              if !has_key(s:executables, a:binary)
                                let s:executables[a:binary] = executable(a:binary)
                              endif
                              return s:executables[a:binary]
                            endfunction
                            
    1              0.000002 if !exists('s:temp_scripts')
    1              0.000001   let s:temp_scripts = {}
    1              0.000000 endif
    1              0.000001 function! s:TempScript(...) abort
                              let body = join(a:000, "\n")
                              if !has_key(s:temp_scripts, body)
                                let s:temp_scripts[body] = tempname() . '.sh'
                              endif
                              let temp = s:temp_scripts[body]
                              if !filereadable(temp)
                                call writefile(['#!/bin/sh'] + a:000, temp)
                              endif
                              return FugitiveGitPath(temp)
                            endfunction
                            
    1              0.000001 function! s:DoAutocmd(...) abort
                              if v:version >= 704 || (v:version == 703 && has('patch442'))
                                return join(map(copy(a:000), "'doautocmd <nomodeline>' . v:val"), '|')
                              elseif &modelines > 0
                                return 'try|set modelines=0|' . join(map(copy(a:000), "'doautocmd ' . v:val"), '|') . '|finally|set modelines=' . &modelines . '|endtry'
                              else
                                return join(map(copy(a:000), "'doautocmd ' . v:val"), '|')
                              endif
                            endfunction
                            
    1              0.000002 let s:nowait = v:version >= 704 ? '<nowait>' : ''
                            
    1              0.000001 function! s:Map(mode, lhs, rhs, ...) abort
                              let maps = []
                              for mode in split(a:mode, '\zs')
                                let skip = 0
                                let flags = (a:0 ? a:1 : '') . (a:rhs =~# '<Plug>' ? '' : '<script>')
                                let head = a:lhs
                                let tail = ''
                                let keys = get(g:, mode.'remap', {})
                                if type(keys) == type([])
                                  continue
                                endif
                                while !empty(head)
                                  if has_key(keys, head)
                                    let head = keys[head]
                                    let skip = empty(head)
                                    break
                                  endif
                                  let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
                                  let head = substitute(head, '<[^<>]*>$\|.$', '', '')
                                endwhile
                                if !skip && flags !~# '<unique>' || empty(mapcheck(head.tail, mode))
                                  call add(maps, mode.'map <buffer>' . s:nowait . flags . ' ' . head.tail . ' ' . a:rhs)
                                  if a:0 > 1
                                    let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') .
                                          \ '|sil! exe "' . mode . 'unmap <buffer> ' . head.tail . '"'
                                  endif
                                endif
                              endfor
                              exe join(maps, '|')
                              return ''
                            endfunction
                            
    1              0.000001 function! fugitive#Autowrite() abort
                              if &autowrite || &autowriteall
                                try
                                  if &confirm
                                    let reconfirm = 1
                                    setglobal noconfirm
                                  endif
                                  silent! wall
                                finally
                                  if exists('reconfirm')
                                    setglobal confirm
                                  endif
                                endtry
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! fugitive#Wait(job_or_jobs, ...) abort
                              let jobs = type(a:job_or_jobs) == type([]) ? copy(a:job_or_jobs) : [a:job_or_jobs]
                              call map(jobs, 'type(v:val) ==# type({}) ? get(v:val, "job", "") : v:val')
                              call filter(jobs, 'type(v:val) !=# type("")')
                              let timeout_ms = a:0 ? a:1 : -1
                              if exists('*jobwait')
                                call map(copy(jobs), 'chanclose(v:val, "stdin")')
                                call jobwait(jobs, timeout_ms)
                              else
                                let sleep = has('patch-8.2.2366') ? 'sleep! 1m' : 'sleep 1m'
                                for job in jobs
                                  if ch_status(job) !=# 'closed'
                                    call ch_close_in(job)
                                  endif
                                endfor
                                let i = 0
                                for job in jobs
                                  while ch_status(job) !=# 'closed' || job_status(job) ==# 'run'
                                    if i == timeout_ms
                                      break
                                    endif
                                    let i += 1
                                    exe sleep
                                  endwhile
                                endfor
                              endif
                              return a:job_or_jobs
                            endfunction
                            
    1              0.000002 function! s:JobVimExit(dict, callback, temp, job, status) abort
                              let a:dict.exit_status = a:status
                              let a:dict.stderr = readfile(a:temp . '.err', 'b')
                              call delete(a:temp . '.err')
                              let a:dict.stdout = readfile(a:temp . '.out', 'b')
                              call delete(a:temp . '.out')
                              call remove(a:dict, 'job')
                              call call(a:callback[0], [a:dict] + a:callback[1:-1])
                            endfunction
                            
    1              0.000003 function! s:JobNvimExit(dict, callback, job, data, type) dict abort
                              let a:dict.stdout = self.stdout
                              let a:dict.stderr = self.stderr
                              let a:dict.exit_status = a:data
                              call call(a:callback[0], [a:dict] + a:callback[1:-1])
                            endfunction
                            
    1              0.000001 function! s:JobExecute(argv, jopts, callback, ...) abort
                              let dict = a:0 ? a:1 : {}
                              let cb = len(a:callback) ? a:callback : [function('len')]
                              if exists('*jobstart')
                                call extend(a:jopts, {
                                      \ 'stdout_buffered': v:true,
                                      \ 'stderr_buffered': v:true,
                                      \ 'on_exit': function('s:JobNvimExit', [dict, cb])})
                                let dict.job = jobstart(a:argv, a:jopts)
                              elseif exists('*job_start')
                                let temp = tempname()
                                call extend(a:jopts, {
                                      \ 'out_io': 'file',
                                      \ 'out_name': temp . '.out',
                                      \ 'err_io': 'file',
                                      \ 'err_name': temp . '.err',
                                      \ 'exit_cb': function('s:JobVimExit', [dict, cb, temp])})
                                let dict.job = job_start(a:argv, a:jopts)
                              elseif &shell !~# 'sh' || &shell =~# 'fish\|\%(powershell\|pwsh\)\%(\.exe\)\=$'
                                throw 'fugitive: Vim 8 or higher required to use ' . &shell
                              else
                                let cmd = s:shellesc(a:argv)
                                let outfile = tempname()
                                try
                                  let dict.stderr = split(system(' (' . cmd . ' >' . outfile . ') '), "\n", 1)
                                  let dict.exit_status = v:shell_error
                                  let dict.stdout = readfile(outfile, 'b')
                                  call call(cb[0], [dict] + cb[1:-1])
                                finally
                                  call delete(outfile)
                                endtry
                              endif
                              if empty(a:callback)
                                call fugitive#Wait(dict)
                              endif
                              return dict
                            endfunction
                            
    1              0.000001 function! s:add_methods(namespace, method_names) abort
                              for name in a:method_names
                                let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
                              endfor
                            endfunction
                            
                            " Section: Git
                            
    1              0.000005 let s:run_jobs = (exists('*job_start') || exists('*jobstart')) && exists('*bufwinid')
                            
    1              0.000001 function! s:GitCmd() abort
                              if !exists('g:fugitive_git_executable')
                                return ['git']
                              elseif type(g:fugitive_git_executable) == type([])
                                return g:fugitive_git_executable
                              else
                                let dquote = '"\%([^"]\|""\|\\"\)*"\|'
                                let string = g:fugitive_git_executable
                                let list = []
                                if string =~# '^\w\+='
                                  call add(list, '/usr/bin/env')
                                endif
                                while string =~# '\S'
                                  let arg = matchstr(string, '^\s*\%(' . dquote . '''[^'']*''\|\\.\|[^[:space:] |]\)\+')
                                  let string = strpart(string, len(arg))
                                  let arg = substitute(arg, '^\s\+', '', '')
                                  let arg = substitute(arg,
                                        \ '\(' . dquote . '''\%(''''\|[^'']\)*''\|\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand,
                                        \ '\=submatch(0)[0] ==# "\\" ? submatch(0)[1] : submatch(0)[1:-2]', 'g')
                                  call add(list, arg)
                                endwhile
                                return list
                              endif
                            endfunction
                            
    1              0.000001 function! s:GitShellCmd() abort
                              if !exists('g:fugitive_git_executable')
                                return 'git'
                              elseif type(g:fugitive_git_executable) == type([])
                                return s:shellesc(g:fugitive_git_executable)
                              else
                                return g:fugitive_git_executable
                              endif
                            endfunction
                            
    1              0.000001 function! s:UserCommandCwd(dir) abort
                              let tree = s:Tree(a:dir)
                              return len(tree) ? FugitiveVimPath(tree) : getcwd()
                            endfunction
                            
    1              0.000001 function! s:UserCommandList(...) abort
                              if !fugitive#GitVersion(1, 8, 5)
                                throw 'fugitive: Git 1.8.5 or higher required'
                              endif
                              if !exists('g:fugitive_git_command')
                                let git = s:GitCmd()
                              elseif type(g:fugitive_git_command) == type([])
                                let git = g:fugitive_git_command
                              else
                                let git = split(g:fugitive_git_command, '\s\+')
                              endif
                              let flags = []
                              if a:0 && type(a:1) == type({})
                                let git = copy(get(a:1, 'git', git))
                                let flags = get(a:1, 'flags', flags)
                                let dir = a:1.git_dir
                              elseif a:0
                                let dir = s:GitDir(a:1)
                              else
                                let dir = ''
                              endif
                              if len(dir)
                                let tree = s:Tree(dir)
                                if empty(tree)
                                  call add(git, '--git-dir=' . FugitiveGitPath(dir))
                                else
                                  if !s:cpath(tree . '/.git', dir)
                                    call add(git, '--git-dir=' . FugitiveGitPath(dir))
                                  endif
                                  if !s:cpath(tree, getcwd())
                                    call extend(git, ['-C', FugitiveGitPath(tree)])
                                  endif
                                endif
                              endif
                              return git + flags
                            endfunction
                            
    1              0.000001 let s:git_versions = {}
    1              0.000001 function! fugitive#GitVersion(...) abort
                              let git = s:GitShellCmd()
                              if !has_key(s:git_versions, git)
                                let s:git_versions[git] = matchstr(get(s:JobExecute(s:GitCmd() + ['--version'], {}, [], {}).stdout, 0, ''), '\d[^[:space:]]\+')
                              endif
                              if !a:0
                                return s:git_versions[git]
                              endif
                              let components = split(s:git_versions[git], '\D\+')
                              if empty(components)
                                return -1
                              endif
                              for i in range(len(a:000))
                                if a:000[i] > +get(components, i)
                                  return 0
                                elseif a:000[i] < +get(components, i)
                                  return 1
                                endif
                              endfor
                              return a:000[i] ==# get(components, i)
                            endfunction
                            
    1              0.000001 let s:commondirs = {}
    1              0.000001 function! fugitive#CommonDir(dir) abort
                              if empty(a:dir)
                                return ''
                              endif
                              if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
                              endif
                              return s:commondirs[a:dir]
                            endfunction
                            
    1              0.000001 function! s:Dir(...) abort
                              return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()
                            endfunction
                            
    1              0.000001 function! s:GitDir(...) abort
                              return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()
                            endfunction
                            
    1              0.000001 function! s:DirUrlPrefix(...) abort
                              return 'fugitive://' . call('s:GitDir', a:000) . '//'
                            endfunction
                            
    1              0.000001 function! s:Tree(...) abort
                              return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()
                            endfunction
                            
    1              0.000001 function! s:HasOpt(args, ...) abort
                              let args = a:args[0 : index(a:args, '--')]
                              let opts = copy(a:000)
                              if type(opts[0]) == type([])
                                if empty(args) || index(opts[0], args[0]) == -1
                                  return 0
                                endif
                                call remove(opts, 0)
                              endif
                              for opt in opts
                                if index(args, opt) != -1
                                  return 1
                                endif
                              endfor
                            endfunction
                            
    1              0.000001 function! s:PreparePathArgs(cmd, dir, literal, explicit) abort
                              if !a:explicit
                                call insert(a:cmd, '--literal-pathspecs')
                              endif
                              let split = index(a:cmd, '--')
                              for i in range(split < 0 ? len(a:cmd) : split)
                                  if type(a:cmd[i]) == type(0)
                                    if a:literal
                                      let a:cmd[i] = fugitive#Path(bufname(a:cmd[i]), './', a:dir)
                                    else
                                      let a:cmd[i] = fugitive#Path(bufname(a:cmd[i]), ':(top,literal)', a:dir)
                                    endif
                                  endif
                              endfor
                              if split < 0
                                return a:cmd
                              endif
                              for i in range(split + 1, len(a:cmd) - 1)
                                if type(a:cmd[i]) == type(0)
                                  if a:literal
                                    let a:cmd[i] = fugitive#Path(bufname(a:cmd[i]), './', a:dir)
                                  else
                                    let a:cmd[i] = fugitive#Path(bufname(a:cmd[i]), ':(top,literal)', a:dir)
                                  endif
                                elseif !a:explicit
                                  let a:cmd[i] = fugitive#Path(a:cmd[i], './', a:dir)
                                endif
                              endfor
                              return a:cmd
                            endfunction
                            
    1              0.000001 function! s:PrepareEnv(env, dir) abort
                              if len($GIT_INDEX_FILE) && len(s:Tree(a:dir)) && !has_key(a:env, 'GIT_INDEX_FILE')
                                let index_dir = substitute($GIT_INDEX_FILE, '[^/]\+$', '', '')
                                let our_dir = fugitive#Find('.git/', a:dir)
                                if !s:cpath(index_dir, our_dir) && !s:cpath(resolve(FugitiveVimPath(index_dir)), our_dir)
                                  let a:env['GIT_INDEX_FILE'] = FugitiveGitPath(fugitive#Find('.git/index', a:dir))
                                endif
                              endif
                            endfunction
                            
    1              0.000004 let s:prepare_env = {
                                  \ 'sequence.editor': 'GIT_SEQUENCE_EDITOR',
                                  \ 'core.editor': 'GIT_EDITOR',
                                  \ 'core.askpass': 'GIT_ASKPASS',
                                  \ }
    1              0.000001 function! fugitive#PrepareDirEnvGitFlagsArgs(...) abort
                              if !fugitive#GitVersion(1, 8, 5)
                                throw 'fugitive: Git 1.8.5 or higher required'
                              endif
                              let git = s:GitCmd()
                              if a:0 == 1 && type(a:1) == type({}) && has_key(a:1, 'git_dir') && has_key(a:1, 'flags') && has_key(a:1, 'args')
                                let cmd = a:1.flags + a:1.args
                                let dir = a:1.git_dir
                                if has_key(a:1, 'git')
                                  let git = a:1.git
                                endif
                                let env = get(a:1, 'env', {})
                              else
                                let list_args = []
                                let cmd = []
                                for arg in a:000
                                  if type(arg) ==# type([])
                                    call extend(list_args, arg)
                                  else
                                    call add(cmd, arg)
                                  endif
                                endfor
                                call extend(cmd, list_args)
                                let env = {}
                              endif
                              let autoenv = {}
                              let explicit_pathspec_option = 0
                              let literal_pathspecs = 1
                              let i = 0
                              let arg_count = 0
                              while i < len(cmd)
                                if type(cmd[i]) == type({})
                                  if has_key(cmd[i], 'git_dir')
                                    let dir = cmd[i].git_dir
                                  elseif has_key(cmd[i], 'dir')
                                    let dir = cmd[i].dir
                                  endif
                                  if has_key(cmd[i], 'git')
                                    let git = cmd[i].git
                                  endif
                                  if has_key(cmd[i], 'env')
                                    call extend(env, cmd[i].env)
                                  endif
                                  call remove(cmd, i)
                                elseif cmd[i] =~# '^$\|[\/.]' && cmd[i] !~# '^-'
                                  let dir = remove(cmd, i)
                                elseif cmd[i] =~# '^--git-dir='
                                  let dir = remove(cmd, i)[10:-1]
                                elseif type(cmd[i]) ==# type(0)
                                  let dir = s:Dir(remove(cmd, i))
                                elseif cmd[i] ==# '-c' && len(cmd) > i + 1
                                  let key = matchstr(cmd[i+1], '^[^=]*')
                                  if has_key(s:prepare_env, tolower(key))
                                    let var = s:prepare_env[tolower(key)]
                                    let val = matchstr(cmd[i+1], '=\zs.*')
                                    let autoenv[var] = val
                                  endif
                                  let i += 2
                                elseif cmd[i] =~# '^--.*pathspecs$'
                                  let literal_pathspecs = (cmd[i] ==# '--literal-pathspecs')
                                  let explicit_pathspec_option = 1
                                  let i += 1
                                elseif cmd[i] !~# '^-'
                                  let arg_count = len(cmd) - i
                                  break
                                else
                                  let i += 1
                                endif
                              endwhile
                              if !exists('dir')
                                let dir = s:Dir()
                              endif
                              if !has_key(env, 'GIT_INDEX_FILE')
                                call s:PrepareEnv(autoenv, dir)
                              endif
                              call s:PreparePathArgs(cmd, dir, literal_pathspecs, explicit_pathspec_option)
                              return [s:GitDir(dir), env, extend(autoenv, env), git, cmd[0 : -arg_count-1], arg_count ? cmd[-arg_count : -1] : []]
                            endfunction
                            
    1              0.000001 function! s:BuildEnvPrefix(env) abort
                              let pre = ''
                              let env = items(a:env)
                              if empty(env)
                                return ''
                              elseif &shell =~# '\%(powershell\|pwsh\)\%(\.exe\)\=$'
                                return join(map(env, '"$Env:" . v:val[0] . " = ''" . substitute(v:val[1], "''", "''''", "g") . "''; "'), '')
                              elseif s:winshell()
                                return join(map(env, '"set " . substitute(join(v:val, "="), "[&|<>^]", "^^^&", "g") . "& "'), '')
                              else
                                return '/usr/bin/env ' . s:shellesc(map(env, 'join(v:val, "=")')) . ' '
                              endif
                            endfunction
                            
    1              0.000001 function! s:JobOpts(cmd, env) abort
                              if empty(a:env)
                                return [a:cmd, {}]
                              elseif has('patch-8.2.0239') ||
                                    \ has('nvim') && api_info().version.api_level - api_info().version.api_prerelease >= 7 ||
                                    \ has('patch-8.0.0902') && !has('nvim') && (!has('win32') || empty(filter(keys(a:env), 'exists("$" . v:val)')))
                                return [a:cmd, {'env': a:env}]
                              endif
                              let envlist = map(items(a:env), 'join(v:val, "=")')
                              if !has('win32')
                                return [['/usr/bin/env'] + envlist + a:cmd, {}]
                              else
                                let pre = join(map(envlist, '"set " . substitute(v:val, "[&|<>^]", "^^^&", "g") . "& "'), '')
                                if len(a:cmd) == 3 && a:cmd[0] ==# 'cmd.exe' && a:cmd[1] ==# '/c'
                                  return [a:cmd[0:1] + [pre . a:cmd[2]], {}]
                                else
                                  return [['cmd.exe', '/c', pre . s:WinShellEsc(a:cmd)], {}]
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! s:PrepareJob(opts) abort
                              let dict = {'argv': a:opts.argv}
                              if has_key(a:opts, 'env')
                                let dict.env = a:opts.env
                              endif
                              let [argv, jopts] = s:JobOpts(a:opts.argv, get(a:opts, 'env', {}))
                              if has_key(a:opts, 'cwd')
                                if has('patch-8.0.0902')
                                  let jopts.cwd = a:opts.cwd
                                  let dict.cwd = a:opts.cwd
                                else
                                  throw 'fugitive: cwd unsupported'
                                endif
                              endif
                              return [argv, jopts, dict]
                            endfunction
                            
    1              0.000001 function! fugitive#PrepareJob(...) abort
                              if a:0 == 1 && type(a:1) == type({}) && has_key(a:1, 'argv') && !has_key(a:1, 'args')
                                return s:PrepareJob(a:1)
                              endif
                              let [dir, user_env, exec_env, git, flags, args] = call('fugitive#PrepareDirEnvGitFlagsArgs', a:000)
                              let dict = {'git': git, 'git_dir': dir, 'flags': flags, 'args': args}
                              if len(user_env)
                                let dict.env = user_env
                              endif
                              let cmd = flags + args
                              let tree = s:Tree(dir)
                              if empty(tree) || index(cmd, '--') == len(cmd) - 1
                                let dict.cwd = getcwd()
                                call extend(cmd, ['--git-dir=' . FugitiveGitPath(dir)], 'keep')
                              else
                                let dict.cwd = FugitiveVimPath(tree)
                                call extend(cmd, ['-C', FugitiveGitPath(tree)], 'keep')
                                if !s:cpath(tree . '/.git', dir)
                                  call extend(cmd, ['--git-dir=' . FugitiveGitPath(dir)], 'keep')
                                endif
                              endif
                              call extend(cmd, git, 'keep')
                              return s:JobOpts(cmd, exec_env) + [dict]
                            endfunction
                            
    1              0.000001 function! fugitive#Execute(...) abort
                              let cb = copy(a:000)
                              let cmd = []
                              while len(cb) && type(cb[0]) !=# type(function('tr'))
                                call add(cmd, remove(cb, 0))
                              endwhile
                              let [argv, jopts, dict] = call('fugitive#PrepareJob', cmd)
                              return s:JobExecute(argv, jopts, cb, dict)
                            endfunction
                            
    1              0.000001 function! s:BuildShell(dir, env, git, args) abort
                              let cmd = copy(a:args)
                              let tree = s:Tree(a:dir)
                              let pre = s:BuildEnvPrefix(a:env)
                              if empty(tree) || index(cmd, '--') == len(cmd) - 1
                                call insert(cmd, '--git-dir=' . FugitiveGitPath(a:dir))
                              else
                                call extend(cmd, ['-C', FugitiveGitPath(tree)], 'keep')
                                if !s:cpath(tree . '/.git', a:dir)
                                  call extend(cmd, ['--git-dir=' . FugitiveGitPath(a:dir)], 'keep')
                                endif
                              endif
                              return pre . join(map(a:git + cmd, 's:shellesc(v:val)'))
                            endfunction
                            
    1              0.000002 function! s:JobNvimCallback(lines, job, data, type) abort
                              let a:lines[-1] .= remove(a:data, 0)
                              call extend(a:lines, a:data)
                            endfunction
                            
    1              0.000001 function! s:SystemList(cmd) abort
                              let exit = []
                              if exists('*jobstart')
                                let lines = ['']
                                let jopts = {
                                      \ 'on_stdout': function('s:JobNvimCallback', [lines]),
                                      \ 'on_stderr': function('s:JobNvimCallback', [lines]),
                                      \ 'on_exit': { j, code, _ -> add(exit, code) }}
                                let job = jobstart(a:cmd, jopts)
                                call chanclose(job, 'stdin')
                                call jobwait([job])
                                if empty(lines[-1])
                                  call remove(lines, -1)
                                endif
                                return [lines, exit[0]]
                              elseif exists('*job_start')
                                let lines = []
                                let jopts = {
                                      \ 'out_cb': { j, str -> add(lines, str) },
                                      \ 'err_cb': { j, str -> add(lines, str) },
                                      \ 'exit_cb': { j, code -> add(exit, code) }}
                                let job = job_start(a:cmd, jopts)
                                call ch_close_in(job)
                                let sleep = has('patch-8.2.2366') ? 'sleep! 1m' : 'sleep 1m'
                                while ch_status(job) !=# 'closed' || job_status(job) ==# 'run'
                                  exe sleep
                                endwhile
                                return [lines, exit[0]]
                              else
                                let [output, exec_error] = call('s:SystemError', s:shellesc(a:cmd))
                                let lines = split(output, "\n", 1)
                                if empty(lines[-1])
                                  call remove(lines, -1)
                                endif
                                return [lines, v:shell_error]
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#ShellCommand(...) abort
                              let [dir, _, env, git, flags, args] = call('fugitive#PrepareDirEnvGitFlagsArgs', a:000)
                              return s:BuildShell(dir, env, git, flags + args)
                            endfunction
                            
    1              0.000001 function! fugitive#Prepare(...) abort
                              return call('fugitive#ShellCommand', a:000)
                            endfunction
                            
    1              0.000001 function! s:SystemError(cmd, ...) abort
                              let cmd = type(a:cmd) == type([]) ? s:shellesc(a:cmd) : a:cmd
                              try
                                if &shellredir ==# '>' && &shell =~# 'sh\|cmd'
                                  let shellredir = &shellredir
                                  if &shell =~# 'csh'
                                    set shellredir=>&
                                  else
                                    set shellredir=>%s\ 2>&1
                                  endif
                                endif
                                if exists('+guioptions') && &guioptions =~# '!'
                                  let guioptions = &guioptions
                                  set guioptions-=!
                                endif
                                let out = call('system', [cmd] + a:000)
                                return [out, v:shell_error]
                              catch /^Vim\%((\a\+)\)\=:E484:/
                                let opts = ['shell', 'shellcmdflag', 'shellredir', 'shellquote', 'shellxquote', 'shellxescape', 'shellslash']
                                call filter(opts, 'exists("+".v:val) && !empty(eval("&".v:val))')
                                call map(opts, 'v:val."=".eval("&".v:val)')
                                call s:throw('failed to run `' . cmd . '` with ' . join(opts, ' '))
                              finally
                                if exists('shellredir')
                                  let &shellredir = shellredir
                                endif
                                if exists('guioptions')
                                  let &guioptions = guioptions
                                endif
                              endtry
                            endfunction
                            
    1              0.000001 function! s:ChompStderr(...) abort
                              let r = call('fugitive#Execute', a:000)
                              return !r.exit_status ? '' : len(r.stderr) > 1 ? s:JoinChomp(r.stderr) : 'unknown Git error' . string(r)
                            endfunction
                            
    1              0.000001 function! s:ChompDefault(default, ...) abort
                              let r = call('fugitive#Execute', a:000)
                              return r.exit_status ? a:default : s:JoinChomp(r.stdout)
                            endfunction
                            
    1              0.000002 function! s:LinesError(...) abort
                              let r = call('fugitive#Execute', a:000)
                              if empty(r.stdout[-1])
                                call remove(r.stdout, -1)
                              endif
                              return [r.exit_status ? [] : r.stdout, r.exit_status]
                            endfunction
                            
    1              0.000001 function! s:NullError(cmd) abort
                              let r = fugitive#Execute(a:cmd)
                              let list = r.exit_status ? [] : split(tr(join(r.stdout, "\1"), "\1\n", "\n\1"), "\1", 1)[0:-2]
                              return [list, s:JoinChomp(r.stderr), r.exit_status]
                            endfunction
                            
    1              0.000001 function! s:TreeChomp(...) abort
                              let r = call('fugitive#Execute', a:000)
                              if !r.exit_status
                                return s:JoinChomp(r.stdout)
                              endif
                              throw 'fugitive: error running `' . call('fugitive#ShellCommand', a:000) . '`: ' . s:JoinChomp(r.stderr)
                            endfunction
                            
    1              0.000001 function! s:StdoutToFile(out, cmd, ...) abort
                              let [argv, jopts, _] = fugitive#PrepareJob(a:cmd)
                              let exit = []
                              if exists('*jobstart')
                                call extend(jopts, {
                                      \ 'stdout_buffered': v:true,
                                      \ 'stderr_buffered': v:true,
                                      \ 'on_exit': { j, code, _ -> add(exit, code) }})
                                let job = jobstart(argv, jopts)
                                if a:0
                                  call chansend(job, a:1)
                                endif
                                call chanclose(job, 'stdin')
                                call jobwait([job])
                                if len(a:out)
                                  call writefile(jopts.stdout, a:out, 'b')
                                endif
                                return [join(jopts.stderr, "\n"), exit[0]]
                              elseif exists('*job_start')
                                try
                                  let err = tempname()
                                  call extend(jopts, {
                                        \ 'out_io': len(a:out) ? 'file' : 'null',
                                        \ 'out_name': a:out,
                                        \ 'err_io': 'file',
                                        \ 'err_name': err,
                                        \ 'exit_cb': { j, code -> add(exit, code) }})
                                  let job = job_start(argv, jopts)
                                  if a:0
                                    call ch_sendraw(job, a:1)
                                  endif
                                  call ch_close_in(job)
                                  while ch_status(job) !=# 'closed' || job_status(job) ==# 'run'
                                    exe has('patch-8.2.2366') ? 'sleep! 1m' : 'sleep 1m'
                                  endwhile
                                  return [join(readfile(err, 'b'), "\n"), exit[0]]
                                finally
                                  call delete(err)
                                endtry
                              elseif s:winshell() || &shell !~# 'sh' || &shell =~# 'fish\|\%(powershell\|pwsh\)\%(\.exe\)\=$'
                                throw 'fugitive: Vim 8 or higher required to use ' . &shell
                              else
                                let cmd = fugitive#ShellCommand(a:cmd)
                                return s:SystemError(' (' . cmd . ' >' . a:out . ') ')
                              endif
                            endfunction
                            
    1              0.000002 let s:head_cache = {}
                            
    1              0.000001 function! fugitive#Head(...) abort
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              if empty(dir)
                                return ''
                              endif
                              let file = fugitive#Find('.git/HEAD', dir)
                              let ftime = getftime(file)
                              if ftime == -1
                                return ''
                              elseif ftime != get(s:head_cache, file, [-1])[0]
                                let s:head_cache[file] = [ftime, readfile(file)[0]]
                              endif
                              let head = s:head_cache[file][1]
                              if head =~# '^ref: '
                                return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#RevParse(rev, ...) abort
                              let hash = s:ChompDefault('', [a:0 ? a:1 : s:Dir(), 'rev-parse', '--verify', a:rev, '--'])
                              if hash =~# '^\x\{40,\}$'
                                return hash
                              endif
                              throw 'fugitive: failed to parse revision ' . a:rev
                            endfunction
                            
                            " Section: Git config
                            
    1              0.000001 function! s:ConfigTimestamps(dir, dict) abort
                              let files = ['/etc/gitconfig', '~/.gitconfig',
                                    \ len($XDG_CONFIG_HOME) ? $XDG_CONFIG_HOME . '/git/config' : '~/.config/git/config']
                              if len(a:dir)
                                call add(files, fugitive#Find('.git/config', a:dir))
                              endif
                              call extend(files, get(a:dict, 'include.path', []))
                              return join(map(files, 'getftime(expand(v:val))'), ',')
                            endfunction
                            
    1              0.000001 function! s:ConfigCallback(r, into) abort
                              let dict = a:into[1]
                              if has_key(dict, 'job')
                                call remove(dict, 'job')
                              endif
                              let lines = a:r.exit_status ? [] : split(tr(join(a:r.stdout, "\1"), "\1\n", "\n\1"), "\1", 1)[0:-2]
                              for line in lines
                                let key = matchstr(line, "^[^\n]*")
                                if !has_key(dict, key)
                                  let dict[key] = []
                                endif
                                if len(key) ==# len(line)
                                  call add(dict[key], 1)
                                else
                                  call add(dict[key], strpart(line, len(key) + 1))
                                endif
                              endfor
                              let callbacks = remove(dict, 'callbacks')
                              lockvar! dict
                              let a:into[0] = s:ConfigTimestamps(dict.git_dir, dict)
                              for callback in callbacks
                                call call(callback[0], [dict] + callback[1:-1])
                              endfor
                            endfunction
                            
    1              0.000001 let s:config_prototype = {}
                            
    1              0.000001 let s:config = {}
    1              0.000001 function! fugitive#ExpireConfig(...) abort
                              if !a:0 || a:1 is# 0
                                let s:config = {}
                              else
                                let key = a:1 is# '' ? '_' : s:GitDir(a:0 ? a:1 : -1)
                                if len(key) && has_key(s:config, key)
                                  call remove(s:config, key)
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#Config(...) abort
                              let name = ''
                              let default = get(a:, 3, '')
                              if a:0 && type(a:1) == type(function('tr'))
                                let dir = s:Dir()
                                let callback = a:000
                              elseif a:0 > 1 && type(a:2) == type(function('tr'))
                                if type(a:1) == type({}) && has_key(a:1, 'GetAll')
                                  if has_key(a:1, 'callbacks')
                                    call add(a:1.callbacks, a:000[1:-1])
                                  else
                                    call call(a:2, [a:1] + a:000[2:-1])
                                  endif
                                  return a:1
                                else
                                  let dir = s:Dir(a:1)
                                  let callback = a:000[1:-1]
                                endif
                              elseif a:0 >= 2 && type(a:2) == type({}) && has_key(a:2, 'GetAll')
                                return get(fugitive#ConfigGetAll(a:1, a:2), 0, default)
                              elseif a:0 >= 2
                                let dir = s:Dir(a:2)
                                let name = a:1
                              elseif a:0 == 1 && type(a:1) == type({}) && has_key(a:1, 'GetAll')
                                return a:1
                              elseif a:0 == 1 && type(a:1) == type('') && a:1 =~# '^[[:alnum:]-]\+\.'
                                let dir = s:Dir()
                                let name = a:1
                              elseif a:0 == 1
                                let dir = s:Dir(a:1)
                              else
                                let dir = s:Dir()
                              endif
                              let name = substitute(name, '^[^.]\+\|[^.]\+$', '\L&', 'g')
                              let git_dir = s:GitDir(dir)
                              let dir_key = len(git_dir) ? git_dir : '_'
                              let [ts, dict] = get(s:config, dir_key, ['new', {}])
                              if !has_key(dict, 'job') && ts !=# s:ConfigTimestamps(git_dir, dict)
                                let dict = copy(s:config_prototype)
                                let dict.git_dir = git_dir
                                let into = ['running', dict]
                                let dict.callbacks = []
                                let exec = fugitive#Execute([dir, 'config', '--list', '-z', '--'], function('s:ConfigCallback'), into)
                                if has_key(exec, 'job')
                                  let dict.job = exec.job
                                endif
                                let s:config[dir_key] = into
                              endif
                              if !exists('l:callback')
                                call fugitive#Wait(dict)
                              elseif has_key(dict, 'callbacks')
                                call add(dict.callbacks, callback)
                              else
                                call call(callback[0], [dict] + callback[1:-1])
                              endif
                              return len(name) ? get(fugitive#ConfigGetAll(name, dict), 0, default) : dict
                            endfunction
                            
    1              0.000001 function! fugitive#ConfigGetAll(name, ...) abort
                              if a:0 && (type(a:name) !=# type('') || a:name !~# '^[[:alnum:]-]\+\.' && type(a:1) ==# type('') && a:1 =~# '^[[:alnum:]-]\+\.')
                                let config = fugitive#Config(a:name)
                                let name = a:1
                              else
                                let config = fugitive#Config(a:0 ? a:1 : s:Dir())
                                let name = a:name
                              endif
                              let name = substitute(name, '^[^.]\+\|[^.]\+$', '\L&', 'g')
                              call fugitive#Wait(config)
                              return name =~# '\.' ? copy(get(config, name, [])) : []
                            endfunction
                            
    1              0.000001 function! fugitive#ConfigGetRegexp(pattern, ...) abort
                              if type(a:pattern) !=# type('')
                                let config = fugitive#Config(a:name)
                                let pattern = a:0 ? a:1 : '.*'
                              else
                                let config = fugitive#Config(a:0 ? a:1 : s:Dir())
                                let pattern = a:pattern
                              endif
                              call fugitive#Wait(config)
                              let filtered = map(filter(copy(config), 'v:key =~# "\\." && v:key =~# pattern'), 'copy(v:val)')
                              if pattern !~# '\\\@<!\%(\\\\\)*\\z[se]'
                                return filtered
                              endif
                              let transformed = {}
                              for [k, v] in items(filtered)
                                let k = matchstr(k, pattern)
                                if len(k)
                                  let transformed[k] = v
                                endif
                              endfor
                              return transformed
                            endfunction
                            
    1              0.000001 function! s:config_GetAll(name) dict abort
                              let name = substitute(a:name, '^[^.]\+\|[^.]\+$', '\L&', 'g')
                              call fugitive#Wait(self)
                              return name =~# '\.' ? copy(get(self, name, [])) : []
                            endfunction
                            
    1              0.000001 function! s:config_Get(name, ...) dict abort
                              return get(self.GetAll(a:name), 0, a:0 ? a:1 : '')
                            endfunction
                            
    1              0.000001 function! s:config_GetRegexp(pattern) dict abort
                              return fugitive#ConfigGetRegexp(self, a:pattern)
                            endfunction
                            
    1   0.000095   0.000008 call s:add_methods('config', ['GetAll', 'Get', 'GetRegexp'])
                            
    1              0.000001 function! s:Remote(dir) abort
                              let head = FugitiveHead(0, a:dir)
                              let remote = len(head) ? FugitiveConfigGet('branch.' . head . '.remote', a:dir) : ''
                              let i = 10
                              while remote ==# '.' && i > 0
                                let head = matchstr(FugitiveConfigGet('branch.' . head . '.merge', a:dir), 'refs/heads/\zs.*')
                                let remote = len(head) ? FugitiveConfigGet('branch.' . head . '.remote', a:dir) : ''
                                let i -= 1
                              endwhile
                              return remote =~# '^\.\=$' ? 'origin' : remote
                            endfunction
                            
    1              0.000001 function! s:SshParseHost(value) abort
                              let patterns = []
                              let negates = []
                              for host in split(a:value, '\s\+')
                                let pattern = substitute(host, '[\\^$.*~?]', '\=submatch(0) == "*" ? ".*" : submatch(0) == "?" ? "." : "\\" . submatch(0)', 'g')
                                if pattern[0] ==# '!'
                                  call add(negates, '\&\%(^' . pattern[1 : -1] . '$\)\@!')
                                else
                                  call add(patterns, pattern)
                                endif
                              endfor
                              return '^\%(' . join(patterns, '\|') . '\)$' . join(negates, '')
                            endfunction
                            
    1              0.000001 function! s:SshParseConfig(into, root, file, ...) abort
                              if !filereadable(a:file)
                                return a:into
                              endif
                              let host = a:0 ? a:1 : '^\%(.*\)$'
                              for line in readfile(a:file)
                                let key = tolower(matchstr(line, '^\s*\zs\w\+\ze\s'))
                                let value = matchstr(line, '^\s*\w\+\s\+\zs.*\S')
                                if key ==# 'match'
                                  let host = value ==# 'all' ? '^\%(.*\)$' : ''
                                elseif key ==# 'host'
                                  let host = s:SshParseHost(value)
                                elseif key ==# 'include'
                                  call s:SshParseInclude(a:into, a:root, host, value)
                                elseif len(key) && len(host)
                                  call extend(a:into, {key: []}, 'keep')
                                  call add(a:into[key], [host, value])
                                endif
                              endfor
                              return a:into
                            endfunction
                            
    1              0.000001 function! s:SshParseInclude(into, root, host, value) abort
                              for glob in split(a:value)
                                if glob !~# '^/'
                                  let glob = a:root . glob
                                endif
                                for file in split(glob(glob), "\n")
                                  call s:SshParseConfig(a:into, a:root, file, a:host)
                                endfor
                              endfor
                            endfunction
                            
    1              0.000001 unlet! s:ssh_config
    1              0.000001 function! fugitive#SshConfig(host, ...) abort
                              if !exists('s:ssh_config')
                                let s:ssh_config = {}
                                for file in [expand("~/.ssh/config"), "/etc/ssh/ssh_config"]
                                  call s:SshParseConfig(s:ssh_config, substitute(file, '\w*$', '', ''), file)
                                endfor
                              endif
                              let host_config = {}
                              for key in a:0 ? a:1 : keys(s:ssh_config)
                                for [host_pattern, value] in get(s:ssh_config, key, [])
                                  if a:host =~# host_pattern
                                    let host_config[key] = value
                                    break
                                  endif
                                endfor
                              endfor
                              return host_config
                            endfunction
                            
    1              0.000001 function! fugitive#SshHostAlias(authority) abort
                              let [_, user, host, port; __] = matchlist(a:authority, '^\%(\([^/@]\+\)@\)\=\(.\{-\}\)\%(:\(\d\+\)\)\=$')
                              let c = fugitive#SshConfig(host, ['user', 'hostname', 'port'])
                              if empty(user)
                                let user = get(c, 'user', '')
                              endif
                              if empty(port)
                                let port = get(c, 'port', '')
                              endif
                              return (len(user) ? user . '@' : '') . get(c, 'hostname', host) . (port =~# '^\%(22\)\=$' ? '' : ':' . port)
                            endfunction
                            
    1              0.000001 function! s:CurlResponse(result) abort
                              let a:result.headers = {}
                              for line in a:result.exit_status ? [] : remove(a:result, 'stdout')
                                let header = matchlist(line, '^\([[:alnum:]-]\+\):\s\(.\{-\}\)'. "\r\\=$")
                                if len(header)
                                  let k = tolower(header[1])
                                  if has_key(a:result.headers, k)
                                    let a:result.headers[k] .= ', ' . header[2]
                                  else
                                    let a:result.headers[k] = header[2]
                                  endif
                                elseif empty(line)
                                  break
                                endif
                              endfor
                            endfunction
                            
    1              0.000002 let s:remote_headers = {}
                            
    1              0.000002 function! fugitive#RemoteHttpHeaders(remote) abort
                              if a:remote !~# '^https\=://.' || !s:executable('curl')
                                return {}
                              endif
                              if !has_key(s:remote_headers, a:remote)
                                let url = a:remote . '/info/refs?service=git-upload-pack'
                                let exec = s:JobExecute(
                                      \ ['curl', '--disable', '--silent', '--max-time', '5', '-X', 'GET', '-I',
                                      \ url], {}, [function('s:CurlResponse')], {})
                                call fugitive#Wait(exec)
                                let s:remote_headers[a:remote] = exec.headers
                              endif
                              return s:remote_headers[a:remote]
                            endfunction
                            
    1              0.000001 function! fugitive#ResolveRemote(remote) abort
                              let scp_authority = matchstr(a:remote, '^[^:/]\+\ze:\%(//\)\@!')
                              if len(scp_authority) && !(has('win32') && scp_authority =~# '^\a:[\/]')
                                let path = strpart(a:remote, len(scp_authority) + 1)
                                let authority = fugitive#SshHostAlias(scp_authority)
                                if path =~# '^/'
                                  return 'ssh://' . authority . path
                                elseif path =~# '^\~'
                                  return 'ssh://' . authority . '/' . path
                                elseif authority !~# ':'
                                  return authority . ':' . path
                                endif
                              elseif a:remote =~# '^https\=://'
                                let headers = fugitive#RemoteHttpHeaders(a:remote)
                                let loc = matchstr(get(headers, 'location', ''), '^https\=://.\{-\}\ze/info/refs?')
                                if len(loc)
                                  return loc
                                endif
                              elseif a:remote =~# '^ssh://'
                                let authority = matchstr(a:remote, '[^/?#]*', 6)
                                return 'ssh://' . fugitive#SshHostAlias(authority) . strpart(a:remote, 6 + len(authority))
                              endif
                              return a:remote
                            endfunction
                            
    1              0.000001 function! s:ConfigLengthSort(i1, i2) abort
                              return len(a:i2[0]) - len(a:i1[0])
                            endfunction
                            
    1              0.000001 function! fugitive#RemoteUrl(...) abort
                              let args = a:000
                              if a:0 && (type(a:1) !=# type('') || a:1 =~# '^/\|^\a:[\\/]' && get(a:, 2, '') !~# '^/\|^\a:[\\/]')
                                let config = fugitive#Config(a:1)
                                let args = a:000[1:-1]
                                if type(a:1) ==# type({}) && has_key(a:1, 'remote_name') && (type(get(args, 0, 0)) !=# type('') || args[0] =~# '^:')
                                  call insert(args, a:1.remote_name)
                                endif
                              elseif a:0 > 1 && a:2 !~# '^:'
                                let config = fugitive#Config(a:2)
                                let args = [a:1] + a:000[2:-1]
                              else
                                let config = fugitive#Config()
                                let args = copy(a:000)
                              endif
                              if empty(args) || args[0] =~# '^:'
                                let url = s:Remote(config)
                              elseif args[0] =~# '^\.\=$'
                                call remove(args, 0)
                                let url = s:Remote(config)
                              else
                                let url = remove(args, 0)
                              endif
                              if url ==# '.git'
                                let url = s:GitDir(config)
                              elseif url !~# ':\|^/\|^\.\.\=/'
                                let url = FugitiveConfigGet('remote.' . url . '.url', config)
                              endif
                              let instead_of = []
                              for [k, vs] in items(fugitive#ConfigGetRegexp('^url\.\zs.\{-\}\ze\.insteadof$', config))
                                for v in vs
                                  call add(instead_of, [v, k])
                                endfor
                              endfor
                              call sort(instead_of, 's:ConfigLengthSort')
                              for [orig, replacement] in instead_of
                                if strpart(url, 0, len(orig)) ==# orig
                                  let url = replacement . strpart(url, len(orig))
                                  break
                                endif
                              endfor
                              if index(args, 1) < 0 && index(args, get(v:, 'true', 1)) < 0 && index(args, ':noresolve') < 0
                                let url = fugitive#ResolveRemote(url)
                              endif
                              return url
                            endfunction
                            
                            " Section: Quickfix
                            
    1              0.000001 function! s:QuickfixGet(nr, ...) abort
                              if a:nr < 0
                                return call('getqflist', a:000)
                              else
                                return call('getloclist', [a:nr] + a:000)
                              endif
                            endfunction
                            
    1              0.000001 function! s:QuickfixSet(nr, ...) abort
                              if a:nr < 0
                                return call('setqflist', a:000)
                              else
                                return call('setloclist', [a:nr] + a:000)
                              endif
                            endfunction
                            
    1              0.000001 function! s:QuickfixCreate(nr, opts) abort
                              if has('patch-7.4.2200')
                                call s:QuickfixSet(a:nr, [], ' ', a:opts)
                              else
                                call s:QuickfixSet(a:nr, [], ' ')
                              endif
                            endfunction
                            
    1              0.000002 function! s:QuickfixStream(nr, event, title, cmd, first, mods, callback, ...) abort
                              call s:BlurStatus()
                              let mods = s:Mods(a:mods)
                              let opts = {'title': a:title, 'context': {'items': []}}
                              call s:QuickfixCreate(a:nr, opts)
                              let event = (a:nr < 0 ? 'c' : 'l') . 'fugitive-' . a:event
                              silent exe s:DoAutocmd('QuickFixCmdPre ' . event)
                              let winnr = winnr()
                              exe a:nr < 0 ? 'copen' : 'lopen'
                              if winnr != winnr()
                                wincmd p
                              endif
                            
                              let buffer = []
                              let lines = s:SystemList(a:cmd)[0]
                              for line in lines
                                call extend(buffer, call(a:callback, a:000 + [line]))
                                if len(buffer) >= 20
                                  let contexts = map(copy(buffer), 'get(v:val, "context", {})')
                                  lockvar contexts
                                  call extend(opts.context.items, contexts)
                                  unlet contexts
                                  call s:QuickfixSet(a:nr, remove(buffer, 0, -1), 'a')
                                  if mods !~# '\<silent\>'
                                    redraw
                                  endif
                                endif
                              endfor
                              call extend(buffer, call(a:callback, a:000 + [0]))
                              call extend(opts.context.items, map(copy(buffer), 'get(v:val, "context", {})'))
                              lockvar opts.context.items
                              call s:QuickfixSet(a:nr, buffer, 'a')
                            
                              silent exe s:DoAutocmd('QuickFixCmdPost ' . event)
                              if a:first && len(s:QuickfixGet(a:nr))
                                return mods . (a:nr < 0 ? 'cfirst' : 'lfirst')
                              else
                                return 'exe'
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#Cwindow() abort
                              if &buftype == 'quickfix'
                                cwindow
                              else
                                botright cwindow
                                if &buftype == 'quickfix'
                                  wincmd p
                                endif
                              endif
                            endfunction
                            
                            " Section: Repository Object
                            
    1              0.000001 let s:repo_prototype = {}
    1              0.000001 let s:repos = {}
                            
    1              0.000001 function! fugitive#repo(...) abort
                              let dir = a:0 ? s:GitDir(a:1) : (len(s:GitDir()) ? s:GitDir() : FugitiveExtractGitDir(expand('%:p')))
                              if dir !=# ''
                                if has_key(s:repos, dir)
                                  let repo = get(s:repos, dir)
                                else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
                                return extend(repo, s:repo_prototype, 'keep')
                              endif
                              call s:throw('not a Git repository')
                            endfunction
                            
    1              0.000001 function! s:repo_dir(...) dict abort
                              return join([self.git_dir]+a:000,'/')
                            endfunction
                            
    1              0.000001 function! s:repo_tree(...) dict abort
                              let dir = s:Tree(self.git_dir)
                              if dir ==# ''
                                call s:throw('no work tree')
                              else
                                return join([dir]+a:000,'/')
                              endif
                            endfunction
                            
    1              0.000001 function! s:repo_bare() dict abort
                              if self.dir() =~# '/\.git$'
                                return 0
                              else
                                return s:Tree(self.git_dir) ==# ''
                              endif
                            endfunction
                            
    1              0.000001 function! s:repo_find(object) dict abort
                              return fugitive#Find(a:object, self.git_dir)
                            endfunction
                            
    1              0.000001 function! s:repo_translate(rev) dict abort
                              return s:Slash(fugitive#Find(substitute(a:rev, '^/', ':(top)', ''), self.git_dir))
                            endfunction
                            
    1              0.000001 function! s:repo_head(...) dict abort
                              return fugitive#Head(a:0 ? a:1 : 0, self.git_dir)
                            endfunction
                            
    1   0.000137   0.000010 call s:add_methods('repo',['dir','tree','bare','find','translate','head'])
                            
    1              0.000001 function! s:repo_git_command(...) dict abort
                              throw 'fugitive: fugitive#repo().git_command(...) has been replaced by FugitiveShellCommand(...)'
                            endfunction
                            
    1              0.000001 function! s:repo_git_chomp(...) dict abort
                              return s:sub(system(fugitive#ShellCommand(a:000, self.git_dir)), '\n$', '')
                            endfunction
                            
    1              0.000001 function! s:repo_git_chomp_in_tree(...) dict abort
                              return call(self.git_chomp, a:000, self)
                            endfunction
                            
    1              0.000001 function! s:repo_rev_parse(rev) dict abort
                              return fugitive#RevParse(a:rev, self.git_dir)
                            endfunction
                            
    1   0.000080   0.000006 call s:add_methods('repo',['git_command','git_chomp','git_chomp_in_tree','rev_parse'])
                            
    1              0.000001 function! s:repo_superglob(base) dict abort
                              return map(fugitive#CompleteObject(a:base, self.git_dir), 'substitute(v:val, ''\\\(.\)'', ''\1'', "g")')
                            endfunction
                            
    1   0.000027   0.000005 call s:add_methods('repo',['superglob'])
                            
    1              0.000001 function! s:repo_config(name) dict abort
                              return FugitiveConfigGet(a:name, self.git_dir)
                            endfunction
                            
    1              0.000001 function! s:repo_user() dict abort
                              let username = self.config('user.name')
                              let useremail = self.config('user.email')
                              return username.' <'.useremail.'>'
                            endfunction
                            
    1   0.000042   0.000005 call s:add_methods('repo',['config', 'user'])
                            
                            " Section: File API
                            
    1              0.000001 function! s:DirCommitFile(path) abort
                              let vals = matchlist(s:Slash(a:path), '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if empty(vals)
                                return ['', '', '']
                              endif
                              return [s:Dir(vals[1])] + vals[2:3]
                            endfunction
                            
    1              0.000001 function! s:DirRev(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              return [dir, (commit =~# '^.$' ? ':' : '') . commit . substitute(file, '^/', ':', '')]
                            endfunction
                            
    1              0.000002 let s:merge_heads = ['MERGE_HEAD', 'REBASE_HEAD', 'CHERRY_PICK_HEAD', 'REVERT_HEAD']
    1              0.000001 function! s:MergeHead(dir) abort
                              let dir = fugitive#Find('.git/', a:dir)
                              for head in s:merge_heads
                                if filereadable(dir . head)
                                  return head
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000001 function! s:Owner(path, ...) abort
                              let dir = a:0 ? s:Dir(a:1) : s:Dir()
                              if empty(dir)
                                return ''
                              endif
                              let actualdir = fugitive#Find('.git/', dir)
                              let [pdir, commit, file] = s:DirCommitFile(a:path)
                              if s:cpath(dir, pdir)
                                if commit =~# '^\x\{40,\}$'
                                  return commit
                                elseif commit ==# '2'
                                  return '@'
                                elseif commit ==# '0'
                                  return ''
                                endif
                                let merge_head = s:MergeHead(dir)
                                if empty(merge_head)
                                  return ''
                                endif
                                if commit ==# '3'
                                  return merge_head
                                elseif commit ==# '1'
                                  return s:TreeChomp('merge-base', 'HEAD', merge_head, '--')
                                endif
                              endif
                              let path = fnamemodify(a:path, ':p')
                              if s:cpath(actualdir, strpart(path, 0, len(actualdir))) && a:path =~# 'HEAD$'
                                return strpart(path, len(actualdir))
                              endif
                              let refs = fugitive#Find('.git/refs', dir)
                              if s:cpath(refs . '/', path[0 : len(refs)]) && path !~# '[\/]$'
                                return strpart(path, len(refs) - 4)
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! fugitive#Real(url) abort
                              if empty(a:url)
                                return ''
                              endif
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if len(dir)
                                let tree = s:Tree(dir)
                                return FugitiveVimPath((len(tree) ? tree : dir) . file)
                              endif
                              let pre = substitute(matchstr(a:url, '^\a\a\+\ze:'), '^.', '\u&', '')
                              if len(pre) && pre !=? 'fugitive' && exists('*' . pre . 'Real')
                                let url = {pre}Real(a:url)
                              else
                                let url = fnamemodify(a:url, ':p' . (a:url =~# '[\/]$' ? '' : ':s?[\/]$??'))
                              endif
                              return FugitiveVimPath(empty(url) ? a:url : url)
                            endfunction
                            
    1              0.000001 function! fugitive#Path(url, ...) abort
                              if empty(a:url)
                                return ''
                              endif
                              let dir = a:0 > 1 ? s:Dir(a:2) : s:Dir()
                              let tree = s:Tree(dir)
                              if !a:0
                                return fugitive#Real(a:url)
                              elseif a:1 =~# '\.$'
                                let path = s:Slash(fugitive#Real(a:url))
                                let cwd = getcwd()
                                let lead = ''
                                while s:cpath(tree . '/', (cwd . '/')[0 : len(tree)])
                                  if s:cpath(cwd . '/', path[0 : len(cwd)])
                                    if strpart(path, len(cwd) + 1) =~# '^\.git\%(/\|$\)'
                                      break
                                    endif
                                    return a:1[0:-2] . (empty(lead) ? './' : lead) . strpart(path, len(cwd) + 1)
                                  endif
                                  let cwd = fnamemodify(cwd, ':h')
                                  let lead .= '../'
                                endwhile
                                return a:1[0:-2] . path
                              endif
                              let url = a:url
                              let temp_state = s:TempState(url)
                              if has_key(temp_state, 'origin_bufnr')
                                let url = bufname(temp_state.origin_bufnr)
                              endif
                              let url = s:Slash(fnamemodify(url, ':p'))
                              if url =~# '/$' && s:Slash(a:url) !~# '/$'
                                let url = url[0:-2]
                              endif
                              let [argdir, commit, file] = s:DirCommitFile(a:url)
                              if len(argdir) && s:cpath(argdir) !=# s:cpath(dir)
                                let file = ''
                              elseif len(dir) && s:cpath(url[0 : len(dir)]) ==# s:cpath(dir . '/')
                                let file = '/.git'.url[strlen(dir) : -1]
                              elseif len(tree) && s:cpath(url[0 : len(tree)]) ==# s:cpath(tree . '/')
                                let file = url[len(tree) : -1]
                              elseif s:cpath(url) ==# s:cpath(tree)
                                let file = '/'
                              endif
                              if empty(file) && a:1 =~# '^$\|^[.:]/$'
                                return FugitiveGitPath(fugitive#Real(a:url))
                              endif
                              return substitute(file, '^/', a:1, '')
                            endfunction
                            
    1              0.000002 function! s:Relative(...) abort
                              return fugitive#Path(@%, a:0 ? a:1 : ':(top)', a:0 > 1 ? a:2 : s:Dir())
                            endfunction
                            
    1              0.000001 function! fugitive#Find(object, ...) abort
                              if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
                              elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
                              endif
                              let rev = s:Slash(a:object)
                              if rev =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
                              elseif rev =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
                              endif
                              let dir = call('s:GitDir', a:000)
                              if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs\%(\.\.\=$\|\.\.\=/.*\|/.*\|\w:/.*\)')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return ''
                                endif
                              endif
                              let tree = s:Tree(dir)
                              let urlprefix = s:DirUrlPrefix(dir)
                              let base = len(tree) ? tree : urlprefix . '0'
                              if rev ==# '.git'
                                let f = len(tree) && len(getftype(tree . '/.git')) ? tree . '/.git' : dir
                              elseif rev =~# '^\.git/'
                                let f = strpart(rev, 5)
                                let fdir = dir . '/'
                                let cdir = fugitive#CommonDir(dir) . '/'
                                if f =~# '^\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[2:-1] : fdir . f)
                                elseif f =~# '^\.\.\%(/\|$\)'
                                  let f = base . f[2:-1]
                                elseif cdir !=# fdir && (
                                      \ f =~# '^\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' ||
                                      \ f !~# '^\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' &&
                                      \ getftime(FugitiveVimPath(fdir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
                                else
                                  let f = simplify(fdir . f)
                                endif
                              elseif rev ==# ':/'
                                let f = tree
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = urlprefix . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = urlprefix . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                let fdir = dir . '/'
                                let f = fdir . 'index'
                                if len($GIT_INDEX_FILE)
                                  let index_dir = substitute($GIT_INDEX_FILE, '[^/]\+$', '', '')
                                  if s:cpath(index_dir, fdir)
                                    let f = FugitiveVimPath($GIT_INDEX_FILE)
                                  elseif s:cpath(resolve(FugitiveVimPath(index_dir)), fdir)
                                    let f = resolve(FugitiveVimPath($GIT_INDEX_FILE))
                                  endif
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = urlprefix . '0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*')
                                  let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) ? "@" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$\|^$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                    if empty(commit) && len(file)
                                      let commit = repeat('0', 40)
                                    endif
                                  endif
                                  if len(commit)
                                    let f = urlprefix . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
                              endif
                              return FugitiveVimPath(f)
                            endfunction
                            
    1              0.000001 function! s:Generate(object, ...) abort
                              let dir = a:0 ? a:1 : s:Dir()
                              let f = fugitive#Find(a:object, dir)
                              if !empty(f)
                                return f
                              elseif a:object ==# ':/'
                                return len(dir) ? FugitiveVimPath(s:DirUrlPrefix(dir) . '0') : '.'
                              endif
                              let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*')
                              return fnamemodify(FugitiveVimPath(len(file) ? file : a:object), ':p')
                            endfunction
                            
    1              0.000001 function! s:DotRelative(path, ...) abort
                              let cwd = a:0 ? a:1 : getcwd()
                              let path = substitute(a:path, '^[~$]\i*', '\=expand(submatch(0))', '')
                              if len(cwd) && s:cpath(cwd . '/', (path . '/')[0 : len(cwd)])
                                return '.' . strpart(path, len(cwd))
                              endif
                              return a:path
                            endfunction
                            
    1              0.000001 function! fugitive#Object(...) abort
                              let dir = a:0 > 1 ? s:Dir(a:2) : s:Dir()
                              let [fdir, rev] = s:DirRev(a:0 ? a:1 : @%)
                              if s:cpath(dir) !=# s:cpath(fdir)
                                let rev = ''
                              endif
                              let tree = s:Tree(dir)
                              let full = a:0 ? a:1 : s:BufName('%')
                              let full = fnamemodify(full, ':p' . (s:Slash(full) =~# '/$' ? '' : ':s?/$??'))
                              if empty(rev) && empty(tree)
                                return FugitiveGitPath(full)
                              elseif empty(rev)
                                let rev = fugitive#Path(full, './', dir)
                                if rev =~# '^\./.git\%(/\|$\)'
                                  return FugitiveGitPath(full)
                                endif
                              endif
                              if rev !~# '^\.\%(/\|$\)' || s:cpath(getcwd(), tree)
                                return rev
                              else
                                return FugitiveGitPath(tree . rev[1:-1])
                              endif
                            endfunction
                            
    1              0.000006 let s:var = '\%(<\%(cword\|cWORD\|cexpr\|cfile\|sfile\|slnum\|afile\|abuf\|amatch' . (has('clientserver') ? '\|client' : '') . '\)>\|%\|#<\=\d\+\|##\=\)'
    1              0.000001 let s:flag = '\%(:[p8~.htre]\|:g\=s\(.\).\{-\}\1.\{-\}\1\)'
    1              0.000003 let s:expand = '\%(\(' . s:var . '\)\(' . s:flag . '*\)\(:S\)\=\)'
                            
    1              0.000001 function! s:BufName(var) abort
                              if a:var ==# '%'
                                return bufname(get(s:TempState(), 'origin_bufnr', ''))
                              elseif a:var =~# '^#\d*$'
                                let nr = get(s:TempState(bufname(+a:var[1:-1])), 'origin_bufnr', '')
                                return bufname(nr ? nr : +a:var[1:-1])
                              else
                                return expand(a:var)
                              endif
                            endfunction
                            
    1              0.000001 function! s:ExpandVarLegacy(str) abort
                              if get(g:, 'fugitive_legacy_quoting', 0)
                                return substitute(a:str, '\\\ze[%#!]', '', 'g')
                              else
                                return a:str
                              endif
                            endfunction
                            
    1              0.000002 function! s:ExpandVar(other, var, flags, esc, ...) abort
                              let cwd = a:0 ? a:1 : getcwd()
                              if a:other =~# '^\'
                                return a:other[1:-1]
                              elseif a:other =~# '^'''
                                return s:ExpandVarLegacy(substitute(a:other[1:-2], "''", "'", "g"))
                              elseif a:other =~# '^"'
                                return s:ExpandVarLegacy(substitute(a:other[1:-2], '""', '"', "g"))
                              elseif a:other =~# '^!'
                                let buffer = s:BufName(len(a:other) > 1 ? '#'. a:other[1:-1] : '%')
                                let owner = s:Owner(buffer)
                                return len(owner) ? owner : '@'
                              elseif len(a:other)
                                return expand(a:other)
                              elseif a:var ==# '<cfile>'
                                let bufnames = [expand('<cfile>')]
                                if v:version >= 704 && get(maparg('<Plug><cfile>', 'c', 0, 1), 'expr')
                                  try
                                    let bufnames = [eval(maparg('<Plug><cfile>', 'c'))]
                                    if bufnames[0] ==# "\<C-R>\<C-F>"
                                      let bufnames = [expand('<cfile>')]
                                    endif
                                  catch
                                  endtry
                                endif
                              elseif a:var =~# '^<'
                                let bufnames = [s:BufName(a:var)]
                              elseif a:var ==# '##'
                                let bufnames = map(argv(), 'fugitive#Real(v:val)')
                              else
                                let bufnames = [fugitive#Real(s:BufName(a:var))]
                              endif
                              let files = []
                              for bufname in bufnames
                                let flags = a:flags
                                let file = s:DotRelative(bufname, cwd)
                                while len(flags)
                                  let flag = matchstr(flags, s:flag)
                                  let flags = strpart(flags, len(flag))
                                  if flag ==# ':.'
                                    let file = s:DotRelative(fugitive#Real(file), cwd)
                                  else
                                    let file = fnamemodify(file, flag)
                                  endif
                                endwhile
                                let file = s:Slash(file)
                                if file =~# '^fugitive://'
                                  let [dir, commit, file_candidate] = s:DirCommitFile(file)
                                  let tree = s:Tree(dir)
                                  if len(tree) && len(file_candidate)
                                    let file = (commit =~# '^.$' ? ':' : '') . commit . ':' .
                                          \ s:DotRelative(tree . file_candidate)
                                  elseif empty(file_candidate) && commit !~# '^.$'
                                    let file = commit
                                  endif
                                endif
                                call add(files, len(a:esc) ? shellescape(file) : file)
                              endfor
                              return join(files, "\1")
                            endfunction
                            
    1              0.000001 function! s:Expand(rev, ...) abort
                              if a:rev =~# '^>\=:[0-3]$'
                                let file = len(expand('%')) ? a:rev[-2:-1] . ':%' : '%'
                              elseif a:rev ==# '>'
                                let file = '%'
                              elseif a:rev ==# '>:'
                                let file = empty(s:DirCommitFile(@%)[0]) ? ':0:%' : '%'
                              elseif a:rev =~# '^>[> ]\@!'
                                let rev = (a:rev =~# '^>[~^]' ? '!' : '') . a:rev[1:-1]
                                let prefix = matchstr(rev, '^\%(\\.\|{[^{}]*}\|[^:]\)*')
                                if prefix !=# rev
                                  let file = rev
                                else
                                  let file = len(expand('%')) ? rev . ':%' : '%'
                                endif
                              else
                                let file = a:rev
                              endif
                              return substitute(file,
                                    \ '\(\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand,
                                    \ '\=tr(s:ExpandVar(submatch(1),submatch(2),submatch(3),"", a:0 ? a:1 : getcwd()), "\1", " ")', 'g')
                            endfunction
                            
    1              0.000001 function! fugitive#Expand(object) abort
                              return substitute(a:object,
                                    \ '\(\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand,
                                    \ '\=tr(s:ExpandVar(submatch(1),submatch(2),submatch(3),submatch(5)), "\1", " ")', 'g')
                            endfunction
                            
    1              0.000001 function! s:SplitExpandChain(string, ...) abort
                              let list = []
                              let string = a:string
                              let dquote = '"\%([^"]\|""\|\\"\)*"\|'
                              let cwd = a:0 ? a:1 : getcwd()
                              while string =~# '\S'
                                if string =~# '^\s*|'
                                  return [list, substitute(string, '^\s*', '', '')]
                                endif
                                let arg = matchstr(string, '^\s*\%(' . dquote . '''[^'']*''\|\\.\|[^[:space:] |]\)\+')
                                let string = strpart(string, len(arg))
                                let arg = substitute(arg, '^\s\+', '', '')
                                if !exists('seen_separator')
                                  let arg = substitute(arg, '^\%([^:.][^:]*:\|^:\|^:[0-3]:\)\=\zs\.\.\=\%(/.*\)\=$',
                                        \ '\=s:DotRelative(s:Slash(simplify(getcwd() . "/" . submatch(0))), cwd)', '')
                                endif
                                let arg = substitute(arg,
                                      \ '\(' . dquote . '''\%(''''\|[^'']\)*''\|\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\|^\~\w*\|\$\w\+\)\|' . s:expand,
                                      \ '\=s:ExpandVar(submatch(1),submatch(2),submatch(3),submatch(5), cwd)', 'g')
                                call extend(list, split(arg, "\1", 1))
                                if arg ==# '--'
                                  let seen_separator = 1
                                endif
                              endwhile
                              return [list, '']
                            endfunction
                            
    1              0.000001 let s:trees = {}
    1              0.000001 let s:indexes = {}
    1              0.000001 function! s:TreeInfo(dir, commit) abort
                              if a:commit =~# '^:\=[0-3]$'
                                let index = get(s:indexes, a:dir, [])
                                let newftime = getftime(fugitive#Find('.git/index', a:dir))
                                if get(index, 0, -1) < newftime
                                  let [lines, exec_error] = s:LinesError([a:dir, 'ls-files', '--stage', '--'])
                                  let s:indexes[a:dir] = [newftime, {'0': {}, '1': {}, '2': {}, '3': {}}]
                                  if exec_error
                                    return [{}, -1]
                                  endif
                                  for line in lines
                                    let [info, filename] = split(line, "\t")
                                    let [mode, sha, stage] = split(info, '\s\+')
                                    let s:indexes[a:dir][1][stage][filename] = [newftime, mode, 'blob', sha, -2]
                                    while filename =~# '/'
                                      let filename = substitute(filename, '/[^/]*$', '', '')
                                      let s:indexes[a:dir][1][stage][filename] = [newftime, '040000', 'tree', '', 0]
                                    endwhile
                                  endfor
                                endif
                                return [get(s:indexes[a:dir][1], a:commit[-1:-1], {}), newftime]
                              elseif a:commit =~# '^\x\{40,\}$'
                                if !has_key(s:trees, a:dir)
                                  let s:trees[a:dir] = {}
                                endif
                                if !has_key(s:trees[a:dir], a:commit)
                                  let ftime = s:ChompDefault('', [a:dir, 'log', '-1', '--pretty=format:%ct', a:commit, '--'])
                                  if empty(ftime)
                                    let s:trees[a:dir][a:commit] = [{}, -1]
                                    return s:trees[a:dir][a:commit]
                                  endif
                                  let s:trees[a:dir][a:commit] = [{}, +ftime]
                                  let [lines, exec_error] = s:LinesError([a:dir, 'ls-tree', '-rtl', '--full-name', a:commit, '--'])
                                  if exec_error
                                    return s:trees[a:dir][a:commit]
                                  endif
                                  for line in lines
                                    let [info, filename] = split(line, "\t")
                                    let [mode, type, sha, size] = split(info, '\s\+')
                                    let s:trees[a:dir][a:commit][0][filename] = [+ftime, mode, type, sha, +size, filename]
                                  endfor
                                endif
                                return s:trees[a:dir][a:commit]
                              endif
                              return [{}, -1]
                            endfunction
                            
    1              0.000001 function! s:PathInfo(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(dir) || !get(g:, 'fugitive_file_api', 1)
                                return [-1, '000000', '', '', -1]
                              endif
                              let path = substitute(file[1:-1], '/*$', '', '')
                              let [tree, ftime] = s:TreeInfo(dir, commit)
                              let entry = empty(path) ? [ftime, '040000', 'tree', '', -1] : get(tree, path, [])
                              if empty(entry) || file =~# '/$' && entry[2] !=# 'tree'
                                return [-1, '000000', '', '', -1]
                              else
                                return entry
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#simplify(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(dir)
                                return ''
                              endif
                              if file =~# '/\.\.\%(/\|$\)'
                                let tree = s:Tree(dir)
                                if len(tree)
                                  let path = simplify(tree . file)
                                  if strpart(path . '/', 0, len(tree) + 1) !=# tree . '/'
                                    return FugitiveVimPath(path)
                                  endif
                                endif
                              endif
                              return FugitiveVimPath('fugitive://' . simplify(dir) . '//' . commit . simplify(file))
                            endfunction
                            
    1              0.000001 function! fugitive#resolve(url) abort
                              let url = fugitive#simplify(a:url)
                              if url =~? '^fugitive:'
                                return url
                              else
                                return resolve(url)
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#getftime(url) abort
                              return s:PathInfo(a:url)[0]
                            endfunction
                            
    1              0.000001 function! fugitive#getfsize(url) abort
                              let entry = s:PathInfo(a:url)
                              if entry[4] == -2 && entry[2] ==# 'blob' && len(entry[3])
                                let dir = s:DirCommitFile(a:url)[0]
                                let entry[4] = +s:ChompDefault(-1, [dir, 'cat-file', '-s', entry[3]])
                              endif
                              return entry[4]
                            endfunction
                            
    1              0.000001 function! fugitive#getftype(url) abort
                              return get({'tree': 'dir', 'blob': 'file'}, s:PathInfo(a:url)[2], '')
                            endfunction
                            
    1              0.000001 function! fugitive#filereadable(url) abort
                              return s:PathInfo(a:url)[2] ==# 'blob'
                            endfunction
                            
    1              0.000001 function! fugitive#filewritable(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if commit !~# '^\d$' || !filewritable(fugitive#Find('.git/index', dir))
                                return 0
                              endif
                              return s:PathInfo(a:url)[2] ==# 'blob' ? 1 : 2
                            endfunction
                            
    1              0.000001 function! fugitive#isdirectory(url) abort
                              return s:PathInfo(a:url)[2] ==# 'tree'
                            endfunction
                            
    1              0.000001 function! fugitive#getfperm(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              let perm = getfperm(dir)
                              let fperm = s:PathInfo(a:url)[1]
                              if fperm ==# '040000'
                                let fperm = '000755'
                              endif
                              if fperm !~# '[15]'
                                let perm = tr(perm, 'x', '-')
                              endif
                              if fperm !~# '[45]$'
                                let perm = tr(perm, 'rw', '--')
                              endif
                              if commit !~# '^\d$'
                                let perm = tr(perm, 'w', '-')
                              endif
                              return perm ==# '---------' ? '' : perm
                            endfunction
                            
    1              0.000001 function! s:UpdateIndex(dir, info) abort
                              let info = join(a:info[0:-2]) . "\t" . a:info[-1] . "\n"
                              let [error, exec_error] = s:StdoutToFile('', [a:dir, 'update-index', '--index-info'], info)
                              return !exec_error ? '' : len(error) ? error : 'unknown update-index error'
                            endfunction
                            
    1              0.000001 function! fugitive#setfperm(url, perm) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              let entry = s:PathInfo(a:url)
                              let perm = fugitive#getfperm(a:url)
                              if commit !~# '^\d$' || entry[2] !=# 'blob' ||
                                  \ substitute(perm, 'x', '-', 'g') !=# substitute(a:perm, 'x', '-', 'g')
                                return -2
                              endif
                              let error = s:UpdateIndex(dir, [a:perm =~# 'x' ? '000755' : '000644', entry[3], commit, file[1:-1]])
                              return len(error) ? -1 : 0
                            endfunction
                            
    1              0.000002 if !exists('s:blobdirs')
    1              0.000001   let s:blobdirs = {}
    1              0.000001 endif
    1              0.000001 function! s:BlobTemp(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(file)
                                return ''
                              endif
                              if !has_key(s:blobdirs, dir)
                                let s:blobdirs[dir] = tempname()
                              endif
                              let tempfile = s:blobdirs[dir] . '/' . commit . file
                              let tempparent = fnamemodify(tempfile, ':h')
                              if !isdirectory(tempparent)
                                call mkdir(tempparent, 'p')
                              elseif isdirectory(tempfile)
                                if commit =~# '^\d$' && has('patch-7.4.1107')
                                  call delete(tempfile, 'rf')
                                else
                                  return ''
                                endif
                              endif
                              if commit =~# '^\d$' || !filereadable(tempfile)
                                let rev = s:DirRev(a:url)[1]
                                let exec_error = s:StdoutToFile(tempfile, [dir, 'cat-file', 'blob', rev])[1]
                                if exec_error
                                  call delete(tempfile)
                                  return ''
                                endif
                              endif
                              return s:Resolve(tempfile)
                            endfunction
                            
    1              0.000001 function! fugitive#readfile(url, ...) abort
                              let entry = s:PathInfo(a:url)
                              if entry[2] !=# 'blob'
                                return []
                              endif
                              let temp = s:BlobTemp(a:url)
                              if empty(temp)
                                return []
                              endif
                              return call('readfile', [temp] + a:000)
                            endfunction
                            
    1              0.000003 function! fugitive#writefile(lines, url, ...) abort
                              let url = type(a:url) ==# type('') ? a:url : ''
                              let [dir, commit, file] = s:DirCommitFile(url)
                              let entry = s:PathInfo(url)
                              if commit =~# '^\d$' && entry[2] !=# 'tree'
                                let temp = tempname()
                                if a:0 && a:1 =~# 'a' && entry[2] ==# 'blob'
                                  call writefile(fugitive#readfile(url, 'b'), temp, 'b')
                                endif
                                call call('writefile', [a:lines, temp] + a:000)
                                let hash = s:ChompDefault('', [dir, '--literal-pathspecs', 'hash-object', '-w', FugitiveGitPath(temp)])
                                let mode = entry[1] !=# '000000' ? entry[1] : '100644'
                                if hash =~# '^\x\{40,\}$'
                                  let error = s:UpdateIndex(dir, [mode, hash, commit, file[1:-1]])
                                  if empty(error)
                                    return 0
                                  endif
                                endif
                              endif
                              return call('writefile', [a:lines, a:url] + a:000)
                            endfunction
                            
    1              0.000006 let s:globsubs = {
                                  \ '/**/': '/\%([^./][^/]*/\)*',
                                  \ '/**': '/\%([^./][^/]\+/\)*[^./][^/]*',
                                  \ '**/': '[^/]*\%(/[^./][^/]*\)*',
                                  \ '**': '.*',
                                  \ '/*': '/[^/.][^/]*',
                                  \ '*': '[^/]*',
                                  \ '?': '[^/]'}
    1              0.000001 function! fugitive#glob(url, ...) abort
                              let [dirglob, commit, glob] = s:DirCommitFile(a:url)
                              let append = matchstr(glob, '/*$')
                              let glob = substitute(glob, '/*$', '', '')
                              let pattern = '^' . substitute(glob, '/\=\*\*/\=\|/\=\*\|[.?\$]\|^^', '\=get(s:globsubs, submatch(0), "\\" . submatch(0))', 'g')[1:-1] . '$'
                              let results = []
                              for dir in dirglob =~# '[*?]' ? split(glob(dirglob), "\n") : [dirglob]
                                if empty(dir) || !get(g:, 'fugitive_file_api', 1) || !filereadable(fugitive#Find('.git/HEAD', dir))
                                  continue
                                endif
                                let files = items(s:TreeInfo(dir, commit)[0])
                                if len(append)
                                  call filter(files, 'v:val[1][2] ==# "tree"')
                                endif
                                call map(files, 'v:val[0]')
                                call filter(files, 'v:val =~# pattern')
                                let prepend = s:DirUrlPrefix(dir) . substitute(commit, '^:', '', '') . '/'
                                call sort(files)
                                call map(files, 'FugitiveVimPath(prepend . v:val . append)')
                                call extend(results, files)
                              endfor
                              if a:0 > 1 && a:2
                                return results
                              else
                                return join(results, "\n")
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#delete(url, ...) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if a:0 && len(a:1) || commit !~# '^\d$'
                                return -1
                              endif
                              let entry = s:PathInfo(a:url)
                              if entry[2] !=# 'blob'
                                return -1
                              endif
                              let error = s:UpdateIndex(dir, ['000000', '0000000000000000000000000000000000000000', commit, file[1:-1]])
                              return len(error) ? -1 : 0
                            endfunction
                            
                            " Section: Buffer Object
                            
    1              0.000001 let s:buffer_prototype = {}
                            
    1              0.000001 function! fugitive#buffer(...) abort
                              let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
                              call extend(buffer, s:buffer_prototype, 'keep')
                              return buffer
                            endfunction
                            
    1              0.000001 function! s:buffer_repo() dict abort
                              return fugitive#repo(self['#'])
                            endfunction
                            
    1              0.000001 function! s:buffer_type(...) dict abort
                              return 'see per type events at :help fugitive-autocommands'
                            endfunction
                            
    1   0.000073   0.000012 call s:add_methods('buffer', ['repo', 'type'])
                            
                            " Section: Completion
                            
    1              0.000001 function! s:FilterEscape(items, ...) abort
                              let items = copy(a:items)
                              call map(items, 's:fnameescape(v:val)')
                              if a:0 && type(a:1) == type('')
                                let cmp = s:FileIgnoreCase(1) ? '==?' : '==#'
                                call filter(items, 'strpart(v:val, 0, strlen(a:1)) ' . cmp . ' a:1')
                              endif
                              return items
                            endfunction
                            
    1              0.000001 function! s:GlobComplete(lead, pattern, ...) abort
                              if a:lead ==# '/'
                                return []
                              elseif v:version >= 704
                                let results = glob(a:lead . a:pattern, a:0 ? a:1 : 0, 1)
                              else
                                let results = split(glob(a:lead . a:pattern), "\n")
                              endif
                              call map(results, 'v:val !~# "/$" && isdirectory(v:val) ? v:val."/" : v:val')
                              call map(results, 'v:val[ strlen(a:lead) : -1 ]')
                              return results
                            endfunction
                            
    1              0.000001 function! fugitive#CompletePath(base, ...) abort
                              let dir = a:0 == 1 ? a:1 : a:0 >= 3 ? a:3 : s:Dir()
                              let stripped = matchstr(a:base, '^\%(:/:\=\|:(top)\|:(top,literal)\|:(literal,top)\)')
                              let base = strpart(a:base, len(stripped))
                              if len(stripped) || a:0 < 4
                                let root = s:Tree(dir)
                              else
                                let root = a:4
                              endif
                              if root !=# '/' && len(root)
                                let root .= '/'
                              endif
                              if empty(stripped)
                                let stripped = matchstr(a:base, '^\%(:(literal)\|:\)')
                                let base = strpart(a:base, len(stripped))
                              endif
                              if base =~# '^\.git/' && len(dir)
                                let pattern = s:gsub(base[5:-1], '/', '*&').'*'
                                let fdir = fugitive#Find('.git/', dir)
                                let matches = s:GlobComplete(fdir, pattern)
                                let cdir = fugitive#Find('.git/refs', dir)[0 : -5]
                                if len(cdir) && s:cpath(fdir) !=# s:cpath(cdir)
                                  call extend(matches, s:GlobComplete(cdir, pattern))
                                endif
                                call s:Uniq(matches)
                                call map(matches, "'.git/' . v:val")
                              elseif base =~# '^\~/'
                                let matches = map(s:GlobComplete(expand('~/'), base[2:-1] . '*'), '"~/" . v:val')
                              elseif a:base =~# '^/\|^\a\+:\|^\.\.\=/'
                                let matches = s:GlobComplete('', base . '*')
                              elseif len(root)
                                let matches = s:GlobComplete(root, s:gsub(base, '/', '*&').'*')
                              else
                                let matches = []
                              endif
                              call map(matches, 's:fnameescape(s:Slash(stripped . v:val))')
                              return matches
                            endfunction
                            
    1              0.000001 function! fugitive#PathComplete(...) abort
                              return call('fugitive#CompletePath', a:000)
                            endfunction
                            
    1              0.000001 function! s:CompleteHeads(dir) abort
                              if empty(a:dir)
                                return []
                              endif
                              let dir = fugitive#Find('.git/', a:dir)
                              return sort(filter(['HEAD', 'FETCH_HEAD', 'ORIG_HEAD'] + s:merge_heads, 'filereadable(dir . v:val)')) +
                                    \ sort(s:LinesError([a:dir, 'rev-parse', '--symbolic', '--branches', '--tags', '--remotes'])[0])
                            endfunction
                            
    1              0.000001 function! fugitive#CompleteObject(base, ...) abort
                              let dir = a:0 == 1 ? a:1 : a:0 >= 3 ? a:3 : s:Dir()
                              let tree = s:Tree(dir)
                              let cwd = getcwd()
                              let subdir = ''
                              if len(tree) && s:cpath(tree . '/', cwd[0 : len(tree)])
                                let subdir = strpart(cwd, len(tree) + 1) . '/'
                              endif
                            
                              if a:base =~# '^\.\=/\|^:(' || a:base !~# ':'
                                let results = []
                                if a:base =~# '^refs/'
                                  let cdir = fugitive#Find('.git/refs', dir)[0 : -5]
                                  let results += map(s:GlobComplete(cdir, a:base . '*'), 's:Slash(v:val)')
                                  call map(results, 's:fnameescape(v:val)')
                                elseif a:base !~# '^\.\=/\|^:('
                                  let heads = s:CompleteHeads(dir)
                                  if filereadable(fugitive#Find('.git/refs/stash', dir))
                                    let heads += ["stash"]
                                    let heads += sort(s:LinesError(["stash","list","--pretty=format:%gd"], dir)[0])
                                  endif
                                  let results += s:FilterEscape(heads, a:base)
                                endif
                                let results += a:0 == 1 || a:0 >= 3 ? fugitive#CompletePath(a:base, 0, '', dir, a:0 >= 4 ? a:4 : tree) : fugitive#CompletePath(a:base)
                                return results
                            
                              elseif a:base =~# '^:'
                                let entries = s:LinesError(['ls-files','--stage'], dir)[0]
                                if a:base =~# ':\./'
                                  call map(entries, 'substitute(v:val, "\\M\t\\zs" . subdir, "./", "")')
                                endif
                                call map(entries,'s:sub(v:val,".*(\\d)\\t(.*)",":\\1:\\2")')
                                if a:base !~# '^:[0-3]\%(:\|$\)'
                                  call filter(entries,'v:val[1] == "0"')
                                  call map(entries,'v:val[2:-1]')
                                endif
                            
                              else
                                let parent = matchstr(a:base, '.*[:/]')
                                let entries = s:LinesError(['ls-tree', substitute(parent,  ':\zs\./', '\=subdir', '')], dir)[0]
                                call map(entries,'s:sub(v:val,"^04.*\\zs$","/")')
                                call map(entries,'parent.s:sub(v:val,".*\t","")')
                              endif
                              return s:FilterEscape(entries, a:base)
                            endfunction
                            
    1              0.000002 function! s:CompleteSub(subcommand, A, L, P, ...) abort
                              let pre = strpart(a:L, 0, a:P)
                              if pre =~# ' -- '
                                return fugitive#CompletePath(a:A)
                              elseif a:A =~# '^-' || a:A is# 0
                                return s:FilterEscape(split(s:ChompDefault('', [a:subcommand, '--git-completion-helper']), ' '), a:A)
                              elseif !a:0
                                return fugitive#CompleteObject(a:A, s:Dir())
                              elseif type(a:1) == type(function('tr'))
                                return call(a:1, [a:A, a:L, a:P] + (a:0 > 1 ? a:2 : []))
                              else
                                return s:FilterEscape(a:1, a:A)
                              endif
                            endfunction
                            
    1              0.000001 function! s:CompleteRevision(A, L, P, ...) abort
                              return s:FilterEscape(s:CompleteHeads(a:0 ? a:1 : s:Dir()), a:A)
                            endfunction
                            
    1              0.000001 function! s:CompleteRemote(A, L, P, ...) abort
                              let dir = a:0 ? a:1 : s:Dir()
                              let remote = matchstr(a:L, '\u\w*[! ] *.\{-\}\s\@<=\zs[^-[:space:]]\S*\ze ')
                              if !empty(remote)
                                let matches = s:LinesError([dir, 'ls-remote', remote])[0]
                                call filter(matches, 'v:val =~# "\t" && v:val !~# "{"')
                                call map(matches, 's:sub(v:val, "^.*\t%(refs/%(heads/|tags/)=)=", "")')
                              else
                                let matches = s:LinesError([dir, 'remote'])[0]
                              endif
                              return s:FilterEscape(matches, a:A)
                            endfunction
                            
                            " Section: Buffer auto-commands
                            
    1              0.000002 augroup fugitive_dummy_events
    1              0.000266   autocmd!
    1              0.000006   autocmd User Fugitive* "
    1              0.000001 augroup END
                            
    1              0.000001 function! s:ReplaceCmd(cmd) abort
                              let temp = tempname()
                              let [err, exec_error] = s:StdoutToFile(temp, a:cmd)
                              if exec_error
                                throw 'fugitive: ' . (len(err) ? substitute(err, "\n$", '', '') : 'unknown error running ' . string(a:cmd))
                              endif
                              setlocal noswapfile
                              silent exe 'lockmarks keepalt 0read ++edit' s:fnameescape(temp)
                              if &foldenable && foldlevel('$') > 0
                                set nofoldenable
                                silent keepjumps $delete _
                                set foldenable
                              else
                                silent keepjumps $delete _
                              endif
                              call delete(temp)
                              if s:cpath(fnamemodify(bufname('$'), ':p'), temp)
                                silent! execute bufnr('$') . 'bwipeout'
                              endif
                            endfunction
                            
    1              0.000001 function! s:QueryLog(refspec) abort
                              let lines = s:LinesError(['log', '-n', '256', '--pretty=format:%h%x09%s', a:refspec, '--'])[0]
                              call map(lines, 'split(v:val, "\t", 1)')
                              call map(lines, '{"type": "Log", "commit": v:val[0], "subject": join(v:val[1 : -1], "\t")}')
                              return lines
                            endfunction
                            
    1              0.000001 function! s:FormatLog(dict) abort
                              return a:dict.commit . ' ' . a:dict.subject
                            endfunction
                            
    1              0.000001 function! s:FormatRebase(dict) abort
                              return a:dict.status . ' ' . a:dict.commit . ' ' . a:dict.subject
                            endfunction
                            
    1              0.000001 function! s:FormatFile(dict) abort
                              return a:dict.status . ' ' . a:dict.filename
                            endfunction
                            
    1              0.000001 function! s:Format(val) abort
                              if type(a:val) == type({})
                                return s:Format{a:val.type}(a:val)
                              elseif type(a:val) == type([])
                                return map(copy(a:val), 's:Format(v:val)')
                              else
                                return '' . a:val
                              endif
                            endfunction
                            
    1              0.000001 function! s:AddHeader(key, value) abort
                              if empty(a:value)
                                return
                              endif
                              let before = 1
                              while !empty(getline(before))
                                let before += 1
                              endwhile
                              call append(before - 1, [a:key . ':' . (len(a:value) ? ' ' . a:value : '')])
                              if before == 1 && line('$') == 2
                                silent keepjumps 2delete _
                              endif
                            endfunction
                            
    1              0.000001 function! s:AddSection(label, lines, ...) abort
                              let note = a:0 ? a:1 : ''
                              if empty(a:lines) && empty(note)
                                return
                              endif
                              call append(line('$'), ['', a:label . (len(note) ? ': ' . note : ' (' . len(a:lines) . ')')] + s:Format(a:lines))
                            endfunction
                            
    1              0.000006 let s:rebase_abbrevs = {
                                  \ 'p': 'pick',
                                  \ 'r': 'reword',
                                  \ 'e': 'edit',
                                  \ 's': 'squash',
                                  \ 'f': 'fixup',
                                  \ 'x': 'exec',
                                  \ 'd': 'drop',
                                  \ 'l': 'label',
                                  \ 't': 'reset',
                                  \ 'm': 'merge',
                                  \ 'b': 'break',
                                  \ }
                            
    1              0.000001 function! fugitive#BufReadStatus() abort
                              let amatch = s:Slash(expand('%:p'))
                              let b:fugitive_type = 'index'
                              unlet! b:fugitive_reltime
                              try
                                silent doautocmd BufReadPre
                                let config = fugitive#Config()
                            
                                let cmd = [fnamemodify(amatch, ':h')]
                                setlocal noro ma nomodeline buftype=nowrite
                                if s:cpath(fnamemodify($GIT_INDEX_FILE !=# '' ? FugitiveVimPath($GIT_INDEX_FILE) : fugitive#Find('.git/index'), ':p')) !=# s:cpath(amatch)
                                  let cmd += [{'env': {'GIT_INDEX_FILE': FugitiveGitPath(amatch)}}]
                                endif
                            
                                if fugitive#GitVersion(2, 15)
                                  call add(cmd, '--no-optional-locks')
                                endif
                            
                                let b:fugitive_files = {'Staged': {}, 'Unstaged': {}}
                                let [staged, unstaged, untracked] = [[], [], []]
                                let props = {}
                            
                                let pull = ''
                                if empty(s:Tree())
                                  let branch = FugitiveHead(0)
                                  let head = FugitiveHead(11)
                                elseif fugitive#GitVersion(2, 11)
                                  let cmd += ['status', '--porcelain=v2', '-bz']
                                  let [output, message, exec_error] = s:NullError(cmd)
                                  if exec_error
                                    throw 'fugitive: ' . message
                                  endif
                            
                                  let i = 0
                                  while i < len(output)
                                    let line = output[i]
                                    let prop = matchlist(line, '# \(\S\+\) \(.*\)')
                                    if len(prop)
                                      let props[prop[1]] = prop[2]
                                    elseif line[0] ==# '?'
                                      call add(untracked, {'type': 'File', 'status': line[0], 'filename': line[2:-1], 'relative': [line[2:-1]]})
                                    elseif line[0] !=# '#'
                                      if line[0] ==# 'u'
                                        let file = matchstr(line, '^.\{37\} \x\{40,\} \x\{40,\} \x\{40,\} \zs.*$')
                                      else
                                        let file = matchstr(line, '^.\{30\} \x\{40,\} \x\{40,\} \zs.*$')
                                      endif
                                      if line[0] ==# '2'
                                        let i += 1
                                        let file = matchstr(file, ' \zs.*')
                                        let relative = [file, output[i]]
                                      else
                                        let relative = [file]
                                      endif
                                      let filename = join(reverse(copy(relative)), ' -> ')
                                      let sub = matchstr(line, '^[12u] .. \zs....')
                                      if line[2] !=# '.'
                                        call add(staged, {'type': 'File', 'status': line[2], 'filename': filename, 'relative': relative, 'submodule': sub})
                                      endif
                                      if line[3] !=# '.'
                                        let sub = matchstr(line, '^[12u] .. \zs....')
                                        call add(unstaged, {'type': 'File', 'status': get({'C':'M','M':'?','U':'?'}, matchstr(sub, 'S\.*\zs[CMU]'), line[3]), 'filename': file, 'relative': [file], 'submodule': sub})
                                      endif
                                    endif
                                    let i += 1
                                  endwhile
                                  let branch = substitute(get(props, 'branch.head', '(unknown)'), '\C^(\%(detached\|unknown\))$', '', '')
                                  if len(branch)
                                    let head = branch
                                  elseif has_key(props, 'branch.oid')
                                    let head = props['branch.oid'][0:10]
                                  else
                                    let head = FugitiveHead(11)
                                  endif
                                  let pull = get(props, 'branch.upstream', '')
                                else " git < 2.11
                                  let cmd += ['status', '--porcelain', '-bz']
                                  let [output, message, exec_error] = s:NullError(cmd)
                                  if exec_error
                                    throw 'fugitive: ' . message
                                  endif
                            
                                  while get(output, 0, '') =~# '^\l\+:'
                                    call remove(output, 0)
                                  endwhile
                                  let head = matchstr(output[0], '^## \zs\S\+\ze\%($\| \[\)')
                                  if head =~# '\.\.\.'
                                    let [head, pull] = split(head, '\.\.\.')
                                    let branch = head
                                  elseif head ==# 'HEAD' || empty(head)
                                    let head = FugitiveHead(11)
                                    let branch = ''
                                  else
                                    let branch = head
                                  endif
                            
                                  let i = 0
                                  while i < len(output)
                                    let line = output[i]
                                    let file = line[3:-1]
                                    let i += 1
                                    if line[2] !=# ' '
                                      continue
                                    endif
                                    if line[0:1] =~# '[RC]'
                                      let relative = [file, output[i]]
                                      let i += 1
                                    else
                                      let relative = [file]
                                    endif
                                    let filename = join(reverse(copy(relative)), ' -> ')
                                    if line[0] !~# '[ ?!#]'
                                      call add(staged, {'type': 'File', 'status': line[0], 'filename': filename, 'relative': relative, 'submodule': ''})
                                    endif
                                    if line[0:1] ==# '??'
                                      call add(untracked, {'type': 'File', 'status': line[1], 'filename': filename, 'relative': relative})
                                    elseif line[1] !~# '[ !#]'
                                      call add(unstaged, {'type': 'File', 'status': line[1], 'filename': file, 'relative': [file], 'submodule': ''})
                                    endif
                                  endwhile
                                endif
                            
                                for dict in staged
                                  let b:fugitive_files['Staged'][dict.filename] = dict
                                endfor
                                for dict in unstaged
                                  let b:fugitive_files['Unstaged'][dict.filename] = dict
                                endfor
                            
                                let pull_type = 'Pull'
                                if len(pull)
                                  let rebase = FugitiveConfigGet('branch.' . branch . '.rebase', config)
                                  if empty(rebase)
                                    let rebase = FugitiveConfigGet('pull.rebase', config)
                                  endif
                                  if rebase =~# '^\%(true\|yes\|on\|1\|interactive\|merges\|preserve\)$'
                                    let pull_type = 'Rebase'
                                  elseif rebase =~# '^\%(false\|no|off\|0\|\)$'
                                    let pull_type = 'Merge'
                                  endif
                                endif
                            
                                let push_remote = FugitiveConfigGet('branch.' . branch . '.pushRemote', config)
                                if empty(push_remote)
                                  let push_remote = FugitiveConfigGet('remote.pushDefault', config)
                                endif
                                let fetch_remote = FugitiveConfigGet('branch.' . branch . '.remote', config)
                                if empty(fetch_remote)
                                  let fetch_remote = 'origin'
                                endif
                                if empty(push_remote)
                                  let push_remote = fetch_remote
                                endif
                            
                                let push_default = FugitiveConfigGet('push.default', config)
                                if empty(push_default)
                                  let push_default = fugitive#GitVersion(2) ? 'simple' : 'matching'
                                endif
                                if push_default ==# 'upstream'
                                  let push = pull
                                else
                                  let push = len(branch) ? (push_remote ==# '.' ? '' : push_remote . '/') . branch : ''
                                endif
                            
                                if isdirectory(fugitive#Find('.git/rebase-merge/'))
                                  let rebasing_dir = fugitive#Find('.git/rebase-merge/')
                                elseif isdirectory(fugitive#Find('.git/rebase-apply/'))
                                  let rebasing_dir = fugitive#Find('.git/rebase-apply/')
                                endif
                            
                                let rebasing = []
                                let rebasing_head = 'detached HEAD'
                                if exists('rebasing_dir') && filereadable(rebasing_dir . 'git-rebase-todo')
                                  let rebasing_head = substitute(readfile(rebasing_dir . 'head-name')[0], '\C^refs/heads/', '', '')
                                  let len = 11
                                  let lines = readfile(rebasing_dir . 'git-rebase-todo')
                                  for line in lines
                                    let hash = matchstr(line, '^[^a-z].*\s\zs[0-9a-f]\{4,\}\ze\.\.')
                                    if len(hash)
                                      let len = len(hash)
                                      break
                                    endif
                                  endfor
                                  if getfsize(rebasing_dir . 'done') > 0
                                    let done = readfile(rebasing_dir . 'done')
                                    call map(done, 'substitute(v:val, ''^\l\+\>'', "done", "")')
                                    let done[-1] = substitute(done[-1], '^\l\+\>', 'stop', '')
                                    let lines = done + lines
                                  endif
                                  call reverse(lines)
                                  for line in lines
                                    let match = matchlist(line, '^\(\l\+\)\s\+\(\x\{4,\}\)\s\+\(.*\)')
                                    if len(match) && match[1] !~# 'exec\|merge\|label'
                                      call add(rebasing, {'type': 'Rebase', 'status': get(s:rebase_abbrevs, match[1], match[1]), 'commit': strpart(match[2], 0, len), 'subject': match[3]})
                                    endif
                                  endfor
                                endif
                            
                                let diff = {'Staged': [], 'Unstaged': []}
                                if len(staged)
                                  let diff['Staged'] =
                                      \ s:LinesError(['diff', '--color=never', '--no-ext-diff', '--no-prefix', '--cached'])[0]
                                endif
                                if len(unstaged)
                                  let diff['Unstaged'] =
                                      \ s:LinesError(['diff', '--color=never', '--no-ext-diff', '--no-prefix'])[0]
                                endif
                                let b:fugitive_diff = diff
                                let expanded = get(b:, 'fugitive_expanded', {'Staged': {}, 'Unstaged': {}})
                                let b:fugitive_expanded = {'Staged': {}, 'Unstaged': {}}
                            
                                silent keepjumps %delete_
                            
                                call s:AddHeader('Head', head)
                                call s:AddHeader(pull_type, pull)
                                if push !=# pull
                                  call s:AddHeader('Push', push)
                                endif
                                if empty(s:Tree())
                                  if get(fugitive#ConfigGetAll('core.bare', config), 0, 'true') !~# '^\%(false\|no|off\|0\|\)$'
                                    call s:AddHeader('Bare', 'yes')
                                  else
                                    call s:AddHeader('Error', s:worktree_error)
                                  endif
                                endif
                                if get(fugitive#ConfigGetAll('advice.statusHints', config), 0, 'true') !~# '^\%(false\|no|off\|0\|\)$'
                                  call s:AddHeader('Help', 'g?')
                                endif
                            
                                call s:AddSection('Rebasing ' . rebasing_head, rebasing)
                                call s:AddSection('Untracked', untracked)
                                call s:AddSection('Unstaged', unstaged)
                                let unstaged_end = len(unstaged) ? line('$') : 0
                                call s:AddSection('Staged', staged)
                                let staged_end = len(staged) ? line('$') : 0
                            
                                if len(pull) && get(props, 'branch.ab') !~# ' -0$'
                                  call s:AddSection('Unpulled from ' . pull, s:QueryLog(head . '..' . pull))
                                endif
                                if len(push) && push !=# pull
                                  call s:AddSection('Unpulled from ' . push, s:QueryLog(head . '..' . push))
                                endif
                                if len(pull) && push !=# pull
                                  call s:AddSection('Unpushed to ' . pull, s:QueryLog(pull . '..' . head))
                                endif
                                if len(push) && !(push ==# pull && get(props, 'branch.ab') =~# '^+0 ')
                                  call s:AddSection('Unpushed to ' . push, s:QueryLog(push . '..' . head))
                                endif
                            
                                setlocal nomodified readonly noswapfile
                                silent doautocmd BufReadPost
                                setlocal nomodifiable
                                if &bufhidden ==# ''
                                  setlocal bufhidden=delete
                                endif
                                let b:dispatch = '-dir=' . s:fnameescape(len(s:Tree()) ? s:Tree() : s:GitDir()) . ' ' . s:GitShellCmd() . ' fetch --all'
                                call fugitive#MapJumps()
                                call s:Map('n', '-', ":<C-U>execute <SID>Do('Toggle',0)<CR>", '<silent>')
                                call s:Map('x', '-', ":<C-U>execute <SID>Do('Toggle',1)<CR>", '<silent>')
                                call s:Map('n', 's', ":<C-U>execute <SID>Do('Stage',0)<CR>", '<silent>')
                                call s:Map('x', 's', ":<C-U>execute <SID>Do('Stage',1)<CR>", '<silent>')
                                call s:Map('n', 'u', ":<C-U>execute <SID>Do('Unstage',0)<CR>", '<silent>')
                                call s:Map('x', 'u', ":<C-U>execute <SID>Do('Unstage',1)<CR>", '<silent>')
                                call s:Map('n', 'U', ":<C-U>Git reset -q<CR>", '<silent>')
                                call s:MapMotion('gu', "exe <SID>StageJump(v:count, 'Untracked', 'Unstaged')")
                                call s:MapMotion('gU', "exe <SID>StageJump(v:count, 'Unstaged', 'Untracked')")
                                call s:MapMotion('gs', "exe <SID>StageJump(v:count, 'Staged')")
                                call s:MapMotion('gp', "exe <SID>StageJump(v:count, 'Unpushed')")
                                call s:MapMotion('gP', "exe <SID>StageJump(v:count, 'Unpulled')")
                                call s:MapMotion('gr', "exe <SID>StageJump(v:count, 'Rebasing')")
                                call s:Map('n', 'C', ":echoerr 'fugitive: C has been removed in favor of cc'<CR>", '<silent><unique>')
                                call s:Map('n', 'a', ":<C-U>execute <SID>Do('Toggle',0)<CR>", '<silent>')
                                call s:Map('n', 'i', ":<C-U>execute <SID>NextExpandedHunk(v:count1)<CR>", '<silent>')
                                call s:Map('n', "=", ":<C-U>execute <SID>StageInline('toggle',line('.'),v:count)<CR>", '<silent>')
                                call s:Map('n', "<", ":<C-U>execute <SID>StageInline('hide',  line('.'),v:count)<CR>", '<silent>')
                                call s:Map('n', ">", ":<C-U>execute <SID>StageInline('show',  line('.'),v:count)<CR>", '<silent>')
                                call s:Map('x', "=", ":<C-U>execute <SID>StageInline('toggle',line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('x', "<", ":<C-U>execute <SID>StageInline('hide',  line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('x', ">", ":<C-U>execute <SID>StageInline('show',  line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('n', 'D', ":echoerr 'fugitive: D has been removed in favor of dd'<CR>", '<silent><unique>')
                                call s:Map('n', 'dd', ":<C-U>execute <SID>StageDiff('Gdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'dh', ":<C-U>execute <SID>StageDiff('Ghdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'ds', ":<C-U>execute <SID>StageDiff('Ghdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'dp', ":<C-U>execute <SID>StageDiffEdit()<CR>", '<silent>')
                                call s:Map('n', 'dv', ":<C-U>execute <SID>StageDiff('Gvdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'd?', ":<C-U>help fugitive_d<CR>", '<silent>')
                                call s:Map('n', 'P', ":<C-U>execute <SID>StagePatch(line('.'),line('.')+v:count1-1)<CR>", '<silent>')
                                call s:Map('x', 'P', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                call s:Map('n', 'p', ":<C-U>if v:count<Bar>silent exe <SID>GF('pedit')<Bar>else<Bar>echoerr 'Use = for inline diff, P for :Git add/reset --patch, 1p for :pedit'<Bar>endif<CR>", '<silent>')
                                call s:Map('x', 'p', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                call s:Map('n', 'I', ":<C-U>execute <SID>StagePatch(line('.'),line('.'))<CR>", '<silent>')
                                call s:Map('x', 'I', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                if empty(mapcheck('q', 'n'))
                                  nnoremap <buffer> <silent> q :echoerr "fugitive: q removed in favor of gq (or :q)"<CR>
                                endif
                                call s:Map('n', 'gq', ":<C-U>if bufnr('$') == 1<Bar>quit<Bar>else<Bar>bdelete<Bar>endif<CR>", '<silent>')
                                call s:Map('n', 'R', ":echohl WarningMsg<Bar>echo 'Reloading is automatic.  Use :e to force'<Bar>echohl NONE<CR>", '<silent>')
                                call s:Map('n', 'g<Bar>', ":<C-U>echoerr 'Changed to X'<CR>", '<silent><unique>')
                                call s:Map('x', 'g<Bar>', ":<C-U>echoerr 'Changed to X'<CR>", '<silent><unique>')
                                call s:Map('n', 'X', ":<C-U>execute <SID>StageDelete(line('.'), 0, v:count)<CR>", '<silent>')
                                call s:Map('x', 'X', ":<C-U>execute <SID>StageDelete(line(\"'<\"), line(\"'>\"), v:count)<CR>", '<silent>')
                                call s:Map('n', 'gI', ":<C-U>execute <SID>StageIgnore(line('.'), line('.'), v:count)<CR>", '<silent>')
                                call s:Map('x', 'gI', ":<C-U>execute <SID>StageIgnore(line(\"'<\"), line(\"'>\"), v:count)<CR>", '<silent>')
                                call s:Map('n', '.', ':<C-U> <C-R>=<SID>StageArgs(0)<CR><Home>')
                                call s:Map('x', '.', ':<C-U> <C-R>=<SID>StageArgs(1)<CR><Home>')
                                setlocal filetype=fugitive
                            
                                for [lnum, section] in [[staged_end, 'Staged'], [unstaged_end, 'Unstaged']]
                                  while len(getline(lnum))
                                    let filename = matchstr(getline(lnum), '^[A-Z?] \zs.*')
                                    if has_key(expanded[section], filename)
                                      call s:StageInline('show', lnum)
                                    endif
                                    let lnum -= 1
                                  endwhile
                                endfor
                            
                                let b:fugitive_reltime = reltime()
                                return s:DoAutocmd('User FugitiveIndex')
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! fugitive#FileReadCmd(...) abort
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let [dir, rev] = s:DirRev(amatch)
                              let line = a:0 > 1 ? a:2 : line("'[")
                              if empty(dir)
                                return 'noautocmd ' . line . 'read ' . s:fnameescape(amatch)
                              endif
                              if rev !~# ':' && s:ChompDefault('', [dir, 'cat-file', '-t', rev]) =~# '^\%(commit\|tag\)$'
                                let cmd = [dir, 'log', '--pretty=format:%B', '-1', rev, '--']
                              else
                                let cmd = [dir, 'cat-file', '-p', rev, '--']
                              endif
                              let temp = tempname()
                              let [err, exec_error] = s:StdoutToFile(temp, cmd)
                              if exec_error
                                call delete(temp)
                                return 'noautocmd ' . line . 'read ' . s:fnameescape(amatch)
                              else
                                return 'silent keepalt ' . line . 'read ' . s:fnameescape(temp) . '|call delete(' . string(temp) . ')'
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#FileWriteCmd(...) abort
                              let temp = tempname()
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let autype = a:0 > 1 ? 'Buf' : 'File'
                              if exists('#' . autype . 'WritePre')
                                execute s:DoAutocmd(autype . 'WritePre ' . s:fnameescape(amatch))
                              endif
                              try
                                let [dir, commit, file] = s:DirCommitFile(amatch)
                                if commit !~# '^[0-3]$' || !v:cmdbang && (line("'[") != 1 || line("']") != line('$'))
                                  return "noautocmd '[,']write" . (v:cmdbang ? '!' : '') . ' ' . s:fnameescape(amatch)
                                endif
                                silent execute "noautocmd keepalt '[,']write ".temp
                                let hash = s:TreeChomp([dir, '--literal-pathspecs', 'hash-object', '-w', '--', FugitiveGitPath(temp)])
                                let old_mode = matchstr(s:ChompDefault('', ['ls-files', '--stage', '.' . file], dir), '^\d\+')
                                if empty(old_mode)
                                  let old_mode = executable(s:Tree(dir) . file) ? '100755' : '100644'
                                endif
                                let error = s:UpdateIndex(dir, [old_mode, hash, commit, file[1:-1]])
                                if empty(error)
                                  setlocal nomodified
                                  if exists('#' . autype . 'WritePost')
                                    execute s:DoAutocmd(autype . 'WritePost ' . s:fnameescape(amatch))
                                  endif
                                  exe s:DoAutocmdChanged(dir)
                                  return ''
                                else
                                  return 'echoerr '.string('fugitive: '.error)
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              finally
                                call delete(temp)
                              endtry
                            endfunction
                            
    1              0.000001 function! fugitive#BufReadCmd(...) abort
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              try
                                let [dir, rev] = s:DirRev(amatch)
                                if empty(dir)
                                  return 'echo "Invalid Fugitive URL"'
                                endif
                                let b:git_dir = s:GitDir(dir)
                                if rev =~# '^:\d$'
                                  let b:fugitive_type = 'stage'
                                else
                                  let r = fugitive#Execute([dir, 'cat-file', '-t', rev])
                                  let b:fugitive_type = get(r.stdout, 0, '')
                                  if r.exit_status && rev =~# '^:0'
                                    let r = fugitive#Execute([dir, 'write-tree', '--prefix=' . rev[3:-1]])
                                    let sha = get(r.stdout, 0, '')
                                    let b:fugitive_type = 'tree'
                                  endif
                                  if r.exit_status
                                    let error = substitute(join(r.stderr, "\n"), "\n*$", '', '')
                                    unlet b:fugitive_type
                                    setlocal noswapfile
                                    if empty(&bufhidden)
                                      setlocal bufhidden=delete
                                    endif
                                    if rev =~# '^:\d:'
                                      let &l:readonly = !filewritable(fugitive#Find('.git/index', dir))
                                      return 'silent doautocmd BufNewFile'
                                    else
                                      setlocal readonly nomodifiable
                                      return 'silent doautocmd BufNewFile|echo ' . string(error)
                                    endif
                                  elseif b:fugitive_type !~# '^\%(tag\|commit\|tree\|blob\)$'
                                    return "echoerr ".string("fugitive: unrecognized git type '".b:fugitive_type."'")
                                  endif
                                  if !exists('b:fugitive_display_format') && b:fugitive_type != 'blob'
                                    let b:fugitive_display_format = +getbufvar('#','fugitive_display_format')
                                  endif
                                endif
                            
                                if b:fugitive_type !=# 'blob'
                                  setlocal nomodeline
                                endif
                            
                                setlocal noreadonly modifiable
                                let pos = getpos('.')
                                silent keepjumps %delete_
                                setlocal endofline
                            
                                let events = ['User FugitiveObject', 'User Fugitive' . substitute(b:fugitive_type, '^\l', '\u&', '')]
                            
                                try
                                  if b:fugitive_type !=# 'blob'
                                    setlocal foldmarker=<<<<<<<<,>>>>>>>>
                                  endif
                                  silent exe s:DoAutocmd('BufReadPre')
                                  if b:fugitive_type ==# 'tree'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'ls-tree', exists('sha') ? sha : rev])
                                    else
                                      if !exists('sha')
                                        let sha = s:TreeChomp(dir, 'rev-parse', '--verify', rev, '--')
                                      endif
                                      call s:ReplaceCmd([dir, 'show', '--no-color', sha])
                                    endif
                                  elseif b:fugitive_type ==# 'tag'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                    else
                                      call s:ReplaceCmd([dir, 'cat-file', '-p', rev])
                                    endif
                                  elseif b:fugitive_type ==# 'commit'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                    else
                                      call s:ReplaceCmd([dir, '-c', 'diff.noprefix=false', 'show', '--no-color', '-m', '--first-parent', '--pretty=format:tree%x20%T%nparent%x20%P%nauthor%x20%an%x20<%ae>%x20%ad%ncommitter%x20%cn%x20<%ce>%x20%cd%nencoding%x20%e%n%n%s%n%n%b', rev])
                                      keepjumps 1
                                      keepjumps call search('^parent ')
                                      if getline('.') ==# 'parent '
                                        silent lockmarks keepjumps delete_
                                      else
                                        silent exe (exists(':keeppatterns') ? 'keeppatterns' : '') 'keepjumps s/\m\C\%(^parent\)\@<! /\rparent /e' . (&gdefault ? '' : 'g')
                                      endif
                                      keepjumps let lnum = search('^encoding \%(<unknown>\)\=$','W',line('.')+3)
                                      if lnum
                                        silent lockmarks keepjumps delete_
                                      end
                                      silent exe (exists(':keeppatterns') ? 'keeppatterns' : '') 'keepjumps 1,/^diff --git\|\%$/s/\r$//e'
                                      keepjumps 1
                                    endif
                                  elseif b:fugitive_type ==# 'stage'
                                    call s:ReplaceCmd([dir, 'ls-files', '--stage'])
                                  elseif b:fugitive_type ==# 'blob'
                                    call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                  endif
                                finally
                                  keepjumps call setpos('.',pos)
                                  setlocal nomodified noswapfile
                                  let modifiable = rev =~# '^:.:' && b:fugitive_type !=# 'tree'
                                  if modifiable
                                    let events = ['User FugitiveStageBlob']
                                  endif
                                  let &l:readonly = !modifiable || !filewritable(fugitive#Find('.git/index', dir))
                                  if empty(&bufhidden)
                                    setlocal bufhidden=delete
                                  endif
                                  let &l:modifiable = modifiable
                                  if b:fugitive_type !=# 'blob'
                                    setlocal filetype=git
                                    call s:Map('n', 'a', ":<C-U>let b:fugitive_display_format += v:count1<Bar>exe fugitive#BufReadCmd(@%)<CR>", '<silent>')
                                    call s:Map('n', 'i', ":<C-U>let b:fugitive_display_format -= v:count1<Bar>exe fugitive#BufReadCmd(@%)<CR>", '<silent>')
                                  endif
                                  call fugitive#MapJumps()
                                endtry
                            
                                setlocal modifiable
                            
                                return 'silent ' . s:DoAutocmd('BufReadPost') .
                                      \ (modifiable ? '' : '|setl nomodifiable') . '|' .
                                      \ call('s:DoAutocmd', events)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! fugitive#BufWriteCmd(...) abort
                              return fugitive#FileWriteCmd(a:0 ? a:1 : expand('<amatch>'), 1)
                            endfunction
                            
    1              0.000001 function! fugitive#SourceCmd(...) abort
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let temp = s:BlobTemp(amatch)
                              if empty(temp)
                                return 'noautocmd source ' . s:fnameescape(amatch)
                              endif
                              if !exists('g:virtual_scriptnames')
                                let g:virtual_scriptnames = {}
                              endif
                              let g:virtual_scriptnames[temp] = amatch
                              return 'source ' . s:fnameescape(temp)
                            endfunction
                            
                            " Section: Temp files
                            
    1              0.000002 if !exists('s:temp_files')
    1              0.000002   let s:temp_files = {}
    1              0.000001 endif
                            
    1              0.000001 function! s:TempState(...) abort
                              return get(s:temp_files, s:cpath(fnamemodify(a:0 ? a:1 : @%, ':p')), {})
                            endfunction
                            
    1              0.000001 function! fugitive#Result(...) abort
                              if !a:0 && exists('g:fugitive_event')
                                return get(g:, 'fugitive_result', {})
                              elseif !a:0 || type(a:1) == type('') && a:1 =~# '^-\=$'
                                return get(g:, '_fugitive_last_job', {})
                              elseif type(a:1) == type(0)
                                return s:TempState(bufname(a:1))
                              elseif type(a:1) == type('')
                                return s:TempState(a:1)
                              elseif type(a:1) == type({}) && has_key(a:1, 'file')
                                return s:TempState(a:1.file)
                              else
                                return {}
                              endif
                            endfunction
                            
    1              0.000001 function! s:TempDotMap() abort
                              let cfile = s:cfile()
                              if empty(cfile)
                                if getline('.') =~# '^[*+] \+\f' && col('.') < 2
                                  return matchstr(getline('.'), '^. \+\zs\f\+')
                                else
                                  return expand('<cfile>')
                                endif
                              endif
                              let name = fugitive#Find(cfile[0])
                              let [dir, commit, file] = s:DirCommitFile(name)
                              if len(commit) && empty(file)
                                return commit
                              elseif s:cpath(s:Tree(), getcwd())
                                return fugitive#Path(name, "./")
                              else
                                return fugitive#Real(name)
                              endif
                            endfunction
                            
    1              0.000001 function! s:TempReadPre(file) abort
                              if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                setlocal nomodeline
                                if empty(&bufhidden)
                                  setlocal bufhidden=delete
                                endif
                                setlocal buftype=nowrite
                                setlocal nomodifiable
                                let b:git_dir = dict.git_dir
                                if len(dict.git_dir)
                                  call extend(b:, {'fugitive_type': 'temp'}, 'keep')
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! s:TempReadPost(file) abort
                              if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                if !has_key(dict, 'job')
                                  setlocal nobuflisted
                                endif
                                if get(dict, 'filetype', '') ==# 'git'
                                  call fugitive#MapJumps()
                                  call s:Map('n', '.', ":<C-U> <C-R>=<SID>fnameescape(<SID>TempDotMap())<CR><Home>")
                                  call s:Map('x', '.', ":<C-U> <C-R>=<SID>fnameescape(<SID>TempDotMap())<CR><Home>")
                                endif
                                if has_key(dict, 'filetype')
                                  if dict.filetype ==# 'man' && has('nvim')
                                    let b:man_sect = matchstr(getline(1), '^\w\+(\zs\d\+\ze)')
                                  endif
                                  let &l:filetype = dict.filetype
                                endif
                                setlocal foldmarker=<<<<<<<<,>>>>>>>>
                                if !&modifiable
                                  if empty(mapcheck('q', 'n'))
                                    nnoremap <buffer> <silent> q    :<C-U>echoerr "fugitive: q is removed in favor of gq (or :q)"<CR>
                                  endif
                                  call s:Map('n', 'gq', ":<C-U>bdelete<CR>", '<silent> <unique>')
                                endif
                              endif
                              return s:DoAutocmd('User FugitivePager')
                            endfunction
                            
    1              0.000001 function! s:TempDelete(file) abort
                              let key = s:cpath(a:file)
                              if has_key(s:temp_files, key) && !has_key(s:temp_files[key], 'job') && key !=# s:cpath(get(get(g:, '_fugitive_last_job', {}), 'file', ''))
                                call delete(a:file)
                                call remove(s:temp_files, key)
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 augroup fugitive_temp
    1              0.000114   autocmd!
    1              0.000009   autocmd BufReadPre  * exe s:TempReadPre( expand('<amatch>:p'))
    1              0.000003   autocmd BufReadPost * exe s:TempReadPost(expand('<amatch>:p'))
    1              0.000002   autocmd BufWipeout  * exe s:TempDelete(  expand('<amatch>:p'))
    1              0.000001 augroup END
                            
                            " Section: :Git
                            
    1              0.000001 function! s:AskPassArgs(dir) abort
                              if (len($DISPLAY) || len($TERM_PROGRAM) || has('gui_running')) &&
                                    \ empty($GIT_ASKPASS) && empty($SSH_ASKPASS) && empty(fugitive#ConfigGetAll('core.askpass', a:dir))
                                if s:executable(FugitiveVimPath(s:ExecPath() . '/git-gui--askpass'))
                                  return ['-c', 'core.askPass=' . s:ExecPath() . '/git-gui--askpass']
                                elseif s:executable('ssh-askpass')
                                  return ['-c', 'core.askPass=ssh-askpass']
                                endif
                              endif
                              return []
                            endfunction
                            
    1              0.000001 function! s:RunSave(state) abort
                              let s:temp_files[s:cpath(a:state.file)] = a:state
                            endfunction
                            
    1              0.000001 function! s:RunFinished(state, ...) abort
                              if has_key(get(g:, '_fugitive_last_job', {}), 'file') && bufnr(g:_fugitive_last_job.file) < 0
                                exe s:TempDelete(remove(g:, '_fugitive_last_job').file)
                              endif
                              let g:_fugitive_last_job = a:state
                              let first = join(readfile(a:state.file, '', 2), "\n")
                              if get(a:state, 'filetype', '') ==# 'git' && first =~# '\<\([[:upper:][:digit:]_-]\+(\d\+)\).*\1'
                                let a:state.filetype = 'man'
                              endif
                              if !has_key(a:state, 'capture_bufnr')
                                return
                              endif
                              call fugitive#ReloadStatus(a:state, 1)
                            endfunction
                            
    1              0.000001 function! s:RunEdit(state, tmp, job) abort
                              if get(a:state, 'request', '') !=# 'edit'
                                return 0
                              endif
                              call remove(a:state, 'request')
                              let sentinel = a:state.file . '.edit'
                              let file = FugitiveVimPath(readfile(sentinel, '', 1)[0])
                              exe substitute(a:state.mods, '\<tab\>', '-tab', 'g') 'keepalt split' s:fnameescape(file)
                              set bufhidden=wipe
                              let s:edit_jobs[bufnr('')] = [a:state, a:tmp, a:job, sentinel]
                              call fugitive#ReloadStatus(a:state.git_dir, 1)
                              return 1
                            endfunction
                            
    1              0.000002 function! s:RunReceive(state, tmp, type, job, data, ...) abort
                              if a:type ==# 'err' || a:state.pty
                                let data = type(a:data) == type([]) ? join(a:data, "\n") : a:data
                                let data = a:tmp.escape . data
                                let escape = "\033]51;[^\007]*"
                                let a:tmp.escape = matchstr(data, escape . '$')
                                if len(a:tmp.escape)
                                  let data = strpart(data, 0, len(data) - len(a:tmp.escape))
                                endif
                                let cmd = matchstr(data, escape . "\007")[5:-2]
                                let data = substitute(data, escape . "\007", '', 'g')
                                if cmd =~# '^fugitive:'
                                  let a:state.request = strpart(cmd, 9)
                                endif
                                let lines = split(a:tmp.err . data, "\r\\=\n", 1)
                                let a:tmp.err = lines[-1]
                                let lines[-1] = ''
                                call map(lines, 'substitute(v:val, ".*\r", "", "")')
                              else
                                let lines = type(a:data) == type([]) ? a:data : split(a:data, "\n", 1)
                                if len(a:tmp.out)
                                  let lines[0] = a:tmp.out . lines[0]
                                endif
                                let a:tmp.out = lines[-1]
                                let lines[-1] = ''
                              endif
                              call writefile(lines, a:state.file, 'ba')
                              if has_key(a:tmp, 'echo')
                                if !exists('l:data')
                                  let data = type(a:data) == type([]) ? join(a:data, "\n") : a:data
                                endif
                                let a:tmp.echo .= data
                              endif
                              let line_count = a:tmp.line_count
                              let a:tmp.line_count += len(lines) - 1
                              if !has_key(a:state, 'capture_bufnr') || !bufloaded(a:state.capture_bufnr)
                                return
                              endif
                              call remove(lines, -1)
                              try
                                call setbufvar(a:state.capture_bufnr, '&modifiable', 1)
                                if !line_count && len(lines) > 1000
                                  let first = remove(lines, 0, 999)
                                  call setbufline(a:state.capture_bufnr, 1, first)
                                  redraw
                                  call setbufline(a:state.capture_bufnr, 1001, lines)
                                else
                                  call setbufline(a:state.capture_bufnr, line_count + 1, lines)
                                endif
                                call setbufvar(a:state.capture_bufnr, '&modifiable', 0)
                                if !getwinvar(bufwinid(a:state.capture_bufnr), '&previewwindow')
                                  " no-op
                                elseif exists('*win_execute')
                                  call win_execute(bufwinid(a:state.capture_bufnr), '$')
                                else
                                  let winnr = bufwinnr(a:state.capture_bufnr)
                                  if winnr > 0
                                    let old_winnr = winnr()
                                    exe 'noautocmd' winnr.'wincmd w'
                                    $
                                    exe 'noautocmd' old_winnr.'wincmd w'
                                  endif
                                endif
                              catch
                              endtry
                            endfunction
                            
    1              0.000002 function! s:RunExit(state, tmp, job, exit_status) abort
                              let a:state.exit_status = a:exit_status
                              if has_key(a:state, 'job')
                                return
                              endif
                              call s:RunFinished(a:state)
                            endfunction
                            
    1              0.000001 function! s:RunClose(state, tmp, job, ...) abort
                              if a:0
                                call s:RunExit(a:state, a:tmp, a:job, a:1)
                              endif
                              let noeol = substitute(substitute(a:tmp.err, "\r$", '', ''), ".*\r", '', '') . a:tmp.out
                              call writefile([noeol], a:state.file, 'ba')
                              call remove(a:state, 'job')
                              if has_key(a:state, 'capture_bufnr') && bufloaded(a:state.capture_bufnr)
                                if len(noeol)
                                  call setbufvar(a:state.capture_bufnr, '&modifiable', 1)
                                  call setbufline(a:state.capture_bufnr, a:tmp.line_count + 1, [noeol])
                                  call setbufvar(a:state.capture_bufnr, '&eol', 0)
                                  call setbufvar(a:state.capture_bufnr, '&modifiable', 0)
                                endif
                                call setbufvar(a:state.capture_bufnr, '&modified', 0)
                                call setbufvar(a:state.capture_bufnr, '&buflisted', 0)
                                if a:state.filetype !=# getbufvar(a:state.capture_bufnr, '&filetype', '')
                                  call setbufvar(a:state.capture_bufnr, '&filetype', a:state.filetype)
                                endif
                              endif
                              if !has_key(a:state, 'exit_status')
                                return
                              endif
                              call s:RunFinished(a:state)
                            endfunction
                            
    1              0.000001 function! s:RunSend(job, str) abort
                              try
                                if type(a:job) == type(0)
                                  call chansend(a:job, a:str)
                                else
                                  call ch_sendraw(a:job, a:str)
                                endif
                                return len(a:str)
                              catch /^Vim\%((\a\+)\)\=:E90[06]:/
                                return 0
                              endtry
                            endfunction
                            
    1              0.000001 function! s:RunCloseIn(job) abort
                              try
                                if type(a:job) ==# type(0)
                                  call chanclose(a:job, 'stdin')
                                else
                                  call ch_close_in(a:job)
                                endif
                                return 1
                              catch /^Vim\%((\a\+)\)\=:E90[06]:/
                                return 0
                              endtry
                            endfunction
                            
    1              0.000001 function! s:RunEcho(tmp) abort
                              if !has_key(a:tmp, 'echo')
                                return
                              endif
                              let data = a:tmp.echo
                              let a:tmp.echo = matchstr(data, "[\r\n]\\+$")
                              if len(a:tmp.echo)
                                let data = strpart(data, 0, len(data) - len(a:tmp.echo))
                              endif
                              echon substitute(data, "\r\\ze\n", '', 'g')
                            endfunction
                            
    1              0.000001 function! s:RunTick(job) abort
                              if type(a:job) == v:t_number
                                return jobwait([a:job], 1)[0] == -1
                              elseif type(a:job) == 8
                                let running = ch_status(a:job) !~# '^closed$\|^failed$' || job_status(a:job) ==# 'run'
                                sleep 1m
                                return running
                              endif
                            endfunction
                            
    1              0.000002 if !exists('s:edit_jobs')
    1              0.000009   let s:edit_jobs = {}
    1              0.000001 endif
    1              0.000001 function! s:RunWait(state, tmp, job, ...) abort
                              if a:0 && filereadable(a:1)
                                call delete(a:1)
                              endif
                              try
                                if a:tmp.no_more && &more
                                  let more = &more
                                  let &more = 0
                                endif
                                while get(a:state, 'request', '') !=# 'edit' && s:RunTick(a:job)
                                  call s:RunEcho(a:tmp)
                                  if !get(a:tmp, 'closed_in')
                                    let peek = getchar(1)
                                    if peek != 0 && !(has('win32') && peek == 128)
                                      let c = getchar()
                                      let c = type(c) == type(0) ? nr2char(c) : c
                                      if c ==# "\<C-D>" || c ==# "\<Esc>"
                                        let a:tmp.closed_in = 1
                                        let can_pedit = s:RunCloseIn(a:job) && exists('*setbufline')
                                        for winnr in range(1, winnr('$'))
                                          if getwinvar(winnr, '&previewwindow') && getbufvar(winbufnr(winnr), '&modified')
                                            let can_pedit = 0
                                          endif
                                        endfor
                                        if can_pedit
                                          if has_key(a:tmp, 'echo')
                                            call remove(a:tmp, 'echo')
                                          endif
                                          call writefile(['fugitive: aborting edit due to background operation.'], a:state.file . '.exit')
                                          exe (&splitbelow ? 'botright' : 'topleft') 'silent pedit ++ff=unix' s:fnameescape(a:state.file)
                                          let a:state.capture_bufnr = bufnr(a:state.file)
                                          call setbufvar(a:state.capture_bufnr, '&modified', 1)
                                          let finished = 0
                                          redraw!
                                          return ''
                                        endif
                                      else
                                        call s:RunSend(a:job, c)
                                        if !a:state.pty
                                          echon c
                                        endif
                                      endif
                                    endif
                                  endif
                                endwhile
                                if !has_key(a:state, 'request') && has_key(a:state, 'job') && exists('*job_status') && job_status(a:job) ==# "dead"
                                  throw 'fugitive: close callback did not fire; this should never happen'
                                endif
                                call s:RunEcho(a:tmp)
                                if has_key(a:tmp, 'echo')
                                  let a:tmp.echo = substitute(a:tmp.echo, "^\r\\=\n", '', '')
                                  echo
                                endif
                                let finished = !s:RunEdit(a:state, a:tmp, a:job)
                              finally
                                if exists('l:more')
                                  let &more = more
                                endif
                                if !exists('finished')
                                  try
                                    if a:state.pty && !get(a:tmp, 'closed_in')
                                      call s:RunSend(a:job, "\<C-C>")
                                    elseif type(a:job) == type(0)
                                      call jobstop(a:job)
                                    else
                                      call job_stop(a:job)
                                    endif
                                  catch /.*/
                                  endtry
                                elseif finished
                                  call fugitive#ReloadStatus(a:state, 1)
                                endif
                              endtry
                              return ''
                            endfunction
                            
    1              0.000002 if !exists('s:resume_queue')
    1              0.000001   let s:resume_queue = []
    1              0.000001 endif
    1              0.000001 function! fugitive#Resume() abort
                              while len(s:resume_queue)
                                if s:resume_queue[0][2] isnot# ''
                                  try
                                    call call('s:RunWait', remove(s:resume_queue, 0))
                                  endtry
                                endif
                              endwhile
                            endfunction
                            
    1              0.000001 function! s:RunBufDelete(bufnr) abort
                              let state = s:TempState(bufname(+a:bufnr))
                              if has_key(state, 'job')
                                try
                                  if type(state.job) == type(0)
                                    call jobstop(state.job)
                                  else
                                    call job_stop(state.job)
                                  endif
                                catch
                                endtry
                              endif
                              if has_key(s:edit_jobs, a:bufnr) |
                                call add(s:resume_queue, remove(s:edit_jobs, a:bufnr))
                                call feedkeys(":redraw!|call delete(" . string(s:resume_queue[-1][0].file . '.edit') .
                                      \ ")|call fugitive#Resume()|silent checktime\r", 'n')
                              endif
                            endfunction
                            
    1              0.000001 augroup fugitive_job
    1              0.000046   autocmd!
    1              0.000005   autocmd BufDelete * call s:RunBufDelete(+expand('<abuf>'))
    1              0.000007   autocmd VimLeave *
                                    \ for s:jobbuf in keys(s:edit_jobs) |
                                    \   call writefile(['Aborting edit due to Vim exit.'], s:edit_jobs[s:jobbuf][0].file . '.exit') |
                                    \   redraw! |
                                    \   call call('s:RunWait', remove(s:edit_jobs, s:jobbuf)) |
                                    \ endfor
    1              0.000001 augroup END
                            
    1              0.000001 function! fugitive#PagerFor(argv, ...) abort
                              let args = a:argv
                              if empty(args)
                                return 0
                              elseif (args[0] ==# 'help' || get(args, 1, '') ==# '--help') && !s:HasOpt(args, '--web')
                                return 1
                              endif
                              if args[0] ==# 'config' && (s:HasOpt(args, '-e', '--edit') ||
                                    \   !s:HasOpt(args, '--list', '--get-all', '--get-regexp', '--get-urlmatch')) ||
                                    \ args[0] =~# '^\%(tag\|branch\)$' && (
                                    \    s:HasOpt(args, '--edit-description', '--unset-upstream', '-m', '-M', '--move', '-c', '-C', '--copy', '-d', '-D', '--delete') ||
                                    \   len(filter(args[1:-1], 'v:val =~# "^[^-]\\|^--set-upstream-to="')) &&
                                    \   !s:HasOpt(args, '--contains', '--no-contains', '--merged', '--no-merged', '--points-at'))
                                return 0
                              endif
                              let config = a:0 ? a:1 : fugitive#Config()
                              let value = get(fugitive#ConfigGetAll('pager.' . args[0], config), 0, -1)
                              if value =~# '^\%(true\|yes\|on\|1\)$'
                                return 1
                              elseif value =~# '^\%(false\|no|off\|0\|\)$'
                                return 0
                              elseif type(value) == type('')
                                return value
                              elseif args[0] =~# '^\%(branch\|config\|diff\|grep\|log\|range-diff\|shortlog\|show\|tag\|whatchanged\)$' ||
                                    \ (args[0] ==# 'stash' && get(args, 1, '') ==# 'show') ||
                                    \ (args[0] ==# 'reflog' && get(args, 1, '') !~# '^\%(expire\|delete\|exists\)$') ||
                                    \ (args[0] ==# 'am' && s:HasOpt(args, '--show-current-patch'))
                                return 1
                              else
                                return 0
                              endif
                            endfunction
                            
    1              0.000002 let s:disable_colors = []
   13              0.000011 for s:colortype in ['advice', 'branch', 'diff', 'grep', 'interactive', 'pager', 'push', 'remote', 'showBranch', 'status', 'transport', 'ui']
   12              0.000026   call extend(s:disable_colors, ['-c', 'color.' . s:colortype . '=false'])
   13              0.000005 endfor
    1              0.000003 unlet s:colortype
    1              0.000002 function! fugitive#Command(line1, line2, range, bang, mods, arg) abort
                              exe s:VersionCheck()
                              let dir = s:Dir()
                              if len(dir)
                                exe s:DirCheck(dir)
                              endif
                              let config = copy(fugitive#Config(dir))
                              let curwin = a:arg =~# '^++curwin\>' || !a:line2
                              let [args, after] = s:SplitExpandChain(substitute(a:arg, '^++curwin\>\s*', '', ''), s:Tree(dir))
                              let flags = []
                              let pager = -1
                              let explicit_pathspec_option = 0
                              while len(args)
                                if args[0] ==# '-c' && len(args) > 1
                                  call extend(flags, remove(args, 0, 1))
                                elseif args[0] =~# '^-p$\|^--paginate$'
                                  let pager = 2
                                  call remove(args, 0)
                                elseif args[0] =~# '^-P$\|^--no-pager$'
                                  let pager = 0
                                  call remove(args, 0)
                                elseif args[0] =~# '^--\%([[:lower:]-]\+-pathspecs\)$'
                                  let explicit_pathspec_option = 1
                                  call add(flags, remove(args, 0))
                                elseif args[0] =~# '^\%(--no-optional-locks\)$'
                                  call add(flags, remove(args, 0))
                                elseif args[0] =~# '^-C$\|^--\%(exec-path=\|git-dir=\|work-tree=\|bare$\)'
                                  return 'echoerr ' . string('fugitive: ' . args[0] . ' is not supported')
                                else
                                  break
                                endif
                              endwhile
                              if !explicit_pathspec_option
                                call insert(flags, '--no-literal-pathspecs')
                              endif
                              let no_pager = pager is# 0
                              if no_pager
                                call add(flags, '--no-pager')
                              endif
                              let env = {}
                              let i = 0
                              while i < len(flags) - 1
                                if flags[i] ==# '-c'
                                  let i += 1
                                  let config_name = tolower(matchstr(flags[i], '^[^=]\+'))
                                  if has_key(s:prepare_env, config_name) && flags[i] =~# '=.'
                                    let env[s:prepare_env[config_name]] = matchstr(flags[i], '=\zs.*')
                                  endif
                                  if flags[i] =~# '='
                                    let config[config_name] = [matchstr(flags[i], '=\zs.*')]
                                  else
                                    let config[config_name] = [1]
                                  endif
                                endif
                                let i += 1
                              endwhile
                              let options = {'git': s:UserCommandList(), 'git_dir': s:GitDir(dir), 'flags': flags}
                              if empty(args) && pager is# -1
                                let cmd = s:StatusCommand(a:line1, a:line2, a:range, curwin ? 0 : a:line2, a:bang, a:mods, '', '', [], options)
                                return (empty(cmd) ? 'exe' : cmd) . after
                              endif
                              let alias = FugitiveConfigGet('alias.' . get(args, 0, ''), config)
                              if get(args, 1, '') !=# '--help' && alias !~# '^$\|^!\|[\"'']' && !filereadable(FugitiveVimPath(s:ExecPath() . '/git-' . args[0]))
                                    \ && !(has('win32') && filereadable(FugitiveVimPath(s:ExecPath() . '/git-' . args[0] . '.exe')))
                                call remove(args, 0)
                                call extend(args, split(alias, '\s\+'), 'keep')
                              endif
                              let name = substitute(get(args, 0, ''), '\%(^\|-\)\(\l\)', '\u\1', 'g')
                              if pager is# -1 && name =~# '^\a\+$' && exists('*s:' . name . 'Subcommand') && get(args, 1, '') !=# '--help'
                                try
                                  let overrides = s:{name}Subcommand(a:line1, curwin && a:line2 < 0 ? 0 : a:line2, a:range, a:bang, a:mods, extend({'subcommand': args[0], 'subcommand_args': args[1:-1]}, options))
                                  if type(overrides) == type('')
                                    return 'exe ' . string(overrides) . after
                                  endif
                                  let args = [get(overrides, 'command', args[0])] + get(overrides, 'insert_args', []) + args[1:-1]
                                catch /^fugitive:/
                                  return 'echoerr ' . string(v:exception)
                                endtry
                              else
                                let overrides = {}
                              endif
                              call extend(env, get(overrides, 'env', {}))
                              call s:PrepareEnv(env, dir)
                              if pager is# -1
                                let pager = fugitive#PagerFor(args, config)
                              endif
                              let wants_terminal = type(pager) ==# type('') ||
                                    \ (s:HasOpt(args, ['add', 'checkout', 'commit', 'reset', 'restore', 'stage', 'stash'], '-p', '--patch') ||
                                    \ s:HasOpt(args, ['add', 'clean', 'stage'], '-i', '--interactive')) && pager is# 0
                              if wants_terminal
                                let mods = substitute(s:Mods(a:mods), '\<tab\>', '-tab', 'g')
                                let assign = len(dir) ? '|let b:git_dir = ' . string(options.git_dir) : ''
                                let argv = s:UserCommandList(options) + args
                                let term_opts = len(env) ? {'env': env} : {}
                                if has('nvim')
                                  call fugitive#Autowrite()
                                  return mods . (curwin ? 'enew' : 'new') . '|call termopen(' . string(argv) . ', ' . string(term_opts) . ')' . assign . '|startinsert' . after
                                elseif exists('*term_start')
                                  call fugitive#Autowrite()
                                  if curwin
                                    let term_opts.curwin = 1
                                  endif
                                  return mods . 'call term_start(' . string(argv) . ', ' . string(term_opts) . ')' . assign . after
                                endif
                              endif
                              let state = {
                                    \ 'git': options.git,
                                    \ 'flags': flags,
                                    \ 'args': args,
                                    \ 'dir': options.git_dir,
                                    \ 'git_dir': options.git_dir,
                                    \ 'cwd': s:UserCommandCwd(dir),
                                    \ 'filetype': 'git',
                                    \ 'mods': s:Mods(a:mods),
                                    \ 'file': s:Resolve(tempname())}
                              let allow_pty = 1
                              let after_edit = ''
                              let stream = 0
                              if a:bang && pager isnot# 2
                                let pager = 1
                                let stream = exists('*setbufline')
                                let do_edit = substitute(s:Mods(a:mods, &splitbelow ? 'botright' : 'topleft'), '\<tab\>', '-tab', 'g') . 'pedit!'
                              elseif pager
                                let allow_pty = 0
                                if pager is# 2 && a:bang && a:line2 >= 0
                                  let [do_edit, after_edit] = s:ReadPrepare(a:line1, a:line2, a:range, a:mods)
                                elseif pager is# 2 && a:bang
                                  let do_edit = s:Mods(a:mods) . 'pedit'
                                elseif !curwin
                                  let do_edit = s:Mods(a:mods) . 'split'
                                else
                                  let do_edit = s:Mods(a:mods) . 'edit'
                                  call s:BlurStatus()
                                endif
                                call extend(env, {'COLUMNS': '' . get(g:, 'fugitive_columns', 80)}, 'keep')
                              endif
                              if s:run_jobs
                                call extend(env, {'COLUMNS': '' . (&columns - 1)}, 'keep')
                                let state.pty = allow_pty && get(g:, 'fugitive_pty', has('unix') && !has('win32unix') && (has('patch-8.0.0744') || has('nvim')) && fugitive#GitVersion() !~# '\.windows\>')
                                if !state.pty
                                  let args = s:AskPassArgs(dir) + args
                                endif
                                let tmp = {
                                      \ 'no_more': no_pager || get(overrides, 'no_more'),
                                      \ 'line_count': 0,
                                      \ 'err': '',
                                      \ 'out': '',
                                      \ 'escape': ''}
                                let env.FUGITIVE = state.file
                                let editor = 'sh ' . s:TempScript(
                                      \ '[ -f "$FUGITIVE.exit" ] && cat "$FUGITIVE.exit" >&2 && exit 1',
                                      \ 'echo "$1" > "$FUGITIVE.edit"',
                                      \ 'printf "\033]51;fugitive:edit\007" >&2',
                                      \ 'while [ -f "$FUGITIVE.edit" -a ! -f "$FUGITIVE.exit" ]; do sleep 0.05 2>/dev/null || sleep 1; done',
                                      \ 'exit 0')
                                call extend(env, {
                                      \ 'NO_COLOR': '1',
                                      \ 'GIT_EDITOR': editor,
                                      \ 'GIT_SEQUENCE_EDITOR': editor,
                                      \ 'GIT_PAGER': 'cat',
                                      \ 'PAGER': 'cat'}, 'keep')
                                if stream
                                  call writefile(['fugitive: aborting edit due to background operation.'], state.file . '.exit')
                                elseif pager
                                  call writefile(['fugitive: aborting edit due to use of pager.'], state.file . '.exit')
                                  let after = '|' . do_edit . ' ' . s:fnameescape(state.file) . after_edit . after
                                else
                                  let env.GIT_MERGE_AUTOEDIT = '1'
                                  let tmp.echo = ''
                                endif
                                let args = s:disable_colors + flags + ['-c', 'advice.waitingForEditor=false'] + args
                                let argv = s:UserCommandList({'git': options.git, 'git_dir': options.git_dir}) + args
                                let [argv, jobopts] = s:JobOpts(argv, env)
                                call fugitive#Autowrite()
                                call writefile([], state.file, 'b')
                                call s:RunSave(state)
                                if has_key(tmp, 'echo')
                                  echo ""
                                endif
                                if exists('*job_start')
                                  call extend(jobopts, {
                                        \ 'mode': 'raw',
                                        \ 'out_cb': function('s:RunReceive', [state, tmp, 'out']),
                                        \ 'err_cb': function('s:RunReceive', [state, tmp, 'err']),
                                        \ 'close_cb': function('s:RunClose', [state, tmp]),
                                        \ 'exit_cb': function('s:RunExit', [state, tmp]),
                                        \ })
                                  if state.pty
                                    let jobopts.pty = 1
                                  endif
                                  let job = job_start(argv, jobopts)
                                else
                                  let job = jobstart(argv, extend(jobopts, {
                                        \ 'pty': state.pty,
                                        \ 'TERM': 'dumb',
                                        \ 'on_stdout': function('s:RunReceive', [state, tmp, 'out']),
                                        \ 'on_stderr': function('s:RunReceive', [state, tmp, 'err']),
                                        \ 'on_exit': function('s:RunClose', [state, tmp]),
                                        \ }))
                                endif
                                let state.job = job
                                if pager
                                  let tmp.closed_in = 1
                                  call s:RunCloseIn(job)
                                endif
                                if stream
                                  exe 'silent' do_edit '++ff=unix' s:fnameescape(state.file)
                                  let state.capture_bufnr = bufnr(state.file)
                                  call setbufvar(state.capture_bufnr, '&modified', 1)
                                  return (after_edit . after)[1:-1]
                                endif
                                call add(s:resume_queue, [state, tmp, job])
                                return 'call fugitive#Resume()|silent checktime' . after
                              elseif pager
                                let pre = s:BuildEnvPrefix(env)
                                try
                                  if exists('+guioptions') && &guioptions =~# '!'
                                    let guioptions = &guioptions
                                    set guioptions-=!
                                  endif
                                  silent! execute '!' . escape(pre . s:shellesc(s:UserCommandList(options) + s:disable_colors + flags + ['--no-pager'] + args), '!#%') .
                                        \ (&shell =~# 'csh' ? ' >& ' . s:shellesc(state.file) : ' > ' . s:shellesc(state.file) . ' 2>&1')
                                  let state.exit_status = v:shell_error
                                finally
                                  if exists('guioptions')
                                    let &guioptions = guioptions
                                  endif
                                endtry
                                redraw!
                                call s:RunSave(state)
                                call s:RunFinished(state)
                                return do_edit . ' ' . s:fnameescape(state.file) . after_edit .
                                      \ '|call fugitive#ReloadStatus(fugitive#Result(' . string(state.file) . '), 1)' . after
                              elseif has('win32')
                                return 'echoerr ' . string('fugitive: Vim 8 with job support required to use :Git on Windows')
                              elseif has('gui_running')
                                return 'echoerr ' . string('fugitive: Vim 8 with job support required to use :Git in GVim')
                              else
                                if !explicit_pathspec_option && get(options.flags, 0, '') ==# '--no-literal-pathspecs'
                                  call remove(options.flags, 0)
                                endif
                                let cmd = s:BuildEnvPrefix(env) . s:shellesc(s:UserCommandList(options) + args)
                                let after = '|call fugitive#ReloadStatus(' . string(dir) . ', 1)' . after
                                if !wants_terminal && (no_pager || index(['add', 'clean', 'reset', 'restore', 'stage'], get(args, 0, '')) >= 0 || s:HasOpt(args, ['checkout'], '-q', '--quiet', '--no-progress'))
                                  let output = substitute(s:SystemError(cmd)[0], "\n$", '', '')
                                  if len(output)
                                    try
                                      if &more && no_pager
                                        let more = 1
                                        set nomore
                                      endif
                                      echo substitute(output, "\n$", "", "")
                                    finally
                                      if exists('l:more')
                                        set more
                                      endif
                                    endtry
                                  endif
                                  return 'silent checktime' . after
                                else
                                  return 'exe ' . string('noautocmd !' . escape(cmd, '!#%')) . after
                                endif
                              endif
                            endfunction
                            
    1              0.000002 let s:exec_paths = {}
    1              0.000001 function! s:ExecPath() abort
                              let git = s:GitShellCmd()
                              if !has_key(s:exec_paths, git)
                                let s:exec_paths[git] = get(s:JobExecute(s:GitCmd() + ['--exec-path'], {}, [], {}).stdout, 0, '')
                              endif
                              return s:exec_paths[git]
                            endfunction
                            
    1              0.000011 let s:subcommands_before_2_5 = [
                                  \ 'add', 'am', 'apply', 'archive', 'bisect', 'blame', 'branch', 'bundle',
                                  \ 'checkout', 'cherry', 'cherry-pick', 'citool', 'clean', 'clone', 'commit', 'config',
                                  \ 'describe', 'diff', 'difftool', 'fetch', 'format-patch', 'fsck',
                                  \ 'gc', 'grep', 'gui', 'help', 'init', 'instaweb', 'log',
                                  \ 'merge', 'mergetool', 'mv', 'notes', 'pull', 'push',
                                  \ 'rebase', 'reflog', 'remote', 'repack', 'replace', 'request-pull', 'reset', 'revert', 'rm',
                                  \ 'send-email', 'shortlog', 'show', 'show-branch', 'stash', 'stage', 'status', 'submodule',
                                  \ 'tag', 'whatchanged',
                                  \ ]
    1              0.000001 let s:path_subcommands = {}
    1              0.000001 function! s:CompletableSubcommands(dir) abort
                              let c_exec_path = s:cpath(s:ExecPath())
                              if !has_key(s:path_subcommands, c_exec_path)
                                if fugitive#GitVersion(2, 18)
                                  let [lines, exec_error] = s:LinesError([a:dir, '--list-cmds=list-mainporcelain,nohelpers,list-complete'])
                                  call filter(lines, 'v:val =~# "^\\S\\+$"')
                                  if !exec_error && len(lines)
                                    let s:path_subcommands[c_exec_path] = lines
                                  else
                                    let s:path_subcommands[c_exec_path] = s:subcommands_before_2_5 +
                                          \ ['maintenance', 'prune', 'range-diff', 'restore', 'sparse-checkout', 'switch', 'worktree']
                                  endif
                                else
                                  let s:path_subcommands[c_exec_path] = s:subcommands_before_2_5 +
                                        \ (fugitive#GitVersion(2, 5) ? ['worktree'] : [])
                                endif
                              endif
                              let commands = copy(s:path_subcommands[c_exec_path])
                              for path in split($PATH, has('win32') ? ';' : ':')
                                if path !~# '^/\|^\a:[\\/]'
                                  continue
                                endif
                                let cpath = s:cpath(path)
                                if !has_key(s:path_subcommands, cpath)
                                  let s:path_subcommands[cpath] = filter(map(s:GlobComplete(path.'/git-', '*', 1),'substitute(v:val,"\\.exe$","","")'), 'v:val !~# "--\\|/"')
                                endif
                                call extend(commands, s:path_subcommands[cpath])
                              endfor
                              call extend(commands, keys(fugitive#ConfigGetRegexp('^alias\.\zs[^.]\+$', a:dir)))
                              let configured = split(FugitiveConfigGet('completion.commands', a:dir), '\s\+')
                              let rejected = {}
                              for command in configured
                                if command =~# '^-.'
                                  let rejected[strpart(command, 1)] = 1
                                endif
                              endfor
                              call filter(configured, 'v:val !~# "^-"')
                              let results = filter(sort(commands + configured), '!has_key(rejected, v:val)')
                              if exists('*uniq')
                                return uniq(results)
                              else
                                let i = 1
                                while i < len(results)
                                  if results[i] ==# results[i-1]
                                    call remove(results, i)
                                  else
                                    let i += 1
                                  endif
                                endwhile
                                return results
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#Complete(lead, ...) abort
                              let dir = a:0 == 1 ? a:1 : a:0 >= 3 ? s:Dir(a:3) : s:Dir()
                              let root = a:0 >= 4 ? a:4 : s:Tree(s:Dir())
                              let pre = a:0 > 1 ? strpart(a:1, 0, a:2) : ''
                              let subcmd = matchstr(pre, '\u\w*[! ] *\zs[[:alnum:]-]\+\ze ')
                              if empty(subcmd)
                                let results = s:CompletableSubcommands(dir)
                              elseif a:0 ==# 2 && subcmd =~# '^\%(commit\|revert\|push\|fetch\|pull\|merge\|rebase\)$'
                                let cmdline = substitute(a:1, '\u\w*\([! ] *\)' . subcmd, 'G' . subcmd, '')
                                let caps_subcmd = substitute(subcmd, '\%(^\|-\)\l', '\u&', 'g')
                                return fugitive#{caps_subcmd}Complete(a:lead, cmdline, a:2 + len(cmdline) - len(a:1), dir, root)
                              elseif pre =~# ' -- '
                                return fugitive#CompletePath(a:lead, a:1, a:2, dir, root)
                              elseif a:lead =~# '^-'
                                let results = split(s:ChompDefault('', [dir, subcmd, '--git-completion-helper']), ' ')
                              else
                                return fugitive#CompleteObject(a:lead, a:1, a:2, dir, root)
                              endif
                              return filter(results, 'strpart(v:val, 0, strlen(a:lead)) ==# a:lead')
                            endfunction
                            
    1              0.000002 function! fugitive#CompleteForWorkingDir(A, L, P, ...) abort
                              let path = a:0 ? a:1 : getcwd()
                              return fugitive#Complete(a:A, a:L, a:P, FugitiveExtractGitDir(path), path)
                            endfunction
                            
                            " Section: :Gcd, :Glcd
                            
    1              0.000001 function! fugitive#CdComplete(A, L, P) abort
                              return filter(fugitive#CompletePath(a:A), 'v:val =~# "/$"')
                            endfunction
                            
    1              0.000001 function! fugitive#Cd(path, ...) abort
                              let path = substitute(a:path, '^:/:\=\|^:(\%(top\|top,literal\|literal,top\|literal\))', '', '')
                              if path !~# '^/\|^\a\+:\|^\.\.\=\%(/\|$\)'
                                let dir = s:Dir()
                                exe s:DirCheck(dir)
                                let path = (empty(s:Tree(dir)) ? dir : s:Tree(dir)) . '/' . path
                              endif
                              return (a:0 && a:1 ? 'lcd ' : 'cd ') . s:fnameescape(FugitiveVimPath(path))
                            endfunction
                            
                            " Section: :Gstatus
                            
    1              0.000002 function! s:StatusCommand(line1, line2, range, count, bang, mods, reg, arg, args, ...) abort
                              let dir = a:0 ? s:Dir(a:1) : s:Dir()
                              exe s:DirCheck(dir)
                              try
                                let mods = s:Mods(a:mods, &splitbelow ? 'botright' : 'topleft')
                                let file = fugitive#Find(':', dir)
                                let arg = ' +setl\ foldmarker=<<<<<<<<,>>>>>>>>\|let\ w:fugitive_status=FugitiveGitDir() ' .
                                      \ s:fnameescape(file)
                                for tabnr in [tabpagenr()] + (mods =~# '\<tab\>' ? range(1, tabpagenr('$')) : [])
                                  let bufs = tabpagebuflist(tabnr)
                                  for winnr in range(1, tabpagewinnr(tabnr, '$'))
                                    if s:cpath(file, fnamemodify(bufname(bufs[winnr-1]), ':p'))
                                      if tabnr == tabpagenr() && winnr == winnr()
                                        call s:ReloadStatus()
                                      else
                                        call s:ExpireStatus(dir)
                                        exe tabnr . 'tabnext'
                                        exe winnr . 'wincmd w'
                                      endif
                                      let w:fugitive_status = dir
                                      1
                                      return ''
                                    endif
                                  endfor
                                endfor
                                if a:count ==# 0
                                  return mods . 'edit' . (a:bang ? '!' : '') . arg
                                elseif a:bang
                                  return mods . 'pedit' . arg . '|wincmd P'
                                else
                                  return mods . 'keepalt split' . arg
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              return ''
                            endfunction
                            
    1              0.000001 function! s:StageJump(offset, section, ...) abort
                              let line = search('^\%(' . a:section . '\)', 'nw')
                              if !line && a:0
                                let line = search('^\%(' . a:1 . '\)', 'nw')
                              endif
                              if line
                                exe line
                                if a:offset
                                  for i in range(a:offset)
                                    call search(s:file_commit_pattern . '\|^$', 'W')
                                    if empty(getline('.')) && a:0 && getline(line('.') + 1) =~# '^\%(' . a:1 . '\)'
                                      call search(s:file_commit_pattern . '\|^$', 'W')
                                    endif
                                    if empty(getline('.'))
                                      return ''
                                    endif
                                  endfor
                                  call s:StageReveal()
                                else
                                  call s:StageReveal()
                                  +
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! s:StageSeek(info, fallback) abort
                              let info = a:info
                              if empty(info.heading)
                                return a:fallback
                              endif
                              let line = search('^' . escape(info.heading, '^$.*[]~\') . ' (\d\+)$', 'wn')
                              if !line
                                for section in get({'Staged': ['Unstaged', 'Untracked'], 'Unstaged': ['Untracked', 'Staged'], 'Untracked': ['Unstaged', 'Staged']}, info.section, [])
                                  let line = search('^' . section, 'wn')
                                  if line
                                    return line + (info.index > 0 ? 1 : 0)
                                  endif
                                endfor
                                return 1
                              endif
                              let i = 0
                              while len(getline(line))
                                let filename = matchstr(getline(line), '^[A-Z?] \zs.*')
                                if len(filename) &&
                                      \ ((info.filename[-1:-1] ==# '/' && filename[0 : len(info.filename) - 1] ==# info.filename) ||
                                      \ (filename[-1:-1] ==# '/' && filename ==# info.filename[0 : len(filename) - 1]) ||
                                      \ filename ==# info.filename)
                                  if info.offset < 0
                                    return line
                                  else
                                    if getline(line+1) !~# '^@'
                                      exe s:StageInline('show', line)
                                    endif
                                    if getline(line+1) !~# '^@'
                                      return line
                                    endif
                                    let type = info.sigil ==# '-' ? '-' : '+'
                                    let offset = -1
                                    while offset < info.offset
                                      let line += 1
                                      if getline(line) =~# '^@'
                                        let offset = +matchstr(getline(line), type . '\zs\d\+') - 1
                                      elseif getline(line) =~# '^[ ' . type . ']'
                                        let offset += 1
                                      elseif getline(line) !~# '^[ @\+-]'
                                        return line - 1
                                      endif
                                    endwhile
                                    return line
                                  endif
                                endif
                                let commit = matchstr(getline(line), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\+')
                                if len(commit) && commit ==# info.commit
                                  return line
                                endif
                                if i ==# info.index
                                  let backup = line
                                endif
                                let i += getline(line) !~# '^[ @\+-]'
                                let line += 1
                              endwhile
                              return exists('backup') ? backup : line - 1
                            endfunction
                            
    1              0.000001 function! s:DoAutocmdChanged(dir) abort
                              let dir = a:dir is# -2 ? '' : FugitiveGitDir(a:dir)
                              if empty(dir) || !exists('#User#FugitiveChanged') || exists('g:fugitive_event')
                                return ''
                              endif
                              try
                                let g:fugitive_event = dir
                                if type(a:dir) == type({}) && has_key(a:dir, 'args')
                                  let g:fugitive_result = a:dir
                                endif
                                exe s:DoAutocmd('User FugitiveChanged')
                              finally
                                unlet! g:fugitive_event g:fugitive_result
                                " Force statusline reload with the buffer's Git dir
                                let &ro = &ro
                              endtry
                              return ''
                            endfunction
                            
    1              0.000001 function! s:ReloadStatusBuffer(...) abort
                              if get(b:, 'fugitive_type', '') !=# 'index'
                                return ''
                              endif
                              let original_lnum = a:0 ? a:1 : line('.')
                              let info = s:StageInfo(original_lnum)
                              call fugitive#BufReadStatus()
                              call setpos('.', [0, s:StageSeek(info, original_lnum), 1, 0])
                              return ''
                            endfunction
                            
    1              0.000001 function! s:ReloadStatus(...) abort
                              call s:ExpireStatus(-1)
                              call s:ReloadStatusBuffer(a:0 ? a:1 : line('.'))
                              exe s:DoAutocmdChanged(-1)
                              return ''
                            endfunction
                            
    1              0.000003 let s:last_time = reltime()
    1              0.000002 if !exists('s:last_times')
    1              0.000001   let s:last_times = {}
    1              0.000001 endif
                            
    1              0.000001 function! s:ExpireStatus(bufnr) abort
                              if a:bufnr is# -2 || a:bufnr is# 0
                                let s:head_cache = {}
                                let s:last_time = reltime()
                                return ''
                              endif
                              let dir = s:Dir(a:bufnr)
                              if len(dir)
                                let s:last_times[s:cpath(dir)] = reltime()
                                if has_key(s:head_cache, dir)
                                  call remove(s:head_cache, dir)
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! s:ReloadWinStatus(...) abort
                              if get(b:, 'fugitive_type', '') !=# 'index' || &modified
                                return
                              endif
                              if !exists('b:fugitive_reltime')
                                exe s:ReloadStatusBuffer()
                                return
                              endif
                              let t = b:fugitive_reltime
                              if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' ||
                                    \ reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatusBuffer()
                              endif
                            endfunction
                            
    1              0.000001 function! s:ReloadTabStatus(...) abort
                              let mytab = tabpagenr()
                              let tab = a:0 ? a:1 : mytab
                              let winnr = 1
                              while winnr <= tabpagewinnr(tab, '$')
                                if getbufvar(tabpagebuflist(tab)[winnr-1], 'fugitive_type') ==# 'index'
                                  execute 'tabnext '.tab
                                  if winnr != winnr()
                                    execute winnr.'wincmd w'
                                    let restorewinnr = 1
                                  endif
                                  try
                                    call s:ReloadWinStatus()
                                  finally
                                    if exists('restorewinnr')
                                      unlet restorewinnr
                                      wincmd p
                                    endif
                                    execute 'tabnext '.mytab
                                  endtry
                                endif
                                let winnr += 1
                              endwhile
                              unlet! t:fugitive_reload_status
                            endfunction
                            
    1              0.000001 function! fugitive#ReloadStatus(...) abort
                              call s:ExpireStatus(a:0 ? a:1 : -1)
                              if a:0 > 1 ? a:2 : 1
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
                              else
                                call s:ReloadWinStatus()
                                return ''
                              endif
                              exe s:DoAutocmdChanged(a:0 ? a:1 : -1)
                              return ''
                            endfunction
                            
    1              0.000001 function! fugitive#EfmDir(...) abort
                              let dir = matchstr(a:0 ? a:1 : &errorformat, '\c,%\\&\%(git\|fugitive\)_\=dir=\zs\%(\\.\|[^,]\)*')
                              let dir = substitute(dir, '%%', '%', 'g')
                              let dir = substitute(dir, '\\\ze[\,]', '', 'g')
                              return dir
                            endfunction
                            
    1              0.000001 augroup fugitive_status
    1              0.000047   autocmd!
    1              0.000006   autocmd BufWritePost         * call fugitive#ReloadStatus(-1, 0)
    1              0.000005   autocmd ShellCmdPost,ShellFilterPost * nested call fugitive#ReloadStatus(-2, 0)
    1              0.000004   autocmd BufDelete * nested
                                    \ if getbufvar(+expand('<abuf>'), 'buftype') ==# 'terminal' |
                                    \   if !empty(FugitiveGitDir(+expand('<abuf>'))) |
                                    \     call fugitive#ReloadStatus(+expand('<abuf>'), 1) |
                                    \   else |
                                    \     call fugitive#ReloadStatus(-2, 0) |
                                    \  endif |
                                    \ endif
    1              0.000008   autocmd QuickFixCmdPost make,lmake,[cl]file,[cl]getfile nested
                                    \ call fugitive#ReloadStatus(fugitive#EfmDir(), 1)
    1              0.000003   if !has('win32')
    1              0.000003     autocmd FocusGained        * call fugitive#ReloadStatus(-2, 0)
    1              0.000001   endif
    1              0.000004   autocmd BufEnter index,index.lock
                                    \ call s:ReloadWinStatus()
    1              0.000003   autocmd TabEnter *
                                    \ if exists('t:fugitive_reload_status') |
                                    \    call s:ReloadTabStatus() |
                                    \ endif
    1              0.000001 augroup END
                            
    1              0.000001 function! s:StageInfo(...) abort
                              let lnum = a:0 ? a:1 : line('.')
                              let sigil = matchstr(getline(lnum), '^[ @\+-]')
                              let offset = -1
                              if len(sigil)
                                let type = sigil ==# '-' ? '-' : '+'
                                while lnum > 0 && getline(lnum) !~# '^@'
                                  if getline(lnum) =~# '^[ '.type.']'
                                    let offset += 1
                                  endif
                                  let lnum -= 1
                                endwhile
                                let offset += matchstr(getline(lnum), type.'\zs\d\+')
                                while getline(lnum) =~# '^[ @\+-]'
                                  let lnum -= 1
                                endwhile
                              endif
                              let slnum = lnum + 1
                              let heading = ''
                              let index = 0
                              while len(getline(slnum - 1)) && empty(heading)
                                let slnum -= 1
                                let heading = matchstr(getline(slnum), '^\u\l\+.\{-\}\ze (\d\+)$')
                                if empty(heading) && getline(slnum) !~# '^[ @\+-]'
                                  let index += 1
                                endif
                              endwhile
                              let text = matchstr(getline(lnum), '^[A-Z?] \zs.*')
                              let file = get(get(b:fugitive_files, heading, {}), text, {})
                              let relative = get(file, 'relative', len(text) ? [text] : [])
                              return {'section': matchstr(heading, '^\u\l\+'),
                                    \ 'heading': heading,
                                    \ 'sigil': sigil,
                                    \ 'offset': offset,
                                    \ 'filename': text,
                                    \ 'relative': copy(relative),
                                    \ 'paths': map(copy(relative), 's:Tree() . "/" . v:val'),
                                    \ 'commit': matchstr(getline(lnum), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\{4,\}\ze '),
                                    \ 'status': matchstr(getline(lnum), '^[A-Z?]\ze \|^\%(\x\x\x\)\@!\l\+\ze [0-9a-f]'),
                                    \ 'submodule': get(file, 'submodule', ''),
                                    \ 'index': index}
                            endfunction
                            
    1              0.000001 function! s:Selection(arg1, ...) abort
                              if a:arg1 ==# 'n'
                                let arg1 = line('.')
                                let arg2 = -v:count
                              elseif a:arg1 ==# 'v'
                                let arg1 = line("'<")
                                let arg2 = line("'>")
                              else
                                let arg1 = a:arg1
                                let arg2 = a:0 ? a:1 : 0
                              endif
                              let first = arg1
                              if arg2 < 0
                                let last = first - arg2 - 1
                              elseif arg2 > 0
                                let last = arg2
                              else
                                let last = first
                              endif
                              while getline(first) =~# '^$\|^[A-Z][a-z]'
                                let first += 1
                              endwhile
                              if first > last || &filetype !=# 'fugitive'
                                return []
                              endif
                              let flnum = first
                              while getline(flnum) =~# '^[ @\+-]'
                                let flnum -= 1
                              endwhile
                              let slnum = flnum + 1
                              let heading = ''
                              let index = 0
                              while empty(heading)
                                let slnum -= 1
                                let heading = matchstr(getline(slnum), '^\u\l\+.\{-\}\ze (\d\+)$')
                                if empty(heading) && getline(slnum) !~# '^[ @\+-]'
                                  let index += 1
                                endif
                              endwhile
                              let results = []
                              let template = {
                                    \ 'heading': heading,
                                    \ 'section': matchstr(heading, '^\u\l\+'),
                                    \ 'filename': '',
                                    \ 'relative': [],
                                    \ 'paths': [],
                                    \ 'commit': '',
                                    \ 'status': '',
                                    \ 'patch': 0,
                                    \ 'index': index}
                              let line = getline(flnum)
                              let lnum = first - (arg1 == flnum ? 0 : 1)
                              let root = s:Tree() . '/'
                              while lnum <= last
                                let heading = matchstr(line, '^\u\l\+\ze.\{-\}\ze (\d\+)$')
                                if len(heading)
                                  let template.heading = heading
                                  let template.section = matchstr(heading, '^\u\l\+')
                                  let template.index = 0
                                elseif line =~# '^[ @\+-]'
                                  let template.index -= 1
                                  if !results[-1].patch
                                    let results[-1].patch = lnum
                                  endif
                                  let results[-1].lnum = lnum
                                elseif line =~# '^[A-Z?] '
                                  let text = matchstr(line, '^[A-Z?] \zs.*')
                                  let file = get(get(b:fugitive_files, template.heading, {}), text, {})
                                  let relative = get(file, 'relative', len(text) ? [text] : [])
                                  call add(results, extend(deepcopy(template), {
                                        \ 'lnum': lnum,
                                        \ 'filename': text,
                                        \ 'relative': copy(relative),
                                        \ 'paths': map(copy(relative), 'root . v:val'),
                                        \ 'status': matchstr(line, '^[A-Z?]'),
                                        \ }))
                                elseif line =~# '^\x\x\x\+ '
                                  call add(results, extend({
                                        \ 'lnum': lnum,
                                        \ 'commit': matchstr(line, '^\x\x\x\+'),
                                        \ }, template, 'keep'))
                                elseif line =~# '^\l\+ \x\x\x\+ '
                                  call add(results, extend({
                                        \ 'lnum': lnum,
                                        \ 'commit': matchstr(line, '^\l\+ \zs\x\x\x\+'),
                                        \ 'status': matchstr(line, '^\l\+'),
                                        \ }, template, 'keep'))
                                endif
                                let lnum += 1
                                let template.index += 1
                                let line = getline(lnum)
                              endwhile
                              if len(results) && results[0].patch && arg2 == 0
                                while getline(results[0].patch) =~# '^[ \+-]'
                                  let results[0].patch -= 1
                                endwhile
                                while getline(results[0].lnum + 1) =~# '^[ \+-]'
                                  let results[0].lnum += 1
                                endwhile
                              endif
                              return results
                            endfunction
                            
    1              0.000001 function! s:StageArgs(visual) abort
                              let commits = []
                              let paths = []
                              for record in s:Selection(a:visual ? 'v' : 'n')
                                if len(record.commit)
                                  call add(commits, record.commit)
                                endif
                                call extend(paths, record.paths)
                              endfor
                              if s:cpath(s:Tree(), getcwd())
                                call map(paths, 'fugitive#Path(v:val, "./")')
                              endif
                              return join(map(commits + paths, 's:fnameescape(v:val)'), ' ')
                            endfunction
                            
    1              0.000001 function! s:Do(action, visual) abort
                              let line = getline('.')
                              let reload = 0
                              if !a:visual && !v:count && line =~# '^[A-Z][a-z]'
                                let header = matchstr(line, '^\S\+\ze:')
                                if len(header) && exists('*s:Do' . a:action . header . 'Header')
                                  let reload = s:Do{a:action}{header}Header(matchstr(line, ': \zs.*')) > 0
                                else
                                  let section = matchstr(line, '^\S\+')
                                  if exists('*s:Do' . a:action . section . 'Heading')
                                    let reload = s:Do{a:action}{section}Heading(line) > 0
                                  endif
                                endif
                                return reload ? s:ReloadStatus() : ''
                              endif
                              let selection = s:Selection(a:visual ? 'v' : 'n')
                              if empty(selection)
                                return ''
                              endif
                              call filter(selection, 'v:val.section ==# selection[0].section')
                              let status = 0
                              let err = ''
                              try
                                for record in selection
                                  if exists('*s:Do' . a:action . record.section)
                                    let status = s:Do{a:action}{record.section}(record)
                                  else
                                    continue
                                  endif
                                  if !status
                                    return ''
                                  endif
                                  let reload = reload || (status > 0)
                                endfor
                                if status < 0
                                  execute record.lnum + 1
                                endif
                                let success = 1
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              finally
                                if reload
                                  execute s:ReloadStatus()
                                endif
                                if exists('success')
                                  call s:StageReveal()
                                endif
                              endtry
                              return ''
                            endfunction
                            
    1              0.000001 function! s:StageReveal() abort
                              exe 'normal! zv'
                              let begin = line('.')
                              if getline(begin) =~# '^@'
                                let end = begin + 1
                                while getline(end) =~# '^[ \+-]'
                                  let end += 1
                                endwhile
                              elseif getline(begin) =~# '^commit '
                                let end = begin
                                while end < line('$') && getline(end + 1) !~# '^commit '
                                  let end += 1
                                endwhile
                              elseif getline(begin) =~# s:section_pattern
                                let end = begin
                                while len(getline(end + 1))
                                  let end += 1
                                endwhile
                              endif
                              if exists('end')
                                while line('.') > line('w0') + &scrolloff && end > line('w$')
                                  execute "normal! \<C-E>"
                                endwhile
                              endif
                            endfunction
                            
    1              0.000001 let s:file_pattern = '^[A-Z?] .\|^diff --'
    1              0.000002 let s:file_commit_pattern = s:file_pattern . '\|^\%(\l\{3,\} \)\=[0-9a-f]\{4,\} '
    1              0.000002 let s:item_pattern = s:file_commit_pattern . '\|^@@'
                            
    1              0.000001 function! s:NextHunk(count) abort
                              if &filetype ==# 'fugitive' && getline('.') =~# s:file_pattern
                                exe s:StageInline('show')
                              endif
                              for i in range(a:count)
                                if &filetype ==# 'fugitive'
                                  call search(s:file_pattern . '\|^@', 'W')
                                  if getline('.') =~# s:file_pattern
                                    exe s:StageInline('show')
                                    if getline(line('.') + 1) =~# '^@'
                                      +
                                    endif
                                  endif
                                else
                                  call search('^@@', 'W')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000001 function! s:PreviousHunk(count) abort
                              for i in range(a:count)
                                if &filetype ==# 'fugitive'
                                  let lnum = search(s:file_pattern . '\|^@','Wbn')
                                  call s:StageInline('show', lnum)
                                  call search('^? .\|^@','Wb')
                                else
                                  call search('^@@', 'Wb')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000001 function! s:NextFile(count) abort
                              for i in range(a:count)
                                exe s:StageInline('hide')
                                if !search(s:file_pattern, 'W')
                                  break
                                endif
                              endfor
                              exe s:StageInline('hide')
                              return '.'
                            endfunction
                            
    1              0.000001 function! s:PreviousFile(count) abort
                              exe s:StageInline('hide')
                              for i in range(a:count)
                                if !search(s:file_pattern, 'Wb')
                                  break
                                endif
                                exe s:StageInline('hide')
                              endfor
                              return '.'
                            endfunction
                            
    1              0.000001 function! s:NextItem(count) abort
                              for i in range(a:count)
                                if !search(s:item_pattern, 'W') && getline('.') !~# s:item_pattern
                                  call search('^commit ', 'W')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000001 function! s:PreviousItem(count) abort
                              for i in range(a:count)
                                if !search(s:item_pattern, 'Wbe') && getline('.') !~# s:item_pattern
                                  call search('^commit ', 'Wbe')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000001 let s:section_pattern = '^[A-Z][a-z][^:]*$'
    1              0.000002 let s:section_commit_pattern = s:section_pattern . '\|^commit '
                            
    1              0.000001 function! s:NextSection(count) abort
                              let orig = line('.')
                              if getline('.') !~# '^commit '
                                -
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern, 'W')
                                  break
                                endif
                              endfor
                              if getline('.') =~# s:section_commit_pattern
                                call s:StageReveal()
                                return getline('.') =~# s:section_pattern ? '+' : ':'
                              else
                                return orig
                              endif
                            endfunction
                            
    1              0.000001 function! s:PreviousSection(count) abort
                              let orig = line('.')
                              if getline('.') !~# '^commit '
                                -
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern . '\|\%^', 'bW')
                                  break
                                endif
                              endfor
                              if getline('.') =~# s:section_commit_pattern || line('.') == 1
                                call s:StageReveal()
                                return getline('.') =~# s:section_pattern ? '+' : ':'
                              else
                                return orig
                              endif
                            endfunction
                            
    1              0.000001 function! s:NextSectionEnd(count) abort
                              +
                              if empty(getline('.'))
                                +
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern, 'W')
                                  return '$'
                                endif
                              endfor
                              return search('^.', 'Wb')
                            endfunction
                            
    1              0.000001 function! s:PreviousSectionEnd(count) abort
                              let old = line('.')
                              for i in range(a:count)
                                if search(s:section_commit_pattern, 'Wb') <= 1
                                  exe old
                                  if i
                                    break
                                  else
                                    return ''
                                  endif
                                endif
                                let old = line('.')
                              endfor
                              return search('^.', 'Wb')
                            endfunction
                            
    1              0.000001 function! s:PatchSearchExpr(reverse) abort
                              let line = getline('.')
                              if col('.') ==# 1 && line =~# '^[+-]'
                                if line =~# '^[+-]\{3\} '
                                  let pattern = '^[+-]\{3\} ' . substitute(escape(strpart(line, 4), '^$.*[]~\'), '^\w/', '\\w/', '') . '$'
                                else
                                  let pattern = '^[+-]\s*' . escape(substitute(strpart(line, 1), '^\s*\|\s*$', '', ''), '^$.*[]~\') . '\s*$'
                                endif
                                if a:reverse
                                  return '?' . escape(pattern, '/?') . "\<CR>"
                                else
                                  return '/' . escape(pattern, '/') . "\<CR>"
                                endif
                              endif
                              return a:reverse ? '#' : '*'
                            endfunction
                            
    1              0.000001 function! s:StageInline(mode, ...) abort
                              if &filetype !=# 'fugitive'
                                return ''
                              endif
                              let lnum1 = a:0 ? a:1 : line('.')
                              let lnum = lnum1 + 1
                              if a:0 > 1 && a:2 == 0 && lnum1 == 1
                                let lnum = line('$') - 1
                              elseif a:0 > 1 && a:2 == 0
                                let info = s:StageInfo(lnum - 1)
                                if empty(info.paths) && len(info.section)
                                  while len(getline(lnum))
                                    let lnum += 1
                                  endwhile
                                endif
                              elseif a:0 > 1
                                let lnum += a:2 - 1
                              endif
                              while lnum > lnum1
                                let lnum -= 1
                                while lnum > 0 && getline(lnum) =~# '^[ @\+-]'
                                  let lnum -= 1
                                endwhile
                                let info = s:StageInfo(lnum)
                                if !has_key(b:fugitive_diff, info.section)
                                  continue
                                endif
                                if getline(lnum + 1) =~# '^[ @\+-]'
                                  let lnum2 = lnum + 1
                                  while getline(lnum2 + 1) =~# '^[ @\+-]'
                                    let lnum2 += 1
                                  endwhile
                                  if a:mode !=# 'show'
                                    setlocal modifiable noreadonly
                                    exe 'silent keepjumps ' . (lnum + 1) . ',' . lnum2 . 'delete _'
                                    call remove(b:fugitive_expanded[info.section], info.filename)
                                    setlocal nomodifiable readonly nomodified
                                  endif
                                  continue
                                endif
                                if !has_key(b:fugitive_diff, info.section) || info.status !~# '^[ADMRU]$' || a:mode ==# 'hide'
                                  continue
                                endif
                                let mode = ''
                                let diff = []
                                let index = 0
                                let start = -1
                                for line in b:fugitive_diff[info.section]
                                  if mode ==# 'await' && line[0] ==# '@'
                                    let mode = 'capture'
                                  endif
                                  if mode !=# 'head' && line !~# '^[ @\+-]'
                                    if len(diff)
                                      break
                                    endif
                                    let start = index
                                    let mode = 'head'
                                  elseif mode ==# 'head' && line =~# '^diff '
                                    let start = index
                                  elseif mode ==# 'head' && substitute(line, "\t$", '', '') ==# '--- ' . info.relative[-1]
                                    let mode = 'await'
                                  elseif mode ==# 'head' && substitute(line, "\t$", '', '') ==# '+++ ' . info.relative[0]
                                    let mode = 'await'
                                  elseif mode ==# 'capture'
                                    call add(diff, line)
                                  elseif line[0] ==# '@'
                                    let mode = ''
                                  endif
                                  let index += 1
                                endfor
                                if len(diff)
                                  setlocal modifiable noreadonly
                                  silent call append(lnum, diff)
                                  let b:fugitive_expanded[info.section][info.filename] = [start, len(diff)]
                                  setlocal nomodifiable readonly nomodified
                                  if foldclosed(lnum+1) > 0
                                    silent exe (lnum+1) . ',' . (lnum+len(diff)) . 'foldopen!'
                                  endif
                                endif
                              endwhile
                              return lnum
                            endfunction
                            
    1              0.000001 function! s:NextExpandedHunk(count) abort
                              for i in range(a:count)
                                call s:StageInline('show', line('.'), 1)
                                call search(s:file_pattern . '\|^@','W')
                              endfor
                              return '.'
                            endfunction
                            
    1              0.000001 function! s:StageDiff(diff) abort
                              let lnum = line('.')
                              let info = s:StageInfo(lnum)
                              let prefix = info.offset > 0 ? '+' . info.offset : ''
                              if info.submodule =~# '^S'
                                if info.section ==# 'Staged'
                                  return 'Git --paginate diff --no-ext-diff --submodule=log --cached -- ' . info.paths[0]
                                elseif info.submodule =~# '^SC'
                                  return 'Git --paginate diff --no-ext-diff --submodule=log -- ' . info.paths[0]
                                else
                                  return 'Git --paginate diff --no-ext-diff --submodule=diff -- ' . info.paths[0]
                                endif
                              elseif empty(info.paths) && info.section ==# 'Staged'
                                return 'Git --paginate diff --no-ext-diff --cached'
                              elseif empty(info.paths)
                                return 'Git --paginate diff --no-ext-diff'
                              elseif len(info.paths) > 1
                                execute 'Gedit' . prefix s:fnameescape(':0:' . info.paths[0])
                                return a:diff . '! @:'.s:fnameescape(info.paths[1])
                              elseif info.section ==# 'Staged' && info.sigil ==# '-'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! :0:%'
                              elseif info.section ==# 'Staged'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! @:%'
                              elseif info.sigil ==# '-'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! :(top)%'
                              else
                                execute 'Gedit' prefix s:fnameescape(':(top)'.info.paths[0])
                                return a:diff . '!'
                              endif
                            endfunction
                            
    1              0.000001 function! s:StageDiffEdit() abort
                              let info = s:StageInfo(line('.'))
                              let arg = (empty(info.paths) ? s:Tree() : info.paths[0])
                              if info.section ==# 'Staged'
                                return 'Git --paginate diff --no-ext-diff --cached '.s:fnameescape(arg)
                              elseif info.status ==# '?'
                                call s:TreeChomp('add', '--intent-to-add', '--', arg)
                                return s:ReloadStatus()
                              else
                                return 'Git --paginate diff --no-ext-diff '.s:fnameescape(arg)
                              endif
                            endfunction
                            
    1              0.000001 function! s:StageApply(info, reverse, extra) abort
                              if a:info.status ==# 'R'
                                throw 'fugitive: patching renamed file not yet supported'
                              endif
                              let cmd = ['apply', '-p0', '--recount'] + a:extra
                              let info = a:info
                              let start = info.patch
                              let end = info.lnum
                              let lines = getline(start, end)
                              if empty(filter(copy(lines), 'v:val =~# "^[+-]"'))
                                return -1
                              endif
                              while getline(end) =~# '^[-+\ ]'
                                let end += 1
                                if getline(end) =~# '^[' . (a:reverse ? '+' : '-') . '\ ]'
                                  call add(lines, ' ' . getline(end)[1:-1])
                                endif
                              endwhile
                              while start > 0 && getline(start) !~# '^@'
                                let start -= 1
                                if getline(start) =~# '^[' . (a:reverse ? '+' : '-') . ' ]'
                                  call insert(lines, ' ' . getline(start)[1:-1])
                                elseif getline(start) =~# '^@'
                                  call insert(lines, getline(start))
                                endif
                              endwhile
                              if start == 0
                                throw 'fugitive: could not find hunk'
                              elseif getline(start) !~# '^@@ '
                                throw 'fugitive: cannot apply conflict hunk'
                              endif
                              let i = b:fugitive_expanded[info.section][info.filename][0]
                              let head = []
                              while get(b:fugitive_diff[info.section], i, '@') !~# '^@'
                                let line = b:fugitive_diff[info.section][i]
                                if line ==# '--- /dev/null'
                                  call add(head, '--- ' . get(b:fugitive_diff[info.section], i + 1, '')[4:-1])
                                elseif line !~# '^new file '
                                  call add(head, line)
                                endif
                                let i += 1
                              endwhile
                              call extend(lines, head, 'keep')
                              let temp = tempname()
                              call writefile(lines, temp)
                              if a:reverse
                                call add(cmd, '--reverse')
                              endif
                              call extend(cmd, ['--', temp])
                              let output = s:ChompStderr(cmd)
                              if empty(output)
                                return 1
                              endif
                              call s:throw(output)
                            endfunction
                            
    1              0.000001 function! s:StageDelete(lnum1, lnum2, count) abort
                              let restore = []
                            
                              let err = ''
                              let did_conflict_err = 0
                              try
                                for info in s:Selection(a:lnum1, a:lnum2)
                                  if empty(info.paths)
                                    continue
                                  endif
                                  let sub = get(get(get(b:fugitive_files, info.section, {}), info.filename, {}), 'submodule')
                                  if sub =~# '^S' && info.status ==# 'M'
                                    let undo = 'Git checkout ' . fugitive#RevParse('HEAD', FugitiveExtractGitDir(info.paths[0]))[0:10] . ' --'
                                  elseif sub =~# '^S'
                                    let err .= '|echoerr ' . string('fugitive: will not touch submodule ' . string(info.relative[0]))
                                    break
                                  elseif info.status ==# 'D'
                                    let undo = 'GRemove'
                                  elseif info.paths[0] =~# '/$'
                                    let err .= '|echoerr ' . string('fugitive: will not delete directory ' . string(info.relative[0]))
                                    break
                                  else
                                    let undo = 'Gread ' . s:TreeChomp('hash-object', '-w', '--', info.paths[0])[0:10]
                                  endif
                                  if info.patch
                                    call s:StageApply(info, 1, info.section ==# 'Staged' ? ['--index'] : [])
                                  elseif sub =~# '^S'
                                    if info.section ==# 'Staged'
                                      call s:TreeChomp('reset', '--', info.paths[0])
                                    endif
                                    call s:TreeChomp('submodule', 'update', '--', info.paths[0])
                                  elseif info.status ==# '?'
                                    call s:TreeChomp('clean', '-f', '--', info.paths[0])
                                  elseif a:count == 2
                                    if get(b:fugitive_files['Staged'], info.filename, {'status': ''}).status ==# 'D'
                                      call delete(FugitiveVimPath(info.paths[0]))
                                    else
                                      call s:TreeChomp('checkout', '--ours', '--', info.paths[0])
                                    endif
                                  elseif a:count == 3
                                    if get(b:fugitive_files['Unstaged'], info.filename, {'status': ''}).status ==# 'D'
                                      call delete(FugitiveVimPath(info.paths[0]))
                                    else
                                      call s:TreeChomp('checkout', '--theirs', '--', info.paths[0])
                                    endif
                                  elseif info.status =~# '[ADU]' &&
                                        \ get(b:fugitive_files[info.section ==# 'Staged' ? 'Unstaged' : 'Staged'], info.filename, {'status': ''}).status =~# '[AU]'
                                    if get(g:, 'fugitive_conflict_x', 0)
                                      call s:TreeChomp('checkout', info.section ==# 'Unstaged' ? '--ours' : '--theirs', '--', info.paths[0])
                                    else
                                      if !did_conflict_err
                                        let err .= '|echoerr "Use 2X for --ours or 3X for --theirs"'
                                        let did_conflict_err = 1
                                      endif
                                      continue
                                    endif
                                  elseif info.status ==# 'U'
                                    call delete(FugitiveVimPath(info.paths[0]))
                                  elseif info.status ==# 'A'
                                    call s:TreeChomp('rm', '-f', '--', info.paths[0])
                                  elseif info.section ==# 'Unstaged'
                                    call s:TreeChomp('checkout', '--', info.paths[0])
                                  else
                                    call s:TreeChomp('checkout', '@', '--', info.paths[0])
                                  endif
                                  if len(undo)
                                    call add(restore, ':Gsplit ' . s:fnameescape(info.relative[0]) . '|' . undo)
                                  endif
                                endfor
                              catch /^fugitive:/
                                let err .= '|echoerr ' . string(v:exception)
                              endtry
                              if empty(restore)
                                return err[1:-1]
                              endif
                              exe s:ReloadStatus()
                              call s:StageReveal()
                              if len(restore)
                                return 'checktime|redraw|echomsg ' . string('To restore, ' . join(restore, '|')) . err
                              else
                                return 'checktime|redraw' . err
                              endif
                            endfunction
                            
    1              0.000001 function! s:StageIgnore(lnum1, lnum2, count) abort
                              let paths = []
                              for info in s:Selection(a:lnum1, a:lnum2)
                                call extend(paths, info.relative)
                              endfor
                              call map(paths, '"/" . v:val')
                              if !a:0
                                let dir = fugitive#Find('.git/info/')
                                if !isdirectory(dir)
                                  try
                                    call mkdir(dir)
                                  catch
                                  endtry
                                endif
                              endif
                              exe 'Gsplit' (a:count ? '.gitignore' : '.git/info/exclude')
                              let last = line('$')
                              if last == 1 && empty(getline(1))
                                call setline(last, paths)
                              else
                                call append(last, paths)
                                exe last + 1
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! s:DoToggleHeadHeader(value) abort
                              exe 'edit' s:fnameescape(s:Dir())
                              call search('\C^index$', 'wc')
                            endfunction
                            
    1              0.000001 function! s:DoToggleHelpHeader(value) abort
                              exe 'help fugitive-map'
                            endfunction
                            
    1              0.000001 function! s:DoStagePushHeader(value) abort
                              let remote = matchstr(a:value, '\zs[^/]\+\ze/')
                              if empty(remote)
                                let remote = '.'
                              endif
                              let branch = matchstr(a:value, '\%([^/]\+/\)\=\zs\S\+')
                              call feedkeys(':Git push ' . remote . ' ' . branch)
                            endfunction
                            
    1              0.000001 function! s:DoTogglePushHeader(value) abort
                              return s:DoStagePushHeader(a:value)
                            endfunction
                            
    1              0.000001 function! s:DoStageUnpushedHeading(heading) abort
                              let remote = matchstr(a:heading, 'to \zs[^/]\+\ze/')
                              if empty(remote)
                                let remote = '.'
                              endif
                              let branch = matchstr(a:heading, 'to \%([^/]\+/\)\=\zs\S\+')
                              call feedkeys(':Git push ' . remote . ' ' . '@:' . 'refs/heads/' . branch)
                            endfunction
                            
    1              0.000001 function! s:DoToggleUnpushedHeading(heading) abort
                              return s:DoStageUnpushedHeading(a:heading)
                            endfunction
                            
    1              0.000001 function! s:DoStageUnpushed(record) abort
                              let remote = matchstr(a:record.heading, 'to \zs[^/]\+\ze/')
                              if empty(remote)
                                let remote = '.'
                              endif
                              let branch = matchstr(a:record.heading, 'to \%([^/]\+/\)\=\zs\S\+')
                              call feedkeys(':Git push ' . remote . ' ' . a:record.commit . ':' . 'refs/heads/' . branch)
                            endfunction
                            
    1              0.000001 function! s:DoToggleUnpushed(record) abort
                              return s:DoStageUnpushed(a:record)
                            endfunction
                            
    1              0.000001 function! s:DoUnstageUnpulledHeading(heading) abort
                              call feedkeys(':Git rebase')
                            endfunction
                            
    1              0.000001 function! s:DoToggleUnpulledHeading(heading) abort
                              call s:DoUnstageUnpulledHeading(a:heading)
                            endfunction
                            
    1              0.000001 function! s:DoUnstageUnpulled(record) abort
                              call feedkeys(':Git rebase ' . a:record.commit)
                            endfunction
                            
    1              0.000001 function! s:DoToggleUnpulled(record) abort
                              call s:DoUnstageUnpulled(a:record)
                            endfunction
                            
    1              0.000001 function! s:DoUnstageUnpushed(record) abort
                              call feedkeys(':Git -c sequence.editor=true rebase --interactive --autosquash ' . a:record.commit . '^')
                            endfunction
                            
    1              0.000001 function! s:DoToggleStagedHeading(...) abort
                              call s:TreeChomp('reset', '-q')
                              return 1
                            endfunction
                            
    1              0.000001 function! s:DoUnstageStagedHeading(heading) abort
                              return s:DoToggleStagedHeading(a:heading)
                            endfunction
                            
    1              0.000001 function! s:DoToggleUnstagedHeading(...) abort
                              call s:TreeChomp('add', '-u')
                              return 1
                            endfunction
                            
    1              0.000001 function! s:DoStageUnstagedHeading(heading) abort
                              return s:DoToggleUnstagedHeading(a:heading)
                            endfunction
                            
    1              0.000001 function! s:DoToggleUntrackedHeading(...) abort
                              call s:TreeChomp('add', '.')
                              return 1
                            endfunction
                            
    1              0.000001 function! s:DoStageUntrackedHeading(heading) abort
                              return s:DoToggleUntrackedHeading(a:heading)
                            endfunction
                            
    1              0.000001 function! s:DoToggleStaged(record) abort
                              if a:record.patch
                                return s:StageApply(a:record, 1, ['--cached'])
                              else
                                call s:TreeChomp(['reset', '-q', '--'] + a:record.paths)
                                return 1
                              endif
                            endfunction
                            
    1              0.000001 function! s:DoUnstageStaged(record) abort
                              return s:DoToggleStaged(a:record)
                            endfunction
                            
    1              0.000001 function! s:DoToggleUnstaged(record) abort
                              if a:record.patch
                                return s:StageApply(a:record, 0, ['--cached'])
                              else
                                call s:TreeChomp(['add', '-A', '--'] + a:record.paths)
                                return 1
                              endif
                            endfunction
                            
    1              0.000001 function! s:DoStageUnstaged(record) abort
                              return s:DoToggleUnstaged(a:record)
                            endfunction
                            
    1              0.000001 function! s:DoUnstageUnstaged(record) abort
                              if a:record.status ==# 'A'
                                call s:TreeChomp(['reset', '-q', '--'] + a:record.paths)
                                return 1
                              else
                                return -1
                              endif
                            endfunction
                            
    1              0.000001 function! s:DoToggleUntracked(record) abort
                              call s:TreeChomp(['add', '--'] + a:record.paths)
                              return 1
                            endfunction
                            
    1              0.000001 function! s:DoStageUntracked(record) abort
                              return s:DoToggleUntracked(a:record)
                            endfunction
                            
    1              0.000001 function! s:StagePatch(lnum1,lnum2) abort
                              let add = []
                              let reset = []
                              let intend = []
                            
                              for lnum in range(a:lnum1,a:lnum2)
                                let info = s:StageInfo(lnum)
                                if empty(info.paths) && info.section ==# 'Staged'
                                  return 'Git reset --patch'
                                elseif empty(info.paths) && info.section ==# 'Unstaged'
                                  return 'Git add --patch'
                                elseif empty(info.paths) && info.section ==# 'Untracked'
                                  return 'Git add --interactive'
                                elseif empty(info.paths)
                                  continue
                                endif
                                execute lnum
                                if info.section ==# 'Staged'
                                  let reset += info.relative
                                elseif info.section ==# 'Untracked'
                                  let intend += info.paths
                                elseif info.status !~# '^D'
                                  let add += info.relative
                                endif
                              endfor
                              try
                                if !empty(intend)
                                  call s:TreeChomp(['add', '--intent-to-add', '--'] + intend)
                                endif
                                if !empty(add)
                                  execute "Git add --patch -- ".join(map(add,'s:fnameescape(v:val)'))
                                endif
                                if !empty(reset)
                                  execute "Git reset --patch -- ".join(map(reset,'s:fnameescape(v:val)'))
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              return s:ReloadStatus()
                            endfunction
                            
                            " Section: :Git commit, :Git revert
                            
    1              0.000002 function! s:CommitInteractive(line1, line2, range, bang, mods, options, patch) abort
                              let status = s:StatusCommand(a:line1, a:line2, a:range, a:line2, a:bang, a:mods, '', '', [], a:options)
                              let status = len(status) ? status . '|' : ''
                              if a:patch
                                return status . 'if search("^Unstaged")|exe "normal >"|exe "+"|endif'
                              else
                                return status . 'if search("^Untracked\\|^Unstaged")|exe "+"|endif'
                              endif
                            endfunction
                            
    1              0.000002 function! s:CommitSubcommand(line1, line2, range, bang, mods, options) abort
                              let argv = copy(a:options.subcommand_args)
                              let i = 0
                              while get(argv, i, '--') !=# '--'
                                if argv[i] =~# '^-[apzsneiovq].'
                                  call insert(argv, argv[i][0:1])
                                  let argv[i+1] = '-' . argv[i+1][2:-1]
                                else
                                  let i += 1
                                endif
                              endwhile
                              if s:HasOpt(argv, '-i', '--interactive')
                                return s:CommitInteractive(a:line1, a:line2, a:range, a:bang, a:mods, a:options, 0)
                              elseif s:HasOpt(argv, '-p', '--patch')
                                return s:CommitInteractive(a:line1, a:line2, a:range, a:bang, a:mods, a:options, 1)
                              else
                                return {}
                              endif
                            endfunction
                            
    1              0.000001 function! s:RevertSubcommand(line1, line2, range, bang, mods, options) abort
                              return {'insert_args': ['--edit']}
                            endfunction
                            
    1              0.000001 function! fugitive#CommitComplete(A, L, P, ...) abort
                              let dir = a:0 ? a:1 : s:Dir()
                              if a:A =~# '^--fixup=\|^--squash='
                                let commits = s:LinesError([dir, 'log', '--pretty=format:%s', '@{upstream}..'])[0]
                                let pre = matchstr(a:A, '^--\w*=''\=') . ':/^'
                                if pre =~# "'"
                                  call map(commits, 'pre . string(tr(v:val, "|\"^$*[]", "......."))[1:-1]')
                                  call filter(commits, 'strpart(v:val, 0, strlen(a:A)) ==# a:A')
                                  return commits
                                else
                                  return s:FilterEscape(map(commits, 'pre . tr(v:val, "\\ !^$*?[]()''\"`&;<>|#", "....................")'), a:A)
                                endif
                              else
                                return s:CompleteSub('commit', a:A, a:L, a:P, function('fugitive#CompletePath'), a:000)
                              endif
                              return []
                            endfunction
                            
    1              0.000001 function! fugitive#RevertComplete(A, L, P, ...) abort
                              return s:CompleteSub('revert', a:A, a:L, a:P, function('s:CompleteRevision'), a:000)
                            endfunction
                            
                            " Section: :Git merge, :Git rebase, :Git pull
                            
    1              0.000002 function! fugitive#MergeComplete(A, L, P, ...) abort
                              return s:CompleteSub('merge', a:A, a:L, a:P, function('s:CompleteRevision'), a:000)
                            endfunction
                            
    1              0.000001 function! fugitive#RebaseComplete(A, L, P, ...) abort
                              return s:CompleteSub('rebase', a:A, a:L, a:P, function('s:CompleteRevision'), a:000)
                            endfunction
                            
    1              0.000001 function! fugitive#PullComplete(A, L, P, ...) abort
                              return s:CompleteSub('pull', a:A, a:L, a:P, function('s:CompleteRemote'), a:000)
                            endfunction
                            
    1              0.000001 function! s:MergeSubcommand(line1, line2, range, bang, mods, options) abort
                              if empty(a:options.subcommand_args) && (
                                    \ filereadable(fugitive#Find('.git/MERGE_MSG', a:options)) ||
                                    \ isdirectory(fugitive#Find('.git/rebase-apply', a:options)) ||
                                    \  !empty(s:TreeChomp([a:options.git_dir, 'diff-files', '--diff-filter=U'])))
                                return 'echoerr ":Git merge for loading conflicts hase been removed in favor of :Git mergetool"'
                              endif
                              return {}
                            endfunction
                            
    1              0.000001 function! s:RebaseSubcommand(line1, line2, range, bang, mods, options) abort
                              let args = a:options.subcommand_args
                              if s:HasOpt(args, '--autosquash') && !s:HasOpt(args, '-i', '--interactive')
                                return {'env': {'GIT_SEQUENCE_EDITOR': 'true'}, 'insert_args': ['--interactive']}
                              endif
                              return {}
                            endfunction
                            
                            " Section: :Git difftool, :Git mergetool
                            
    1              0.000001 function! s:ToolItems(state, from, to, offsets, text, ...) abort
                              let items = []
                              for i in range(len(a:state.diff))
                                let diff = a:state.diff[i]
                                let path = (i == len(a:state.diff) - 1) ? a:to : a:from
                                if empty(path)
                                  return []
                                endif
                                let item = {
                                      \ 'valid': a:0 ? a:1 : 1,
                                      \ 'filename': diff.filename . FugitiveVimPath(path),
                                      \ 'lnum': matchstr(get(a:offsets, i), '\d\+'),
                                      \ 'text': a:text}
                                if len(get(diff, 'module', ''))
                                  let item.module = diff.module . path
                                endif
                                call add(items, item)
                              endfor
                              let diff = items[0:-2]
                              let items[-1].context = {'diff': items[0:-2]}
                              return [items[-1]]
                            endfunction
                            
    1              0.000001 function! s:ToolToFrom(str) abort
                              if a:str =~# ' => '
                                let str = a:str =~# '{.* => .*}' ? a:str : '{' . a:str . '}'
                                return [substitute(str, '{.* => \(.*\)}', '\1', ''),
                                      \ substitute(str, '{\(.*\) => .*}', '\1', '')]
                              else
                                return [a:str, a:str]
                              endif
                            endfunction
                            
    1              0.000001 function! s:ToolParse(state, line) abort
                              if type(a:line) !=# type('') || a:state.mode ==# 'hunk' && a:line =~# '^[ +-]'
                                return []
                              elseif a:line =~# '^diff '
                                let a:state.mode = 'diffhead'
                                let a:state.from = ''
                                let a:state.to = ''
                              elseif a:state.mode ==# 'diffhead' && a:line =~# '^--- [^/]'
                                let a:state.from = a:line[4:-1]
                                let a:state.to = a:state.from
                              elseif a:state.mode ==# 'diffhead' && a:line =~# '^+++ [^/]'
                                let a:state.to = a:line[4:-1]
                                if empty(get(a:state, 'from', ''))
                                  let a:state.from = a:state.to
                                endif
                              elseif a:line[0] ==# '@'
                                let a:state.mode = 'hunk'
                                if has_key(a:state, 'from')
                                  let offsets = split(matchstr(a:line, '^@\+ \zs[-+0-9, ]\+\ze @'), ' ')
                                  return s:ToolItems(a:state, a:state.from, a:state.to, offsets, matchstr(a:line, ' @@\+ \zs.*'))
                                endif
                              elseif a:line =~# '^\* Unmerged path .'
                                let file = a:line[16:-1]
                                return s:ToolItems(a:state, file, file, [], '')
                              elseif a:line =~# '^[A-Z]\d*\t.\|^:.*\t.'
                                " --raw, --name-status
                                let [status; files] = split(a:line, "\t")
                                return s:ToolItems(a:state, files[0], files[-1], [], a:state.name_only ? '' : status)
                              elseif a:line =~# '^ \S.* |'
                                " --stat
                                let [_, to, changes; __] = matchlist(a:line, '^ \(.\{-\}\) \+|\zs \(.*\)$')
                                let [to, from] = s:ToolToFrom(to)
                                return s:ToolItems(a:state, from, to, [], changes)
                              elseif a:line =~# '^ *\([0-9.]\+%\) .'
                                " --dirstat
                                let [_, changes, to; __] = matchlist(a:line, '^ *\([0-9.]\+%\) \(.*\)')
                                return s:ToolItems(a:state, to, to, [], changes)
                              elseif a:line =~# '^\(\d\+\|-\)\t\(\d\+\|-\)\t.'
                                " --numstat
                                let [_, add, remove, to; __] = matchlist(a:line, '^\(\d\+\|-\)\t\(\d\+\|-\)\t\(.*\)')
                                let [to, from] = s:ToolToFrom(to)
                                return s:ToolItems(a:state, from, to, [], add ==# '-' ? 'Binary file' : '+' . add . ' -' . remove, add !=# '-')
                              elseif a:state.mode !=# 'diffhead' && a:state.mode !=# 'hunk' && len(a:line) || a:line =~# '^git: \|^usage: \|^error: \|^fatal: '
                                return [{'text': a:line}]
                              endif
                              return []
                            endfunction
                            
    1              0.000002 function! s:ToolStream(line1, line2, range, bang, mods, options, args, state) abort
                              let i = 0
                              let argv = copy(a:args)
                              let prompt = 1
                              let state = a:state
                              while i < len(argv)
                                let match = matchlist(argv[i], '^\(-[a-zABDFH-KN-RT-Z]\)\ze\(.*\)')
                                if len(match) && len(match[2])
                                  call insert(argv, match[1])
                                  let argv[i+1] = '-' . match[2]
                                  continue
                                endif
                                let arg = argv[i]
                                if arg =~# '^-t$\|^--tool=\|^--tool-help$\|^--help$'
                                  return {}
                                elseif arg =~# '^-y$\|^--no-prompt$'
                                  let prompt = 0
                                  call remove(argv, i)
                                  continue
                                elseif arg ==# '--prompt'
                                  let prompt = 1
                                  call remove(argv, i)
                                  continue
                                elseif arg =~# '^--\%(no-\)\=\(symlinks\|trust-exit-code\|gui\)$'
                                  call remove(argv, i)
                                  continue
                                elseif arg ==# '--'
                                  break
                                endif
                                let i += 1
                              endwhile
                              let a:state.mode = 'init'
                              let a:state.from = ''
                              let a:state.to = ''
                              let exec = s:UserCommandList({'git': a:options.git, 'git_dir': a:options.git_dir}) + ['-c', 'diff.context=0']
                              let exec += a:options.flags + ['--no-pager', 'diff', '--no-ext-diff', '--no-color', '--no-prefix'] + argv
                              if prompt
                                let title = ':Git ' . s:fnameescape(a:options.flags + [a:options.subcommand] + a:options.subcommand_args)
                                return s:QuickfixStream(a:line2, 'difftool', title, exec, !a:bang, a:mods, s:function('s:ToolParse'), a:state)
                              else
                                let filename = ''
                                let cmd = []
                                let tabnr = tabpagenr() + 1
                                for line in s:SystemList(exec)[0]
                                  for item in s:ToolParse(a:state, line)
                                    if len(get(item, 'filename', '')) && item.filename != filename
                                      call add(cmd, 'tabedit ' . s:fnameescape(item.filename))
                                      for i in reverse(range(len(get(item.context, 'diff', []))))
                                        call add(cmd, (i ? 'rightbelow' : 'leftabove') . ' vertical Gdiffsplit! ' . s:fnameescape(item.context.diff[i].filename))
                                      endfor
                                      call add(cmd, 'wincmd =')
                                      let filename = item.filename
                                    endif
                                  endfor
                                endfor
                                return join(cmd, '|') . (empty(cmd) ? '' : '|' . tabnr . 'tabnext')
                              endif
                            endfunction
                            
    1              0.000002 function! s:MergetoolSubcommand(line1, line2, range, bang, mods, options) abort
                              let dir = a:options.git_dir
                              exe s:DirCheck(dir)
                              let i = 0
                              let prompt = 1
                              let cmd = ['diff', '--diff-filter=U']
                              let state = {'name_only': 0}
                              let state.diff = [{'prefix': ':2:', 'module': ':2:'}, {'prefix': ':3:', 'module': ':3:'}, {'prefix': ':(top)'}]
                              call map(state.diff, 'extend(v:val, {"filename": fugitive#Find(v:val.prefix, dir)})')
                              return s:ToolStream(a:line1, a:line2, a:range, a:bang, a:mods, a:options, ['--diff-filter=U'] + a:options.subcommand_args, state)
                            endfunction
                            
    1              0.000001 function! s:DifftoolSubcommand(line1, line2, range, bang, mods, options) abort
                              let dir = s:Dir(a:options)
                              exe s:DirCheck(dir)
                              let i = 0
                              let argv = copy(a:options.subcommand_args)
                              let commits = []
                              let cached = 0
                              let reverse = 1
                              let prompt = 1
                              let state = {'name_only': 0}
                              let merge_base_against = {}
                              let dash = (index(argv, '--') > i ? ['--'] : [])
                              while i < len(argv)
                                let match = matchlist(argv[i], '^\(-[a-zABDFH-KN-RT-Z]\)\ze\(.*\)')
                                if len(match) && len(match[2])
                                  call insert(argv, match[1])
                                  let argv[i+1] = '-' . match[2]
                                  continue
                                endif
                                let arg = argv[i]
                                if arg ==# '--cached'
                                  let cached = 1
                                elseif arg ==# '-R'
                                  let reverse = 1
                                elseif arg ==# '--name-only'
                                  let state.name_only = 1
                                  let argv[0] = '--name-status'
                                elseif arg ==# '--'
                                  break
                                elseif arg !~# '^-\|^\.\.\=\%(/\|$\)'
                                  let parsed = s:LinesError(['rev-parse', '--revs-only', substitute(arg, ':.*', '', '')] + dash)[0]
                                  call map(parsed, '{"uninteresting": v:val =~# "^\\^", "prefix": substitute(v:val, "^\\^", "", "") . ":"}')
                                  let merge_base_against = {}
                                  if arg =~# '\.\.\.' && len(parsed) > 2
                                    let display = map(split(arg, '\.\.\.', 1), 'empty(v:val) ? "@" : v:val')
                                    if len(display) == 2
                                      let parsed[0].module = display[1] . ':'
                                      let parsed[1].module = display[0] . ':'
                                    endif
                                    let parsed[2].module = arg . ':'
                                    if empty(commits)
                                      let merge_base_against = parsed[0]
                                      let parsed = [parsed[2]]
                                    endif
                                  elseif arg =~# '\.\.' && len(parsed) == 2
                                    let display = map(split(arg, '\.\.', 1), 'empty(v:val) ? "@" : v:val')
                                    if len(display) == 2
                                      let parsed[0].module = display[0] . ':'
                                      let parsed[1].module = display[1] . ':'
                                    endif
                                  elseif len(parsed) == 1
                                    let parsed[0].module = arg . ':'
                                  endif
                                  call extend(commits, parsed)
                                endif
                                let i += 1
                              endwhile
                              if len(merge_base_against)
                                call add(commits, merge_base_against)
                              endif
                              let commits = filter(copy(commits), 'v:val.uninteresting') + filter(commits, '!v:val.uninteresting')
                              if cached
                                if empty(commits)
                                  call add(commits, {'prefix': '@:', 'module': '@:'})
                                endif
                                call add(commits, {'prefix': ':0:', 'module': ':0:'})
                              elseif len(commits) < 2
                                call add(commits, {'prefix': ':(top)'})
                                if len(commits) < 2
                                  call insert(commits, {'prefix': ':0:', 'module': ':0:'})
                                endif
                              endif
                              if reverse
                                let commits = [commits[-1]] + repeat([commits[0]], len(commits) - 1)
                                call reverse(commits)
                              endif
                              if len(commits) > 2
                                call add(commits, remove(commits, 0))
                              endif
                              call map(commits, 'extend(v:val, {"filename": fugitive#Find(v:val.prefix, dir)})')
                              let state.diff = commits
                              return s:ToolStream(a:line1, a:line2, a:range, a:bang, a:mods, a:options, argv, state)
                            endfunction
                            
                            " Section: :Ggrep, :Glog
                            
    1              0.000002 if !exists('g:fugitive_summary_format')
    1              0.000002   let g:fugitive_summary_format = '%s'
    1              0.000001 endif
                            
    1              0.000001 function! fugitive#GrepComplete(A, L, P) abort
                              return s:CompleteSub('grep', a:A, a:L, a:P)
                            endfunction
                            
    1              0.000001 function! fugitive#LogComplete(A, L, P) abort
                              return s:CompleteSub('log', a:A, a:L, a:P)
                            endfunction
                            
    1              0.000001 function! s:GrepParseLine(options, quiet, dir, line) abort
                              if !a:quiet
                                echo a:line
                              endif
                              let entry = {'valid': 1}
                              let match = matchlist(a:line, '^\(.\{-\}\):\([1-9]\d*\):\([1-9]\d*:\)\=\(.*\)$')
                              if a:line =~# '^git: \|^usage: \|^error: \|^fatal: \|^BUG: '
                                return {'text': a:line}
                              elseif len(match)
                                let entry.module = match[1]
                                let entry.lnum = +match[2]
                                let entry.col = +match[3]
                                let entry.text = match[4]
                              else
                                let entry.module = matchstr(a:line, '\CBinary file \zs.*\ze matches$')
                                if len(entry.module)
                                  let entry.text = 'Binary file'
                                  let entry.valid = 0
                                endif
                              endif
                              if empty(entry.module) && !a:options.line_number
                                let match = matchlist(a:line, '^\(.\{-\}\):\(.*\)$')
                                if len(match)
                                  let entry.module = match[1]
                                  let entry.pattern = '\M^' . escape(match[2], '\.^$/') . '$'
                                endif
                              endif
                              if empty(entry.module) && a:options.name_count && a:line =~# ':\d\+$'
                                let entry.text = matchstr(a:line, '\d\+$')
                                let entry.module = strpart(a:line, 0, len(a:line) - len(entry.text) - 1)
                              endif
                              if empty(entry.module) && a:options.name_only
                                let entry.module = a:line
                              endif
                              if empty(entry.module)
                                return {'text': a:line}
                              endif
                              if entry.module !~# ':'
                                let entry.filename = a:options.prefix . entry.module
                              else
                                let entry.filename = fugitive#Find(entry.module, a:dir)
                              endif
                              return entry
                            endfunction
                            
    1              0.000001 let s:grep_combine_flags = '[aiIrhHEGPFnlLzocpWq]\{-\}'
    1              0.000001 function! s:GrepOptions(args, dir) abort
                              let options = {'name_only': 0, 'name_count': 0, 'line_number': 0}
                              let tree = s:Tree(a:dir)
                              let prefix = empty(tree) ? fugitive#Find(':0:', a:dir) :
                                    \ s:cpath(getcwd(), tree) ? '' : FugitiveVimPath(tree . '/')
                              let options.prefix = prefix
                              for arg in a:args
                                if arg ==# '--'
                                  break
                                endif
                                if arg =~# '^\%(-' . s:grep_combine_flags . 'c\|--count\)$'
                                  let options.name_count = 1
                                endif
                                if arg =~# '^\%(-' . s:grep_combine_flags . 'n\|--line-number\)$'
                                  let options.line_number = 1
                                elseif arg =~# '^\%(--no-line-number\)$'
                                  let options.line_number = 0
                                endif
                                if arg =~# '^\%(-' . s:grep_combine_flags . '[lL]\|--files-with-matches\|--name-only\|--files-without-match\)$'
                                  let options.name_only = 1
                                endif
                                if arg ==# '--cached'
                                  let options.prefix = fugitive#Find(':0:', a:dir)
                                elseif arg ==# '--no-cached'
                                  let options.prefix = prefix
                                endif
                              endfor
                              return options
                            endfunction
                            
    1              0.000001 function! s:GrepCfile(result) abort
                              let options = s:GrepOptions(a:result.args, a:result)
                              let entry = s:GrepParseLine(options, 1, a:result, getline('.'))
                              if get(entry, 'col')
                                return [entry.filename, entry.lnum, "norm!" . entry.col . "|"]
                              elseif has_key(entry, 'lnum')
                                return [entry.filename, entry.lnum]
                              elseif has_key(entry, 'pattern')
                                return [entry.filename, '', 'silent /' . entry.pattern]
                              elseif has_key(entry, 'filename')
                                return [entry.filename]
                              else
                                return []
                              endif
                            endfunction
                            
    1              0.000002 function! s:GrepSubcommand(line1, line2, range, bang, mods, options) abort
                              let args = copy(a:options.subcommand_args)
                              let handle = -1
                              let quiet = 0
                              let i = 0
                              while i < len(args) && args[i] !=# '--'
                                let partition = matchstr(args[i], '^-' . s:grep_combine_flags . '\ze[qzO]')
                                if len(partition) > 1
                                  call insert(args, '-' . strpart(args[i], len(partition)), i+1)
                                  let args[i] = partition
                                elseif args[i] =~# '^\%(-' . s:grep_combine_flags . '[eABC]\|--max-depth\|--context\|--after-context\|--before-context\|--threads\)$'
                                  let i += 1
                                elseif args[i] =~# '^\%(-O\|--open-files-in-pager\)$'
                                  let handle = 1
                                  call remove(args, i)
                                  continue
                                elseif args[i] =~# '^\%(-O\|--open-files-in-pager=\)'
                                  let handle = 0
                                elseif args[i] =~# '^-[qz].'
                                  let args[i] = '-' . args[i][2:-1]
                                  let quiet = 1
                                elseif args[i] =~# '^\%(-[qz]\|--quiet\)$'
                                  let quiet = 1
                                  call remove(args, i)
                                  continue
                                elseif args[i] =~# '^--no-quiet$'
                                  let quiet = 0
                                elseif args[i] =~# '^\%(--heading\)$'
                                  call remove(args, i)
                                  continue
                                endif
                                let i += 1
                              endwhile
                              if handle < 0 ? !quiet : !handle
                                return {}
                              endif
                              let listnr = a:line1 == 0 ? a:line1 : a:line2
                              if s:HasOpt(args, '--no-line-number')
                                let lc = []
                              else
                                let lc = fugitive#GitVersion(2, 19) ? ['-n', '--column'] : ['-n']
                              endif
                              let cmd = ['grep', '--no-color', '--full-name'] + lc
                              let dir = s:Dir(a:options)
                              let options = s:GrepOptions(lc + args, dir)
                              if listnr > 0
                                exe listnr 'wincmd w'
                              else
                                call s:BlurStatus()
                              endif
                              let title = (listnr < 0 ? ':Ggrep ' : ':Glgrep ') . s:fnameescape(args)
                              call s:QuickfixCreate(listnr, {'title': title})
                              let tempfile = tempname()
                              let state = {
                                    \ 'git': a:options.git,
                                    \ 'flags': a:options.flags,
                                    \ 'args': cmd + args,
                                    \ 'dir': s:GitDir(a:options),
                                    \ 'git_dir': s:GitDir(a:options),
                                    \ 'cwd': s:UserCommandCwd(a:options),
                                    \ 'filetype': 'git',
                                    \ 'mods': s:Mods(a:mods),
                                    \ 'file': s:Resolve(tempfile)}
                              let event = listnr < 0 ? 'grep-fugitive' : 'lgrep-fugitive'
                              silent exe s:DoAutocmd('QuickFixCmdPre ' . event)
                              try
                                if !quiet && &more
                                  let more = 1
                                  set nomore
                                endif
                                if !quiet
                                  echo title
                                endif
                                let list = s:SystemList(s:UserCommandList(a:options) + cmd + args)[0]
                                call writefile(list + [''], tempfile, 'b')
                                call s:RunSave(state)
                                call map(list, 's:GrepParseLine(options, ' . quiet . ', dir, v:val)')
                                call s:QuickfixSet(listnr, list, 'a')
                                let press_enter_shortfall = &cmdheight - len(list)
                                if press_enter_shortfall > 0 && !quiet
                                  echo repeat("\n", press_enter_shortfall - 1)
                                endif
                              finally
                                if exists('l:more')
                                  let &more = more
                                endif
                              endtry
                              call s:RunFinished(state)
                              silent exe s:DoAutocmd('QuickFixCmdPost ' . event)
                              if quiet
                                let bufnr = bufnr('')
                                silent exe substitute(s:Mods(a:mods), '\<tab\>', '', '') (listnr < 0 ? 'c' : 'l').'open'
                                if bufnr != bufnr('') && !a:bang
                                  wincmd p
                                endif
                              end
                              if !a:bang && !empty(list)
                                return 'silent ' . (listnr < 0 ? 'c' : 'l').'first'
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000002 function! fugitive#GrepCommand(line1, line2, range, bang, mods, arg) abort
                              return fugitive#Command(a:line1, a:line2, a:range, a:bang, a:mods,
                                    \ "grep -O " . a:arg)
                            endfunction
                            
    1              0.000002 let s:log_diff_context = '{"filename": fugitive#Find(v:val . from, a:dir), "lnum": get(offsets, v:key), "module": strpart(v:val, 0, len(a:state.base_module)) . from}'
                            
    1              0.000001 function! s:LogFlushQueue(state, dir) abort
                              let queue = remove(a:state, 'queue')
                              if a:state.child_found && get(a:state, 'ignore_commit')
                                call remove(queue, 0)
                              elseif len(queue) && len(a:state.target) && len(get(a:state, 'parents', []))
                                let from = substitute(a:state.target, '^/', ':', '')
                                let offsets = []
                                let queue[0].context.diff = map(copy(a:state.parents), s:log_diff_context)
                              endif
                              if len(queue) && queue[-1] ==# {'text': ''}
                                call remove(queue, -1)
                              endif
                              return queue
                            endfunction
                            
    1              0.000001 function! s:LogParse(state, dir, prefix, line) abort
                              if a:state.mode ==# 'hunk' && a:line =~# '^[-+ ]'
                                return []
                              endif
                              let list = matchlist(a:line, '^\%(fugitive \(.\{-\}\)\t\|commit \|From \)\=\(\x\{40,\}\)\%( \(.*\)\)\=$')
                              if len(list)
                                let queue = s:LogFlushQueue(a:state, a:dir)
                                let a:state.mode = 'commit'
                                let a:state.base = a:prefix . list[2]
                                if len(list[1])
                                  let [a:state.base_module; a:state.parents] = split(list[1], ' ')
                                else
                                  let a:state.base_module = list[2]
                                  let a:state.parents = []
                                endif
                                let a:state.message = list[3]
                                let a:state.from = ''
                                let a:state.to = ''
                                let context = {}
                                let a:state.queue = [{
                                      \ 'valid': 1,
                                      \ 'context': context,
                                      \ 'filename': a:state.base . a:state.target,
                                      \ 'module': a:state.base_module . substitute(a:state.target, '^/', ':', ''),
                                      \ 'text': a:state.message}]
                                let a:state.child_found = 0
                                return queue
                              elseif type(a:line) == type(0)
                                return s:LogFlushQueue(a:state, a:dir)
                              elseif a:line =~# '^diff'
                                let a:state.mode = 'diffhead'
                                let a:state.from = ''
                                let a:state.to = ''
                              elseif a:state.mode ==# 'diffhead' && a:line =~# '^--- \w/'
                                let a:state.from = a:line[6:-1]
                                let a:state.to = a:state.from
                              elseif a:state.mode ==# 'diffhead' && a:line =~# '^+++ \w/'
                                let a:state.to = a:line[6:-1]
                                if empty(get(a:state, 'from', ''))
                                  let a:state.from = a:state.to
                                endif
                              elseif a:line =~# '^@@[^@]*+\d' && len(get(a:state, 'to', '')) && has_key(a:state, 'base')
                                let a:state.mode = 'hunk'
                                if empty(a:state.target) || a:state.target ==# '/' . a:state.to
                                  if !a:state.child_found && len(a:state.queue) && a:state.queue[-1] ==# {'text': ''}
                                    call remove(a:state.queue, -1)
                                  endif
                                  let a:state.child_found = 1
                                  let offsets = map(split(matchstr(a:line, '^@\+ \zs[-+0-9, ]\+\ze @'), ' '), '+matchstr(v:val, "\\d\\+")')
                                  let context = {}
                                  if len(a:state.parents)
                                    let from = ":" . a:state.from
                                    let context.diff = map(copy(a:state.parents), s:log_diff_context)
                                  endif
                                  call add(a:state.queue, {
                                        \ 'valid': 1,
                                        \ 'context': context,
                                        \ 'filename': FugitiveVimPath(a:state.base . '/' . a:state.to),
                                        \ 'module': a:state.base_module . ':' . a:state.to,
                                        \ 'lnum': offsets[-1],
                                        \ 'text': a:state.message . matchstr(a:line, ' @@\+ .\+')})
                                endif
                              elseif a:state.follow &&
                                    \ a:line =~# '^ \%(mode change \d\|\%(create\|delete\) mode \d\|\%(rename\|copy\|rewrite\) .* (\d\+%)$\)'
                                let rename = matchstr(a:line, '^ rename \zs.* => .*\ze (\d\+%)$')
                                if len(rename)
                                  let rename = rename =~# '{.* => .*}' ? rename : '{' . rename . '}'
                                  if a:state.target ==# simplify('/' . substitute(rename, '{.* => \(.*\)}', '\1', ''))
                                    let a:state.target = simplify('/' . substitute(rename, '{\(.*\) => .*}', '\1', ''))
                                  endif
                                endif
                                if !get(a:state, 'ignore_summary')
                                  call add(a:state.queue, {'text': a:line})
                                endif
                              elseif a:state.mode ==# 'commit' || a:state.mode ==# 'init'
                                call add(a:state.queue, {'text': a:line})
                              endif
                              return []
                            endfunction
                            
    1              0.000002 function! fugitive#LogCommand(line1, count, range, bang, mods, args, type) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              let listnr = a:type =~# '^l' ? 0 : -1
                              let [args, after] = s:SplitExpandChain('log ' . a:args, s:Tree(dir))
                              call remove(args, 0)
                              let split = index(args, '--')
                              if split > 0
                                let paths = args[split : -1]
                                let args = args[0 : split - 1]
                              elseif split == 0
                                let paths = args
                                let args = []
                              else
                                let paths = []
                              endif
                              if a:line1 == 0 && a:count
                                let path = fugitive#Path(bufname(a:count), '/', dir)
                                let titlepre = ':0,' . a:count
                              elseif a:count >= 0
                                let path = fugitive#Path(@%, '/', dir)
                                let titlepre = a:count == 0 ? ':0,' . bufnr('') : ':'
                              else
                                let titlepre = ':'
                                let path = ''
                              endif
                              let range = ''
                              let extra_args = []
                              let extra_paths = []
                              let state = {'mode': 'init', 'child_found': 0, 'queue': [], 'follow': 0}
                              if path =~# '^/\.git\%(/\|$\)\|^$'
                                let path = ''
                              elseif a:line1 == 0
                                let range = "0," . (a:count ? a:count : bufnr(''))
                                let extra_paths = ['.' . path]
                                if (empty(paths) || paths ==# ['--']) && !s:HasOpt(args, '--no-follow')
                                  let state.follow = 1
                                  if !s:HasOpt(args, '--follow')
                                    call insert(extra_args, '--follow')
                                  endif
                                  if !s:HasOpt(args, '--summary')
                                    call insert(extra_args, '--summary')
                                    let state.ignore_summary = 1
                                  endif
                                endif
                                let state.ignore_commit = 1
                              elseif a:count > 0
                                if !s:HasOpt(args, '--merges', '--no-merges')
                                  call insert(extra_args, '--no-merges')
                                endif
                                call add(args, '-L' . a:line1 . ',' . a:count . ':' . path[1:-1])
                                let state.ignore_commit = 1
                              endif
                              if len(path) && empty(filter(copy(args), 'v:val =~# "^[^-]"'))
                                let owner = s:Owner(@%, dir)
                                if len(owner)
                                  call add(args, owner . (owner =~# '^\x\{40,}' ? '' : '^{}'))
                                endif
                              endif
                              if empty(extra_paths)
                                let path = ''
                              endif
                              if s:HasOpt(args, '-g', '--walk-reflogs')
                                let format = "%gd %P\t%H %gs"
                              else
                                let format = "%h %P\t%H " . g:fugitive_summary_format
                              endif
                              let cmd = ['--no-pager']
                              call extend(cmd, ['-c', 'diff.context=0', '-c', 'diff.noprefix=false', 'log'] +
                                    \ ['--no-color', '--no-ext-diff', '--pretty=format:fugitive ' . format] +
                                    \ args + extra_args + paths + extra_paths)
                              let state.target = path
                              let title = titlepre . (listnr < 0 ? 'Gclog ' : 'Gllog ') . s:fnameescape(args + paths)
                              return s:QuickfixStream(listnr, 'log', title, s:UserCommandList(dir) + cmd, !a:bang, a:mods, s:function('s:LogParse'), state, dir, s:DirUrlPrefix(dir)) . after
                            endfunction
                            
                            " Section: :Gedit, :Gpedit, :Gsplit, :Gvsplit, :Gtabedit, :Gread
                            
    1              0.000001 function! s:UsableWin(nr) abort
                              return a:nr && !getwinvar(a:nr, '&previewwindow') && !getwinvar(a:nr, '&winfixwidth') &&
                                    \ (empty(getwinvar(a:nr, 'fugitive_status')) || getbufvar(winbufnr(a:nr), 'fugitive_type') !=# 'index') &&
                                    \ index(['gitrebase', 'gitcommit'], getbufvar(winbufnr(a:nr), '&filetype')) < 0 &&
                                    \ index(['nofile','help','quickfix', 'terminal'], getbufvar(winbufnr(a:nr), '&buftype')) < 0
                            endfunction
                            
    1              0.000001 function! s:ArgSplit(string) abort
                              let string = a:string
                              let args = []
                              while string =~# '\S'
                                let arg = matchstr(string, '^\s*\%(\\.\|[^[:space:]]\)\+')
                                let string = strpart(string, len(arg))
                                let arg = substitute(arg, '^\s\+', '', '')
                                call add(args, substitute(arg, '\\\@<!\\ ', ' ', 'g'))
                              endwhile
                              return args
                            endfunction
                            
    1              0.000001 function! s:OpenParse(string, wants_cmd) abort
                              let opts = []
                              let cmds = []
                              let args = s:ArgSplit(a:string)
                              while !empty(args)
                                if args[0] =~# '^++'
                                  call add(opts, ' ' . escape(remove(args, 0), ' |"'))
                                elseif a:wants_cmd && args[0] =~# '^+'
                                  call add(cmds, remove(args, 0)[1:-1])
                                else
                                  break
                                endif
                              endwhile
                              if len(args) && args !=# ['>:']
                                let file = join(args)
                                if file ==# '-'
                                  let result = fugitive#Result()
                                  if has_key(result, 'file')
                                    let file = s:fnameescape(result.file)
                                  else
                                    throw 'fugitive: no previous command output'
                                  endif
                                endif
                              elseif empty(expand('%'))
                                let file = ''
                              elseif empty(s:DirCommitFile(@%)[1]) && s:Relative('./') !~# '^\./\.git\>'
                                let file = '>:0'
                              else
                                let file = '>'
                              endif
                              let dir = s:Dir()
                              let efile = s:Expand(file)
                              let url = s:Generate(efile, dir)
                            
                              if a:wants_cmd && file[0] ==# '>' && efile[0] !=# '>' && get(b:, 'fugitive_type', '') isnot# 'tree' && &filetype !=# 'netrw'
                                let line = line('.')
                                if expand('%:p') !=# url
                                  let diffcmd = 'diff'
                                  let from = s:DirRev(@%)[1]
                                  let to = s:DirRev(url)[1]
                                  if empty(from) && empty(to)
                                    let diffcmd = 'diff-files'
                                    let args = ['--', expand('%:p'), url]
                                  elseif empty(to)
                                    let args = [from, '--', url]
                                  elseif empty(from)
                                    let args = [to, '--', expand('%:p')]
                                    let reverse = 1
                                  else
                                    let args = [from, to]
                                  endif
                                  let [res, exec_error] = s:LinesError([dir, diffcmd, '-U0'] + args)
                                  if !exec_error
                                    call filter(res, 'v:val =~# "^@@ "')
                                    call map(res, 'substitute(v:val, ''[-+]\d\+\zs '', ",1 ", "g")')
                                    call map(res, 'matchlist(v:val, ''^@@ -\(\d\+\),\(\d\+\) +\(\d\+\),\(\d\+\) @@'')[1:4]')
                                    if exists('reverse')
                                      call map(res, 'v:val[2:3] + v:val[0:1]')
                                    endif
                                    call filter(res, 'v:val[0] < '.line('.'))
                                    let hunk = get(res, -1, [0,0,0,0])
                                    if hunk[0] + hunk[1] > line('.')
                                      let line = hunk[2] + max([1 - hunk[3], 0])
                                    else
                                      let line = hunk[2] + max([hunk[3], 1]) + line('.') - hunk[0] - max([hunk[1], 1])
                                    endif
                                  endif
                                endif
                                call insert(cmds, line)
                              endif
                            
                              let pre = join(opts, '')
                              if len(cmds) > 1
                                let pre .= ' +' . escape(join(map(cmds, '"exe ".string(v:val)'), '|'), ' |"')
                              elseif len(cmds)
                                let pre .= ' +' . escape(cmds[0], ' |"')
                              endif
                              return [url, pre]
                            endfunction
                            
    1              0.000001 function! fugitive#DiffClose() abort
                              let mywinnr = winnr()
                              for winnr in [winnr('#')] + range(winnr('$'),1,-1)
                                if winnr != mywinnr && getwinvar(winnr,'&diff')
                                  execute winnr.'wincmd w'
                                  close
                                  if winnr('$') > 1
                                    wincmd p
                                  endif
                                endif
                              endfor
                              diffoff!
                            endfunction
                            
    1              0.000001 function! s:BlurStatus() abort
                              if (&previewwindow || exists('w:fugitive_status')) && get(b:,'fugitive_type', '') ==# 'index'
                                let winnrs = filter([winnr('#')] + range(1, winnr('$')), 's:UsableWin(v:val)')
                                if len(winnrs)
                                  exe winnrs[0].'wincmd w'
                                else
                                  belowright new
                                endif
                                if &diff
                                  call fugitive#DiffClose()
                                endif
                              endif
                            endfunction
                            
    1              0.000003 let s:bang_edits = {'split': 'Git', 'vsplit': 'vertical Git', 'tabedit': 'tab Git', 'pedit': 'Git!'}
    1              0.000001 function! fugitive#Open(cmd, bang, mods, arg, args) abort
                              exe s:VersionCheck()
                              if a:bang
                                return 'echoerr ' . string(':G' . a:cmd . '! for temp buffer output has been replaced by :' . get(s:bang_edits, a:cmd, 'Git') . ' --paginate')
                              endif
                            
                              let mods = s:Mods(a:mods)
                              try
                                let [file, pre] = s:OpenParse(a:arg, 1)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if file !~# '^\a\a\+:' && !(has('win32') && file =~# '^\a:/$')
                                let file = substitute(file, '.\zs' . (has('win32') ? '[\/]' : '/') . '$', '', '')
                              endif
                              if a:cmd ==# 'edit'
                                call s:BlurStatus()
                              endif
                              return mods . a:cmd . pre . ' ' . s:fnameescape(file)
                            endfunction
                            
    1              0.000001 function! s:ReadPrepare(line1, count, range, mods) abort
                              let mods = s:Mods(a:mods)
                              let after = a:count
                              if a:count < 0
                                let delete = 'silent 1,' . line('$') . 'delete_|'
                                let after = line('$')
                              elseif a:range == 2
                                let delete = 'silent ' . a:line1 . ',' . a:count . 'delete_|'
                              else
                                let delete = ''
                              endif
                              if foldlevel(after)
                                let pre = after . 'foldopen!|'
                              else
                                let pre = ''
                              endif
                              return [pre . 'keepalt ' . mods . after . 'read', '|' . delete . 'diffupdate' . (a:count < 0 ? '|' . line('.') : '')]
                            endfunction
                            
    1              0.000002 function! fugitive#ReadCommand(line1, count, range, bang, mods, arg, args) abort
                              exe s:VersionCheck()
                              if a:bang
                                return 'echoerr ' . string(':Gread! for temp buffer output has been replaced by :{range}Git! --paginate')
                              endif
                              let [read, post] = s:ReadPrepare(a:line1, a:count, a:range, a:mods)
                              try
                                let [file, pre] = s:OpenParse(a:arg, 0)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if file =~# '^fugitive:' && a:count is# 0
                                return 'exe ' .string('keepalt ' . s:Mods(a:mods) . fugitive#FileReadCmd(file, 0, pre)) . '|diffupdate'
                              endif
                              return read . ' ' . pre . ' ' . s:fnameescape(file) . post
                            endfunction
                            
    1              0.000001 function! fugitive#EditComplete(A, L, P) abort
                              if a:A =~# '^>'
                                return map(s:FilterEscape(s:CompleteHeads(s:Dir()), a:A[1:-1]), "'>' . v:val")
                              else
                                return fugitive#CompleteObject(a:A, a:L, a:P)
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#ReadComplete(A, L, P) abort
                              if a:L =~# '^\w\+!'
                                return fugitive#Complete(a:A, a:L, a:P)
                              else
                                return fugitive#EditComplete(a:A, a:L, a:P)
                              endif
                            endfunction
                            
                            " Section: :Gwrite, :Gwq
                            
    1              0.000001 function! fugitive#WriteCommand(line1, line2, range, bang, mods, arg, args) abort
                              exe s:VersionCheck()
                              if s:cpath(expand('%:p'), fugitive#Find('.git/COMMIT_EDITMSG')) && empty(a:arg)
                                return (empty($GIT_INDEX_FILE) ? 'write|bdelete' : 'wq') . (a:bang ? '!' : '')
                              elseif get(b:, 'fugitive_type', '') ==# 'index' && empty(a:arg)
                                return 'Git commit'
                              elseif &buftype ==# 'nowrite' && getline(4) =~# '^[+-]\{3\} '
                                return 'echoerr ' . string('fugitive: :Gwrite from :Git diff has been removed in favor of :Git add --edit')
                              endif
                              let mytab = tabpagenr()
                              let mybufnr = bufnr('')
                              let args = s:ArgSplit(a:arg)
                              let after = ''
                              if get(args, 0) =~# '^+'
                                let after = '|' . remove(args, 0)[1:-1]
                              endif
                              try
                                let file = len(args) ? s:Generate(s:Expand(join(args, ' '))) : fugitive#Real(@%)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if empty(file)
                                return 'echoerr '.string('fugitive: cannot determine file path')
                              endif
                              if file =~# '^fugitive:'
                                return 'write' . (a:bang ? '! ' : ' ') . s:fnameescape(file)
                              endif
                              exe s:DirCheck()
                              let always_permitted = s:cpath(fugitive#Real(@%), file) && empty(s:DirCommitFile(@%)[1])
                              if !always_permitted && !a:bang && (len(s:TreeChomp('diff', '--name-status', 'HEAD', '--', file)) || len(s:TreeChomp('ls-files', '--others', '--', file)))
                                let v:errmsg = 'fugitive: file has uncommitted changes (use ! to override)'
                                return 'echoerr v:errmsg'
                              endif
                              let treebufnr = 0
                              for nr in range(1,bufnr('$'))
                                if fnamemodify(bufname(nr),':p') ==# file
                                  let treebufnr = nr
                                endif
                              endfor
                            
                              if treebufnr > 0 && treebufnr != bufnr('')
                                let temp = tempname()
                                silent execute 'keepalt %write '.temp
                                for tab in [mytab] + range(1,tabpagenr('$'))
                                  for winnr in range(1,tabpagewinnr(tab,'$'))
                                    if tabpagebuflist(tab)[winnr-1] == treebufnr
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        let lnum = line('.')
                                        let last = line('$')
                                        silent execute '$read '.temp
                                        silent execute '1,'.last.'delete_'
                                        silent write!
                                        silent execute lnum
                                        diffupdate
                                        let did = 1
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                      break
                                    endif
                                  endfor
                                endfor
                                if !exists('did')
                                  call writefile(readfile(temp,'b'),file,'b')
                                endif
                              else
                                execute 'write! '.s:fnameescape(file)
                              endif
                            
                              let message = s:ChompStderr(['add'] + (a:bang ? ['--force'] : []) + ['--', file])
                              if len(message)
                                let v:errmsg = 'fugitive: '.message
                                return 'echoerr v:errmsg'
                              endif
                              if s:cpath(fugitive#Real(@%), file) && s:DirCommitFile(@%)[1] =~# '^\d$'
                                setlocal nomodified
                              endif
                            
                              let one = fugitive#Find(':1:'.file)
                              let two = fugitive#Find(':2:'.file)
                              let three = fugitive#Find(':3:'.file)
                              for nr in range(1,bufnr('$'))
                                let name = fnamemodify(bufname(nr), ':p')
                                if bufloaded(nr) && !getbufvar(nr,'&modified') && (name ==# one || name ==# two || name ==# three)
                                  execute nr.'bdelete'
                                endif
                              endfor
                            
                              unlet! restorewinnr
                              let zero = fugitive#Find(':0:'.file)
                              silent exe s:DoAutocmd('BufWritePost ' . s:fnameescape(zero))
                              for tab in range(1,tabpagenr('$'))
                                for winnr in range(1,tabpagewinnr(tab,'$'))
                                  let bufnr = tabpagebuflist(tab)[winnr-1]
                                  let bufname = fnamemodify(bufname(bufnr), ':p')
                                  if bufname ==# zero && bufnr != mybufnr
                                    execute 'tabnext '.tab
                                    if winnr != winnr()
                                      execute winnr.'wincmd w'
                                      let restorewinnr = 1
                                    endif
                                    try
                                      let lnum = line('.')
                                      let last = line('$')
                                      silent execute '$read '.s:fnameescape(file)
                                      silent execute '1,'.last.'delete_'
                                      silent execute lnum
                                      setlocal nomodified
                                      diffupdate
                                    finally
                                      if exists('restorewinnr')
                                        wincmd p
                                      endif
                                      execute 'tabnext '.mytab
                                    endtry
                                    break
                                  endif
                                endfor
                              endfor
                              call fugitive#ReloadStatus(-1, 1)
                              return 'silent checktime' . after
                            endfunction
                            
    1              0.000001 function! fugitive#WqCommand(...) abort
                              let bang = a:4 ? '!' : ''
                              if s:cpath(expand('%:p'), fugitive#Find('.git/COMMIT_EDITMSG'))
                                return 'wq'.bang
                              endif
                              let result = call('fugitive#WriteCommand', a:000)
                              if result =~# '^\%(write\|wq\|echoerr\)'
                                return s:sub(result,'^write','wq')
                              else
                                return result.'|quit'.bang
                              endif
                            endfunction
                            
                            " Section: :Git push, :Git fetch
                            
    1              0.000001 function! s:CompletePush(A, L, P, ...) abort
                              let dir = a:0 ? a:1 : s:Dir()
                              let remote = matchstr(a:L, '\u\w*[! ] *.\{-\}\s\@<=\zs[^-[:space:]]\S*\ze ')
                              if empty(remote)
                                let matches = s:LinesError([dir, 'remote'])[0]
                              elseif a:A =~# ':'
                                let lead = matchstr(a:A, '^[^:]*:')
                                let matches = s:LinesError([dir, 'ls-remote', remote])[0]
                                call filter(matches, 'v:val =~# "\t" && v:val !~# "{"')
                                call map(matches, 'lead . s:sub(v:val, "^.*\t", "")')
                              else
                                let matches = s:CompleteHeads(dir)
                              endif
                              return s:FilterEscape(matches, a:A)
                            endfunction
                            
    1              0.000001 function! fugitive#PushComplete(A, L, P, ...) abort
                              return s:CompleteSub('push', a:A, a:L, a:P, function('s:CompletePush'), a:000)
                            endfunction
                            
    1              0.000001 function! fugitive#FetchComplete(A, L, P, ...) abort
                              return s:CompleteSub('fetch', a:A, a:L, a:P, function('s:CompleteRemote'), a:000)
                            endfunction
                            
    1              0.000001 function! s:PushSubcommand(...) abort
                              return {'no_more': 1}
                            endfunction
                            
    1              0.000001 function! s:FetchSubcommand(...) abort
                              return {'no_more': 1}
                            endfunction
                            
                            " Section: :Gdiff
                            
    1              0.000001 augroup fugitive_diff
    1              0.000047   autocmd!
    1              0.000005   autocmd BufWinLeave * nested
                                    \ if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |
                                    \   call s:diffoff_all(s:Dir(+expand('<abuf>'))) |
                                    \ endif
    1              0.000003   autocmd BufWinEnter * nested
                                    \ if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |
                                    \   call s:diffoff() |
                                    \ endif
    1              0.000001 augroup END
                            
    1              0.000001 function! s:can_diffoff(buf) abort
                              return getwinvar(bufwinnr(a:buf), '&diff') &&
                                    \ !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))
                            endfunction
                            
    1              0.000001 function! fugitive#CanDiffoff(buf) abort
                              return s:can_diffoff(bufnr(a:buf))
                            endfunction
                            
    1              0.000001 function! s:DiffModifier(count, default) abort
                              let fdc = matchstr(&diffopt, 'foldcolumn:\zs\d\+')
                              if &diffopt =~# 'horizontal' && &diffopt !~# 'vertical'
                                return ''
                              elseif &diffopt =~# 'vertical'
                                return 'vertical '
                              elseif !get(g:, 'fugitive_diffsplit_directional_fit', a:default)
                                return ''
                              elseif winwidth(0) <= a:count * ((&tw ? &tw : 80) + (empty(fdc) ? 2 : fdc))
                                return ''
                              else
                                return 'vertical '
                              endif
                            endfunction
                            
    1              0.000001 function! s:diff_window_count() abort
                              let c = 0
                              for nr in range(1,winnr('$'))
                                let c += getwinvar(nr,'&diff')
                              endfor
                              return c
                            endfunction
                            
    1              0.000001 function! s:diff_restore() abort
                              let restore = 'setlocal nodiff noscrollbind'
                                    \ . ' scrollopt=' . &l:scrollopt
                                    \ . (&l:wrap ? ' wrap' : ' nowrap')
                                    \ . ' foldlevel=999'
                                    \ . ' foldmethod=' . &l:foldmethod
                                    \ . ' foldcolumn=' . &l:foldcolumn
                                    \ . ' foldlevel=' . &l:foldlevel
                                    \ . (&l:foldenable ? ' foldenable' : ' nofoldenable')
                              if has('cursorbind')
                                let restore .= (&l:cursorbind ? ' ' : ' no') . 'cursorbind'
                              endif
                              return restore
                            endfunction
                            
    1              0.000001 function! s:diffthis() abort
                              if !&diff
                                let w:fugitive_diff_restore = s:diff_restore()
                                diffthis
                              endif
                            endfunction
                            
    1              0.000001 function! s:diffoff() abort
                              if exists('w:fugitive_diff_restore') && v:version < 704
                                execute w:fugitive_diff_restore
                              endif
                              unlet! w:fugitive_diff_restore
                              diffoff
                            endfunction
                            
    1              0.000001 function! s:diffoff_all(dir) abort
                              let curwin = winnr()
                              for nr in range(1,winnr('$'))
                                if getwinvar(nr, '&diff') && !empty(getwinvar(nr, 'fugitive_diff_restore'))
                                  if v:version < 704
                                    if nr != winnr()
                                      execute nr.'wincmd w'
                                    endif
                                    execute w:fugitive_diff_restore
                                  endif
                                  call setwinvar(nr, 'fugitive_diff_restore', '')
                                endif
                              endfor
                              if curwin != winnr()
                                execute curwin.'wincmd w'
                              endif
                              diffoff!
                            endfunction
                            
    1              0.000001 function! s:IsConflicted() abort
                              return len(@%) && !empty(s:ChompDefault('', ['ls-files', '--unmerged', '--', expand('%:p')]))
                            endfunction
                            
    1              0.000001 function! fugitive#Diffsplit(autodir, keepfocus, mods, arg, args) abort
                              exe s:VersionCheck()
                              let args = s:ArgSplit(a:arg)
                              let post = ''
                              let autodir = a:autodir
                              while get(args, 0, '') =~# '^++'
                                if args[0] =~? '^++novertical$'
                                  let autodir = 0
                                else
                                  return 'echoerr ' . string('fugitive: unknown option ' . args[0])
                                endif
                                call remove(args, 0)
                              endwhile
                              if get(args, 0) =~# '^+'
                                let post = remove(args, 0)[1:-1]
                              endif
                              if exists(':DiffGitCached') && empty(args)
                                return s:Mods(a:mods) . 'DiffGitCached' . (len(post) ? '|' . post : '')
                              endif
                              let commit = s:DirCommitFile(@%)[1]
                              if a:mods =~# '\<tab\>'
                                let mods = substitute(a:mods, '\<tab\>', '', 'g')
                                let pre = 'tab split'
                              else
                                let mods = 'keepalt ' . a:mods
                                let pre = ''
                              endif
                              let back = exists('*win_getid') ? 'call win_gotoid(' . win_getid() . ')' : 'wincmd p'
                              if (empty(args) || args[0] =~# '^>\=:$') && a:keepfocus
                                exe s:DirCheck()
                                if commit =~# '^1\=$' && s:IsConflicted()
                                  let parents = [s:Relative(':2:'), s:Relative(':3:')]
                                elseif empty(commit)
                                  let parents = [s:Relative(':0:')]
                                elseif commit =~# '^\d\=$'
                                  let parents = [s:Relative('@:')]
                                elseif commit =~# '^\x\x\+$'
                                  let parents = s:LinesError(['rev-parse', commit . '^@'])[0]
                                  call map(parents, 's:Relative(v:val . ":")')
                                endif
                              endif
                              try
                                if exists('parents') && len(parents) > 1
                                  exe pre
                                  let mods = (autodir ? s:DiffModifier(len(parents) + 1, empty(args) || args[0] =~# '^>') : '') . s:Mods(mods, 'leftabove')
                                  let nr = bufnr('')
                                  if len(parents) > 1 && !&equalalways
                                    let equalalways = 0
                                    set equalalways
                                  endif
                                  execute mods 'split' s:fnameescape(fugitive#Find(parents[0]))
                                  call s:Map('n', 'dp', ':diffput '.nr.'<Bar>diffupdate<CR>', '<silent>')
                                  let nr2 = bufnr('')
                                  call s:diffthis()
                                  exe back
                                  call s:Map('n', 'd2o', ':diffget '.nr2.'<Bar>diffupdate<CR>', '<silent>')
                                  let mods = substitute(mods, '\Cleftabove\|rightbelow\|aboveleft\|belowright', '\=submatch(0) =~# "f" ? "rightbelow" : "leftabove"', '')
                                  for i in range(len(parents)-1, 1, -1)
                                    execute mods 'split' s:fnameescape(fugitive#Find(parents[i]))
                                    call s:Map('n', 'dp', ':diffput '.nr.'<Bar>diffupdate<CR>', '<silent>')
                                    let nrx = bufnr('')
                                    call s:diffthis()
                                    exe back
                                    call s:Map('n', 'd' . (i + 2) . 'o', ':diffget '.nrx.'<Bar>diffupdate<CR>', '<silent>')
                                  endfor
                                  call s:diffthis()
                                  return post
                                elseif len(args)
                                  let arg = join(args, ' ')
                                  if arg ==# ''
                                    return post
                                  elseif arg ==# ':/'
                                    exe s:DirCheck()
                                    let file = s:Relative()
                                  elseif arg ==# ':'
                                    exe s:DirCheck()
                                    let file = len(commit) ? s:Relative() : s:Relative(s:IsConflicted() ? ':1:' : ':0:')
                                  elseif arg =~# '^:\d$'
                                    exe s:DirCheck()
                                    let file = s:Relative(arg . ':')
                                  elseif arg =~# '^[~^]\d*$'
                                    return 'echoerr ' . string('fugitive: change ' . arg . ' to !' . arg . ' to diff against ancestor')
                                  else
                                    try
                                      let file = arg =~# '^:/.' ? fugitive#RevParse(arg) . s:Relative(':') : s:Expand(arg)
                                    catch /^fugitive:/
                                      return 'echoerr ' . string(v:exception)
                                    endtry
                                  endif
                                  if a:keepfocus || arg =~# '^>'
                                    let mods = s:Mods(a:mods, 'leftabove')
                                  else
                                    let mods = s:Mods(a:mods)
                                  endif
                                elseif exists('parents')
                                  let file = get(parents, -1, s:Relative(repeat('0', 40). ':'))
                                  let mods = s:Mods(a:mods, 'leftabove')
                                elseif len(commit)
                                  let file = s:Relative()
                                  let mods = s:Mods(a:mods, 'rightbelow')
                                elseif s:IsConflicted()
                                  let file = s:Relative(':1:')
                                  let mods = s:Mods(a:mods, 'leftabove')
                                  if get(g:, 'fugitive_legacy_commands', 1)
                                    let post = 'echohl WarningMsg|echo "Use :Gdiffsplit! for 3 way diff"|echohl NONE|' . post
                                  endif
                                else
                                  exe s:DirCheck()
                                  let file = s:Relative(':0:')
                                  let mods = s:Mods(a:mods, 'leftabove')
                                endif
                                let spec = s:Generate(file)
                                if spec =~# '^fugitive:' && empty(s:DirCommitFile(spec)[2])
                                  let spec = FugitiveVimPath(spec . s:Relative('/'))
                                endif
                                exe pre
                                let restore = s:diff_restore()
                                let w:fugitive_diff_restore = restore
                                let mods = (autodir ? s:DiffModifier(2, empty(args) || args[0] =~# '^>') : '') . mods
                                if &diffopt =~# 'vertical'
                                  let diffopt = &diffopt
                                  set diffopt-=vertical
                                endif
                                execute mods 'diffsplit' s:fnameescape(spec)
                                let w:fugitive_diff_restore = restore
                                let winnr = winnr()
                                if getwinvar('#', '&diff')
                                  if a:keepfocus
                                    exe back
                                  endif
                                endif
                                return post
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              finally
                                if exists('l:equalalways')
                                  let &l:equalalways = equalalways
                                endif
                                if exists('diffopt')
                                  let &diffopt = diffopt
                                endif
                              endtry
                            endfunction
                            
                            " Section: :GMove, :GRemove
                            
    1              0.000001 function! s:Move(force, rename, destination) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              if s:DirCommitFile(@%)[1] !~# '^0\=$' || empty(@%)
                                return 'echoerr ' . string('fugitive: mv not supported for this buffer')
                              endif
                              if a:destination =~# '^\a\+:\|^/'
                                let destination = a:destination
                              elseif a:destination =~# '^:/:\='
                                let destination = s:Tree(dir) . substitute(a:destination, '^:/:\=', '', '')
                              elseif a:destination =~# '^:(\%(top\|top,literal\|literal,top\))'
                                let destination = s:Tree(dir) . matchstr(a:destination, ')\zs.*')
                              elseif a:destination =~# '^:(literal)'
                                let destination = simplify(getcwd() . '/' . matchstr(a:destination, ')\zs.*'))
                              elseif a:rename
                                let destination = simplify(expand('%:p:s?[\/]$??:h') . '/' . a:destination)
                              elseif a:destination =~# '^\.\.\=\%(/\|$\)'
                                let destination = simplify(getcwd() . '/' . a:destination)
                              else
                                let destination = s:Tree(dir) . '/' . a:destination
                              endif
                              let destination = s:Slash(destination)
                              if isdirectory(@%)
                                setlocal noswapfile
                              endif
                              let message = s:ChompStderr(['mv'] + (a:force ? ['-f'] : []) + ['--', expand('%:p'), destination], dir)
                              if len(message)
                                let v:errmsg = 'fugitive: '.message
                                return 'echoerr v:errmsg'
                              endif
                              if isdirectory(destination)
                                let destination = fnamemodify(s:sub(destination,'/$','').'/'.expand('%:t'),':.')
                              endif
                              let reload = '|call fugitive#ReloadStatus(' . string(dir) . ', 1)'
                              if empty(s:DirCommitFile(@%)[1])
                                if isdirectory(destination)
                                  return 'keepalt edit '.s:fnameescape(destination) . reload
                                else
                                  return 'keepalt saveas! '.s:fnameescape(destination) . reload
                                endif
                              else
                                return 'file '.s:fnameescape(fugitive#Find(':0:'.destination, dir)) . reload
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#RenameComplete(A,L,P) abort
                              if a:A =~# '^[.:]\=/'
                                return fugitive#CompletePath(a:A)
                              else
                                let pre = s:Slash(fnamemodify(expand('%:p:s?[\/]$??'), ':h')) . '/'
                                return map(fugitive#CompletePath(pre.a:A), 'strpart(v:val, len(pre))')
                              endif
                            endfunction
                            
    1              0.000002 function! fugitive#MoveCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Move(a:bang, 0, a:arg)
                            endfunction
                            
    1              0.000002 function! fugitive#RenameCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Move(a:bang, 1, a:arg)
                            endfunction
                            
    1              0.000001 function! s:Remove(after, force) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              if len(@%) && s:DirCommitFile(@%)[1] ==# ''
                                let cmd = ['rm']
                              elseif s:DirCommitFile(@%)[1] ==# '0'
                                let cmd = ['rm','--cached']
                              else
                                return 'echoerr ' . string('fugitive: rm not supported for this buffer')
                              endif
                              if a:force
                                let cmd += ['--force']
                              endif
                              let message = s:ChompStderr(cmd + ['--', expand('%:p')], dir)
                              if len(message)
                                let v:errmsg = 'fugitive: '.s:sub(message,'error:.*\zs\n\(.*-f.*',' (add ! to force)')
                                return 'echoerr '.string(v:errmsg)
                              else
                                return a:after . (a:force ? '!' : ''). '|call fugitive#ReloadStatus(' . string(dir) . ', 1)'
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#RemoveCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Remove('edit', a:bang)
                            endfunction
                            
    1              0.000001 function! fugitive#DeleteCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Remove('bdelete', a:bang)
                            endfunction
                            
                            " Section: :Git blame
                            
    1              0.000001 function! s:Keywordprg() abort
                              let args = ' --git-dir='.escape(s:Dir(),"\\\"' ")
                              if has('gui_running') && !has('win32')
                                return s:GitShellCmd() . ' --no-pager' . args . ' log -1'
                              else
                                return s:GitShellCmd() . args . ' show'
                              endif
                            endfunction
                            
    1              0.000001 function! s:linechars(pattern) abort
                              let chars = strlen(s:gsub(matchstr(getline('.'), a:pattern), '.', '.'))
                              if exists('*synconcealed') && &conceallevel > 1
                                for col in range(1, chars)
                                  let chars -= synconcealed(line('.'), col)[0]
                                endfor
                              endif
                              return chars
                            endfunction
                            
    1              0.000001 function! s:BlameBufnr(...) abort
                              let state = s:TempState(bufname(a:0 ? a:1 : ''))
                              if get(state, 'filetype', '') ==# 'fugitiveblame'
                                return get(state, 'origin_bufnr', -1)
                              else
                                return -1
                              endif
                            endfunction
                            
    1              0.000001 function! s:BlameCommitFileLnum(...) abort
                              let line = a:0 ? a:1 : getline('.')
                              let state = a:0 > 1 ? a:2 : s:TempState()
                              if get(state, 'filetype', '') !=# 'fugitiveblame'
                                return ['', '', 0]
                              endif
                              let commit = matchstr(line, '^\^\=[?*]*\zs\x\+')
                              if commit =~# '^0\+$'
                                let commit = ''
                              elseif has_key(state, 'blame_reverse_end')
                                let commit = get(s:LinesError([state.git_dir, 'rev-list', '--ancestry-path', '--reverse', commit . '..' . state.blame_reverse_end])[0], 0, '')
                              endif
                              let lnum = +matchstr(line, ' \zs\d\+\ze \%((\| *\d\+)\)')
                              let path = matchstr(line, '^\^\=[?*]*\x* \+\%(\d\+ \+\d\+ \+\)\=\zs.\{-\}\ze\s*\d\+ \%((\| *\d\+)\)')
                              if empty(path) && lnum
                                let path = get(state, 'blame_file', '')
                              endif
                              return [commit, path, lnum]
                            endfunction
                            
    1              0.000001 function! s:BlameLeave() abort
                              let bufwinnr = bufwinnr(s:BlameBufnr())
                              if bufwinnr > 0
                                let bufnr = bufnr('')
                                exe bufwinnr . 'wincmd w'
                                return bufnr . 'bdelete'
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! s:BlameQuit() abort
                              let cmd = s:BlameLeave()
                              if empty(cmd)
                                return 'bdelete'
                              elseif len(s:DirCommitFile(@%)[1])
                                return cmd . '|Gedit'
                              else
                                return cmd
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#BlameComplete(A, L, P) abort
                              return s:CompleteSub('blame', a:A, a:L, a:P)
                            endfunction
                            
    1              0.000001 function! s:BlameSubcommand(line1, count, range, bang, mods, options) abort
                              let dir = s:Dir(a:options)
                              exe s:DirCheck(dir)
                              let flags = copy(a:options.subcommand_args)
                              let i = 0
                              let raw = 0
                              let commits = []
                              let files = []
                              let ranges = []
                              if a:line1 > 0 && a:count > 0 && a:range != 1
                                call extend(ranges, ['-L', a:line1 . ',' . a:count])
                              endif
                              while i < len(flags)
                                let match = matchlist(flags[i], '^\(-[a-zABDFH-KN-RT-Z]\)\ze\(.*\)')
                                if len(match) && len(match[2])
                                  call insert(flags, match[1])
                                  let flags[i+1] = '-' . match[2]
                                  continue
                                endif
                                let arg = flags[i]
                                if arg =~# '^-p$\|^--\%(help\|porcelain\|line-porcelain\|incremental\)$'
                                  let raw = 1
                                elseif arg ==# '--contents' && i + 1 < len(flags)
                                  call extend(commits, remove(flags, i, i+1))
                                  continue
                                elseif arg ==# '-L' && i + 1 < len(flags)
                                  call extend(ranges, remove(flags, i, i+1))
                                  continue
                                elseif arg =~# '^--contents='
                                  call add(commits, remove(flags, i))
                                  continue
                                elseif arg =~# '^-L.'
                                  call add(ranges, remove(flags, i))
                                  continue
                                elseif arg =~# '^-[GLS]$\|^--\%(date\|encoding\|contents\|ignore-rev\|ignore-revs-file\)$'
                                  let i += 1
                                  if i == len(flags)
                                    echohl ErrorMsg
                                    echo s:ChompStderr([dir, 'blame', arg])
                                    echohl NONE
                                    return ''
                                  endif
                                elseif arg ==# '--'
                                  if i + 1 < len(flags)
                                    call extend(files, remove(flags, i + 1, -1))
                                  endif
                                  call remove(flags, i)
                                  break
                                elseif arg !~# '^-' && (s:HasOpt(flags, '--not') || arg !~# '^\^')
                                  if index(flags, '--') >= 0
                                    call add(commits, remove(flags, i))
                                    continue
                                  endif
                                  if arg =~# '\.\.' && arg !~# '^\.\.\=\%(/\|$\)' && empty(commits)
                                    call add(commits, remove(flags, i))
                                    continue
                                  endif
                                  try
                                    let dcf = s:DirCommitFile(fugitive#Find(arg, dir))
                                    if len(dcf[1]) && empty(dcf[2])
                                      call add(commits, remove(flags, i))
                                      continue
                                    endif
                                  catch /^fugitive:/
                                  endtry
                                  call add(files, remove(flags, i))
                                  continue
                                endif
                                let i += 1
                              endwhile
                              let file = substitute(get(files, 0, get(s:TempState(), 'blame_file', s:Relative('./', dir))), '^\.\%(/\|$\)', '', '')
                              if empty(commits) && len(files) > 1
                                call add(commits, remove(files, 1))
                              endif
                              exe s:BlameLeave()
                              try
                                let cmd = a:options.flags + ['--no-pager', '-c', 'blame.coloring=none', '-c', 'blame.blankBoundary=false', a:options.subcommand, '--show-number']
                                call extend(cmd, filter(copy(flags), 'v:val !~# "\\v^%(-b|--%(no-)=color-.*|--progress)$"'))
                                if a:count > 0 && empty(ranges)
                                  let cmd += ['-L', (a:line1 ? a:line1 : line('.')) . ',' . (a:line1 ? a:line1 : line('.'))]
                                endif
                                call extend(cmd, ranges)
                                let tempname = tempname()
                                let temp = tempname . (raw ? '' : '.fugitiveblame')
                                if len(commits)
                                  let cmd += commits
                                elseif empty(files) && len(matchstr(s:DirCommitFile(@%)[1], '^\x\x\+$'))
                                  let cmd += [matchstr(s:DirCommitFile(@%)[1], '^\x\x\+$')]
                                elseif empty(files) && !s:HasOpt(flags, '--reverse')
                                  let cmd += ['--contents', tempname . '.in']
                                  silent execute 'noautocmd keepalt %write ' . s:fnameescape(tempname . '.in')
                                  let delete_in = 1
                                endif
                                let basecmd = [{'git': a:options.git, 'git_dir': dir}] + ['--literal-pathspecs'] + cmd + ['--'] + (len(files) ? files : [file])
                                let [err, exec_error] = s:StdoutToFile(temp, basecmd)
                                if exists('delete_in')
                                  call delete(tempname . '.in')
                                endif
                                redraw
                                try
                                  if exec_error
                                    let lines = split(err, "\n")
                                    if empty(lines)
                                      let lines = readfile(temp)
                                    endif
                                    for i in range(len(lines))
                                      if lines[i] =~# '^error: \|^fatal: '
                                        echohl ErrorMsg
                                        echon lines[i]
                                        echohl NONE
                                        break
                                      else
                                        echon lines[i]
                                      endif
                                      if i != len(lines) - 1
                                        echon "\n"
                                      endif
                                    endfor
                                    return ''
                                  endif
                                  let temp_state = {
                                        \ 'git': a:options.git,
                                        \ 'flags': a:options.flags,
                                        \ 'args': [a:options.subcommand] + a:options.subcommand_args,
                                        \ 'dir': dir,
                                        \ 'git_dir': dir,
                                        \ 'cwd': s:UserCommandCwd(dir),
                                        \ 'filetype': (raw ? 'git' : 'fugitiveblame'),
                                        \ 'blame_options': a:options,
                                        \ 'blame_flags': flags,
                                        \ 'blame_file': file}
                                  if s:HasOpt(flags, '--reverse')
                                    let temp_state.blame_reverse_end = matchstr(get(commits, 0, ''), '\.\.\zs.*')
                                  endif
                                  if (a:line1 == 0 || a:range == 1) && a:count > 0
                                    let edit = s:Mods(a:mods) . get(['edit', 'split', 'pedit', 'vsplit', 'tabedit'], a:count - (a:line1 ? a:line1 : 1), 'split')
                                    return s:BlameCommit(edit, get(readfile(temp), 0, ''), temp_state)
                                  else
                                    let temp = s:Resolve(temp)
                                    let temp_state.file = temp
                                    call s:RunSave(temp_state)
                                    if len(ranges + commits + files) || raw
                                      let reload = '|call fugitive#ReloadStatus(fugitive#Result(' . string(temp_state.file) . '), 1)'
                                      let mods = s:Mods(a:mods)
                                      if a:count != 0
                                        exe 'silent keepalt' mods 'split' s:fnameescape(temp)
                                      elseif !&modified || a:bang || &bufhidden ==# 'hide' || (empty(&bufhidden) && &hidden)
                                        exe 'silent' mods 'edit' . (a:bang ? '! ' : ' ') . s:fnameescape(temp)
                                      else
                                        return mods . 'edit ' . s:fnameescape(temp) . reload
                                      endif
                                      return reload[1 : -1]
                                    endif
                                    if a:mods =~# '\<tab\>'
                                      silent tabedit %
                                    endif
                                    let bufnr = bufnr('')
                                    let temp_state.origin_bufnr = bufnr
                                    let restore = []
                                    let mods = substitute(a:mods, '\<tab\>', '', 'g')
                                    for winnr in range(winnr('$'),1,-1)
                                      if getwinvar(winnr, '&scrollbind')
                                        if !&l:scrollbind
                                          call setwinvar(winnr, '&scrollbind', 0)
                                        elseif winnr != winnr() && getwinvar(winnr, '&foldenable')
                                          call setwinvar(winnr, '&foldenable', 0)
                                          call add(restore, 'call setwinvar(bufwinnr('.winbufnr(winnr).'),"&foldenable",1)')
                                        endif
                                      endif
                                      if exists('+cursorbind') && !&l:cursorbind && getwinvar(winnr, '&cursorbind')
                                        call setwinvar(winnr, '&cursorbind', 0)
                                      endif
                                      if s:BlameBufnr(winbufnr(winnr)) > 0
                                        execute winbufnr(winnr).'bdelete'
                                      endif
                                    endfor
                                    let restore_winnr = 'bufwinnr(' . bufnr . ')'
                                    if !&l:scrollbind
                                      call add(restore, 'call setwinvar(' . restore_winnr . ',"&scrollbind",0)')
                                    endif
                                    if exists('+cursorbind') && !&l:cursorbind
                                      call add(restore, 'call setwinvar(' . restore_winnr . ',"&cursorbind",0)')
                                    endif
                                    if &l:wrap
                                      call add(restore, 'call setwinvar(' . restore_winnr . ',"&wrap",1)')
                                    endif
                                    if &l:foldenable
                                      call add(restore, 'call setwinvar(' . restore_winnr . ',"&foldenable",1)')
                                    endif
                                    setlocal scrollbind nowrap nofoldenable
                                    if exists('+cursorbind')
                                      setlocal cursorbind
                                    endif
                                    let top = line('w0') + &scrolloff
                                    let current = line('.')
                                    exe 'silent keepalt' (a:bang ? s:Mods(mods) . 'split' : s:Mods(mods, 'leftabove') . 'vsplit') s:fnameescape(temp)
                                    let w:fugitive_leave = join(restore, '|')
                                    execute top
                                    normal! zt
                                    execute current
                                    if exists('+cursorbind')
                                      setlocal cursorbind
                                    endif
                                    setlocal nonumber scrollbind nowrap foldcolumn=0 nofoldenable winfixwidth
                                    if exists('+relativenumber')
                                      setlocal norelativenumber
                                    endif
                                    if exists('+signcolumn')
                                      setlocal signcolumn=no
                                    endif
                                    execute "vertical resize ".(s:linechars('.\{-\}\s\+\d\+\ze)')+1)
                                    redraw
                                    syncbind
                                    exe s:DoAutocmdChanged(temp_state)
                                  endif
                                endtry
                                return ''
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:BlameCommit(cmd, ...) abort
                              let line = a:0 ? a:1 : getline('.')
                              let state = a:0 ? a:2 : s:TempState()
                              let sigil = has_key(state, 'blame_reverse_end') ? '-' : '+'
                              let mods = (s:BlameBufnr() < 0 ? '' : &splitbelow ? "botright " : "topleft ")
                              let [commit, path, lnum] = s:BlameCommitFileLnum(line, state)
                              if empty(commit) && len(path) && has_key(state, 'blame_reverse_end')
                                let path = (len(state.blame_reverse_end) ? state.blame_reverse_end . ':' : ':(top)') . path
                                return fugitive#Open(mods . a:cmd, 0, '', '+' . lnum . ' ' . s:fnameescape(path), ['+' . lnum, path])
                              endif
                              if commit =~# '^0*$'
                                return 'echoerr ' . string('fugitive: no commit')
                              endif
                              if line =~# '^\^' && !has_key(state, 'blame_reverse_end')
                                let path = commit . ':' . path
                                return fugitive#Open(mods . a:cmd, 0, '', '+' . lnum . ' ' . s:fnameescape(path), ['+' . lnum, path])
                              endif
                              let cmd = fugitive#Open(mods . a:cmd, 0, '', commit, [commit])
                              if cmd =~# '^echoerr'
                                return cmd
                              endif
                              execute cmd
                              if a:cmd ==# 'pedit' || empty(path)
                                return ''
                              endif
                              if search('^diff .* b/\M'.escape(path,'\').'$','W')
                                call search('^+++')
                                let head = line('.')
                                while search('^@@ \|^diff ') && getline('.') =~# '^@@ '
                                  let top = +matchstr(getline('.'),' ' . sigil .'\zs\d\+')
                                  let len = +matchstr(getline('.'),' ' . sigil . '\d\+,\zs\d\+')
                                  if lnum >= top && lnum <= top + len
                                    let offset = lnum - top
                                    if &scrolloff
                                      +
                                      normal! zt
                                    else
                                      normal! zt
                                      +
                                    endif
                                    while offset > 0 && line('.') < line('$')
                                      +
                                      if getline('.') =~# '^[ ' . sigil . ']'
                                        let offset -= 1
                                      endif
                                    endwhile
                                    return 'normal! zv'
                                  endif
                                endwhile
                                execute head
                                normal! zt
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! s:BlameJump(suffix, ...) abort
                              let suffix = a:suffix
                              let [commit, path, lnum] = s:BlameCommitFileLnum()
                              if empty(path)
                                return 'echoerr ' . string('fugitive: could not determine filename for blame')
                              endif
                              if commit =~# '^0*$'
                                let commit = '@'
                                let suffix = ''
                              endif
                              let offset = line('.') - line('w0')
                              let state = s:TempState()
                              let flags = get(state, 'blame_flags', [])
                              if a:0 && a:1
                                if s:HasOpt(flags, '--reverse')
                                  call remove(flags, '--reverse')
                                else
                                  call add(flags, '--reverse')
                                endif
                              endif
                              let blame_bufnr = s:BlameBufnr()
                              if blame_bufnr > 0
                                let bufnr = bufnr('')
                                let winnr = bufwinnr(blame_bufnr)
                                if winnr > 0
                                  exe winnr.'wincmd w'
                                  exe bufnr.'bdelete'
                                endif
                                execute 'Gedit' s:fnameescape(commit . suffix . ':' . path)
                                execute lnum
                              endif
                              let my_bufnr = bufnr('')
                              if blame_bufnr < 0
                                let blame_args = flags + [commit . suffix, '--', path]
                                let result = s:BlameSubcommand(0, 0, 0, 0, '', extend({'subcommand_args': blame_args}, state.blame_options, 'keep'))
                              else
                                let blame_args = flags
                                let result = s:BlameSubcommand(-1, -1, 0, 0, '', extend({'subcommand_args': blame_args}, state.blame_options, 'keep'))
                              endif
                              if bufnr('') == my_bufnr
                                return result
                              endif
                              execute result
                              execute lnum
                              let delta = line('.') - line('w0') - offset
                              if delta > 0
                                execute 'normal! '.delta."\<C-E>"
                              elseif delta < 0
                                execute 'normal! '.(-delta)."\<C-Y>"
                              endif
                              keepjumps syncbind
                              redraw
                              echo ':Git blame' s:fnameescape(blame_args)
                              return ''
                            endfunction
                            
    1              0.000002 let s:hash_colors = {}
                            
    1              0.000001 function! fugitive#BlameSyntax() abort
                              let conceal = has('conceal') ? ' conceal' : ''
                              let flags = get(s:TempState(), 'blame_flags', [])
                              syn spell notoplevel
                              syn match FugitiveblameBlank                      "^\s\+\s\@=" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalFile,FugitiveblameOriginalLineNumber skipwhite
                              syn match FugitiveblameHash       "\%(^\^\=[?*]*\)\@<=\<\x\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              if s:HasOpt(flags, '-b') || FugitiveConfigGet('blame.blankBoundary') =~# '^1$\|^true$'
                                syn match FugitiveblameBoundaryIgnore "^\^[*?]*\x\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              else
                                syn match FugitiveblameBoundary "^\^"
                              endif
                              syn match FugitiveblameScoreDebug        " *\d\+\s\+\d\+\s\@=" nextgroup=FugitiveblameAnnotation,FugitiveblameOriginalLineNumber,fugitiveblameOriginalFile contained skipwhite
                              syn region FugitiveblameAnnotation matchgroup=FugitiveblameDelimiter start="(" end="\%(\s\d\+\)\@<=)" contained keepend oneline
                              syn match FugitiveblameTime "\<[0-9:/+-][0-9:/+ -]*[0-9:/+-]\%(\s\+\d\+)\)\@=" contained containedin=FugitiveblameAnnotation
                              exec 'syn match FugitiveblameLineNumber         "\s[[:digit:][:space:]]\{0,' . (len(line('$'))-1). '\}\d)\@=" contained containedin=FugitiveblameAnnotation' conceal
                              exec 'syn match FugitiveblameOriginalFile       "\s\%(\f\+\D\@<=\|\D\@=\f\+\)\%(\%(\s\+\d\+\)\=\s\%((\|\s*\d\+)\)\)\@=" contained nextgroup=FugitiveblameOriginalLineNumber,FugitiveblameAnnotation skipwhite' (s:HasOpt(flags, '--show-name', '-f') ? '' : conceal)
                              exec 'syn match FugitiveblameOriginalLineNumber "\s*\d\+\%(\s(\)\@=" contained nextgroup=FugitiveblameAnnotation skipwhite' (s:HasOpt(flags, '--show-number', '-n') ? '' : conceal)
                              exec 'syn match FugitiveblameOriginalLineNumber "\s*\d\+\%(\s\+\d\+)\)\@=" contained nextgroup=FugitiveblameShort skipwhite' (s:HasOpt(flags, '--show-number', '-n') ? '' : conceal)
                              syn match FugitiveblameShort              " \d\+)" contained contains=FugitiveblameLineNumber
                              syn match FugitiveblameNotCommittedYet "(\@<=Not Committed Yet\>" contained containedin=FugitiveblameAnnotation
                              hi def link FugitiveblameBoundary           Keyword
                              hi def link FugitiveblameHash               Identifier
                              hi def link FugitiveblameBoundaryIgnore     Ignore
                              hi def link FugitiveblameUncommitted        Ignore
                              hi def link FugitiveblameScoreDebug         Debug
                              hi def link FugitiveblameTime               PreProc
                              hi def link FugitiveblameLineNumber         Number
                              hi def link FugitiveblameOriginalFile       String
                              hi def link FugitiveblameOriginalLineNumber Float
                              hi def link FugitiveblameShort              FugitiveblameDelimiter
                              hi def link FugitiveblameDelimiter          Delimiter
                              hi def link FugitiveblameNotCommittedYet    Comment
                              if !get(g:, 'fugitive_dynamic_colors', 1) && !s:HasOpt(flags, '--color-lines') || s:HasOpt(flags, '--no-color-lines')
                                return
                              endif
                              let seen = {}
                              for lnum in range(1, line('$'))
                                let orig_hash = matchstr(getline(lnum), '^\^\=[*?]*\zs\x\{6\}')
                                let hash = orig_hash
                                let hash = substitute(hash, '\(\x\)\x', '\=submatch(1).printf("%x", 15-str2nr(submatch(1),16))', 'g')
                                let hash = substitute(hash, '\(\x\x\)', '\=printf("%02x", str2nr(submatch(1),16)*3/4+32)', 'g')
                                if hash ==# '' || orig_hash ==# '000000' || has_key(seen, hash)
                                  continue
                                endif
                                let seen[hash] = 1
                                if &t_Co == 256
                                  let [s, r, g, b; __] = map(matchlist(orig_hash, '\(\x\)\x\(\x\)\x\(\x\)\x'), 'str2nr(v:val,16)')
                                  let color = 16 + (r + 1) / 3 * 36 + (g + 1) / 3 * 6 + (b + 1) / 3
                                  if color == 16
                                    let color = 235
                                  elseif color == 231
                                    let color = 255
                                  endif
                                  let s:hash_colors[hash] = ' ctermfg='.color
                                else
                                  let s:hash_colors[hash] = ''
                                endif
                                let pattern = substitute(orig_hash, '^\(\x\)\x\(\x\)\x\(\x\)\x$', '\1\\x\2\\x\3\\x', '') . '*\>'
                                exe 'syn match FugitiveblameHash'.hash.'       "\%(^\^\=[*?]*\)\@<='.pattern.'" nextgroup=FugitiveblameAnnotation,FugitiveblameOriginalLineNumber,fugitiveblameOriginalFile skipwhite'
                              endfor
                              syn match FugitiveblameUncommitted "\%(^\^\=[?*]*\)\@<=\<0\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              call s:BlameRehighlight()
                            endfunction
                            
    1              0.000001 function! s:BlameRehighlight() abort
                              for [hash, cterm] in items(s:hash_colors)
                                if !empty(cterm) || has('gui_running') || has('termguicolors') && &termguicolors
                                  exe 'hi FugitiveblameHash'.hash.' guifg=#' . hash . cterm
                                else
                                  exe 'hi link FugitiveblameHash'.hash.' Identifier'
                                endif
                              endfor
                            endfunction
                            
    1              0.000001 function! fugitive#BlameFileType() abort
                              setlocal nomodeline
                              setlocal foldmethod=manual
                              if len(s:Dir())
                                let &l:keywordprg = s:Keywordprg()
                              endif
                              let b:undo_ftplugin = 'setl keywordprg= foldmethod<'
                              if exists('+concealcursor')
                                setlocal concealcursor=nc conceallevel=2
                                let b:undo_ftplugin .= ' concealcursor< conceallevel<'
                              endif
                              if &modifiable
                                return ''
                              endif
                              call s:Map('n', '<F1>', ':help :Git_blame<CR>', '<silent>')
                              call s:Map('n', 'g?',   ':help :Git_blame<CR>', '<silent>')
                              if mapcheck('q', 'n') =~# '^$\|bdelete'
                                call s:Map('n', 'q',  ':echoerr "fugitive: q removed in favor of gq (or :q)"<CR>', '<silent>')
                              endif
                              call s:Map('n', 'gq',   ':exe <SID>BlameQuit()<CR>', '<silent>')
                              call s:Map('n', '<2-LeftMouse>', ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', '<CR>', ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', '-',    ':<C-U>exe <SID>BlameJump("")<CR>', '<silent>')
                              call s:Map('n', 's',    ':<C-U>exe <SID>BlameJump("")<CR>', '<silent>')
                              call s:Map('n', 'u',    ':<C-U>exe <SID>BlameJump("")<CR>', '<silent>')
                              call s:Map('n', 'P',    ':<C-U>exe <SID>BlameJump("^".v:count1)<CR>', '<silent>')
                              call s:Map('n', '~',    ':<C-U>exe <SID>BlameJump("~".v:count1)<CR>', '<silent>')
                              call s:Map('n', 'i',    ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', 'o',    ':<C-U>exe <SID>BlameCommit("split")<CR>', '<silent>')
                              call s:Map('n', 'O',    ':<C-U>exe <SID>BlameCommit("tabedit")<CR>', '<silent>')
                              call s:Map('n', 'p',    ':<C-U>exe <SID>BlameCommit("pedit")<CR>', '<silent>')
                              call s:Map('n', '.',    ":<C-U> <C-R>=substitute(<SID>BlameCommitFileLnum()[0],'^$','@','')<CR><Home>")
                              call s:Map('n', '(',    "-")
                              call s:Map('n', ')',    "+")
                              call s:Map('n', 'A',    ":<C-u>exe 'vertical resize '.(<SID>linechars('.\\{-\\}\\ze [0-9:/+-][0-9:/+ -]* \\d\\+)')+1+v:count)<CR>", '<silent>')
                              call s:Map('n', 'C',    ":<C-u>exe 'vertical resize '.(<SID>linechars('^\\S\\+')+1+v:count)<CR>", '<silent>')
                              call s:Map('n', 'D',    ":<C-u>exe 'vertical resize '.(<SID>linechars('.\\{-\\}\\ze\\d\\ze\\s\\+\\d\\+)')+1-v:count)<CR>", '<silent>')
                            endfunction
                            
    1              0.000001 augroup fugitive_blame
    1              0.000045   autocmd!
    1              0.000009   autocmd ColorScheme,GUIEnter * call s:BlameRehighlight()
    1              0.000002   autocmd BufWinLeave * execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
    1              0.000001 augroup END
                            
                            " Section: :GBrowse
                            
    1              0.000002 function! s:BrowserOpen(url, mods, echo_copy) abort
                              let url = substitute(a:url, '[ <>\|"]', '\="%".printf("%02X",char2nr(submatch(0)))', 'g')
                              let mods = s:Mods(a:mods)
                              if a:echo_copy
                                if has('clipboard')
                                  let @+ = url
                                endif
                                return 'echo '.string(url)
                              elseif exists(':Browse') == 2
                                return 'echo '.string(url).'|' . mods . 'Browse '.url
                              elseif exists(':OpenBrowser') == 2
                                return 'echo '.string(url).'|' . mods . 'OpenBrowser '.url
                              else
                                if !exists('g:loaded_netrw')
                                  runtime! autoload/netrw.vim
                                endif
                                if exists('*netrw#BrowseX')
                                  return 'echo '.string(url).'|' . mods . 'call netrw#BrowseX('.string(url).', 0)'
                                elseif exists('*netrw#NetrwBrowseX')
                                  return 'echo '.string(url).'|' . mods . 'call netrw#NetrwBrowseX('.string(url).', 0)'
                                else
                                  return 'echoerr ' . string('Netrw not found. Define your own :Browse to use :GBrowse')
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! fugitive#BrowseCommand(line1, count, range, bang, mods, arg, args) abort
                              exe s:VersionCheck()
                              let dir = s:Dir()
                              try
                                let arg = a:arg
                                if arg =~# '^++\%([Gg]it\)\=[Rr]emote='
                                  let remote = matchstr(arg, '^++\%([Gg]it\)\=[Rr]emote=\zs\S\+')
                                  let arg = matchstr(arg, '\s\zs\S.*')
                                endif
                                let validremote = '\.\%(git\)\=\|\.\=/.*\|[[:alnum:]_-]\+\%(://.\{-\}\)\='
                                if arg ==# '-'
                                  let remote = ''
                                  let rev = ''
                                  let result = fugitive#Result()
                                  if filereadable(get(result, 'file', ''))
                                    let rev = s:fnameescape(result.file)
                                  else
                                    return 'echoerr ' . string('fugitive: could not find prior :Git invocation')
                                  endif
                                elseif !exists('l:remote')
                                  let remote = matchstr(arg, '@\zs\%('.validremote.'\)$')
                                  let rev = substitute(arg, '@\%('.validremote.'\)$','','')
                                else
                                  let rev = arg
                                endif
                                if rev =~? '^\a\a\+:[\/][\/]' && rev !~? '^fugitive:'
                                  let rev = substitute(rev, '\\\@<![#!]\|\\\@<!%\ze\w', '\\&', 'g')
                                elseif rev ==# ':'
                                  let rev = ''
                                endif
                                let expanded = s:Expand(rev)
                                if expanded =~? '^\a\a\+:[\/][\/]' && expanded !~? '^fugitive:'
                                  return s:BrowserOpen(s:Slash(expanded), a:mods, a:bang)
                                endif
                                if !exists('l:result')
                                  let result = s:TempState(empty(expanded) ? @% : expanded)
                                endif
                                if !empty(result) && filereadable(get(result, 'file', ''))
                                  for line in readfile(result.file, '', 4096)
                                    let rev = s:fnameescape(matchstr(line, '\<https\=://[^[:space:]<>]*[^[:space:]<>.,;:"''!?]'))
                                    if len(rev)
                                      break
                                    endif
                                  endfor
                                  if empty(rev)
                                    return 'echoerr ' . string('fugitive: no URL found in output of :Git')
                                  endif
                                endif
                                exe s:DirCheck(dir)
                                if empty(expanded)
                                  let bufname = s:BufName('%')
                                  let expanded = s:DirRev(bufname)[1]
                                  if empty(expanded)
                                    let expanded = fugitive#Path(bufname, ':(top)', dir)
                                  endif
                                  if a:count > 0 && bufname !=# bufname('')
                                    let blame = s:BlameCommitFileLnum(getline(a:count))
                                    if len(blame[0])
                                      let expanded = blame[0]
                                    endif
                                  endif
                                endif
                                let refdir = fugitive#Find('.git/refs', dir)
                                for subdir in ['tags/', 'heads/', 'remotes/']
                                  if expanded !~# '^[./]' && filereadable(refdir . '/' . subdir . expanded)
                                    let expanded = '.git/refs/' . subdir . expanded
                                  endif
                                endfor
                                let full = s:Generate(expanded, dir)
                                let commit = ''
                                if full =~? '^fugitive:'
                                  let [dir, commit, path] = s:DirCommitFile(full)
                                  if commit =~# '^:\=\d$'
                                    let commit = ''
                                  endif
                                  if commit =~ '..'
                                    let type = s:TreeChomp(['cat-file','-t',commit.s:sub(path,'^/',':')], dir)
                                    let branch = matchstr(expanded, '^[^:]*')
                                  elseif empty(path) || path ==# '/'
                                    let type = 'tree'
                                  else
                                    let type = 'blob'
                                  endif
                                  let path = path[1:-1]
                                elseif empty(s:Tree(dir))
                                  let path = '.git/' . full[strlen(dir)+1:-1]
                                  let type = ''
                                else
                                  let path = fugitive#Path(full, '/')[1:-1]
                                  if path =~# '^\.git/'
                                    let type = ''
                                  elseif isdirectory(full) || empty(path)
                                    let type = 'tree'
                                  else
                                    let type = 'blob'
                                  endif
                                endif
                                if type ==# 'tree' && !empty(path)
                                  let path = s:sub(path, '/\=$', '/')
                                endif
                                let actual_dir = fugitive#Find('.git/', dir)
                                if path =~# '^\.git/.*HEAD$' && filereadable(actual_dir . path[5:-1])
                                  let body = readfile(actual_dir . path[5:-1])[0]
                                  if body =~# '^\x\{40,\}$'
                                    let commit = body
                                    let type = 'commit'
                                    let path = ''
                                  elseif body =~# '^ref: refs/'
                                    let path = '.git/' . matchstr(body,'ref: \zs.*')
                                  endif
                                endif
                            
                                let merge = ''
                                if path =~# '^\.git/refs/remotes/.'
                                  if empty(remote)
                                    let remote = matchstr(path, '^\.git/refs/remotes/\zs[^/]\+')
                                    let branch = matchstr(path, '^\.git/refs/remotes/[^/]\+/\zs.\+')
                                  else
                                    let merge = matchstr(path, '^\.git/refs/remotes/[^/]\+/\zs.\+')
                                    let branch = merge
                                    let path = '.git/refs/heads/'.merge
                                  endif
                                elseif path =~# '^\.git/refs/heads/.'
                                  let branch = path[16:-1]
                                elseif !exists('branch')
                                  let branch = FugitiveHead(0, dir)
                                endif
                                if !empty(branch)
                                  let r = FugitiveConfigGet('branch.'.branch.'.remote', dir)
                                  let m = FugitiveConfigGet('branch.'.branch.'.merge', dir)[11:-1]
                                  if r ==# '.' && !empty(m)
                                    let r2 = FugitiveConfigGet('branch.'.m.'.remote', dir)
                                    if r2 !~# '^\.\=$'
                                      let r = r2
                                      let m = FugitiveConfigGet('branch.'.m.'.merge', dir)[11:-1]
                                    endif
                                  endif
                                  if empty(remote)
                                    let remote = r
                                  endif
                                  if r ==# '.' || r ==# remote
                                    let remote_ref = 'refs/remotes/' . remote . '/' . branch
                                    if FugitiveConfigGet('push.default', dir) ==# 'upstream' ||
                                          \ !filereadable(FugitiveFind('.git/' . remote_ref, dir)) && empty(s:ChompDefault('', ['rev-parse', '--verify', remote_ref, '--'], dir))
                                      let merge = m
                                      if path =~# '^\.git/refs/heads/.'
                                        let path = '.git/refs/heads/'.merge
                                      endif
                                    else
                                      let merge = branch
                                    endif
                                  endif
                                endif
                            
                                let line1 = a:count > 0 && type ==# 'blob' ? a:line1 : 0
                                let line2 = a:count > 0 && type ==# 'blob' ? a:count : 0
                                if empty(commit) && path !~# '^\.git/'
                                  if a:count < 0 && !empty(merge)
                                    let commit = merge
                                  else
                                    let commit = ''
                                    if len(merge)
                                      let owner = s:Owner(@%, dir)
                                      let commit = s:ChompDefault('', ['merge-base', 'refs/remotes/' . remote . '/' . merge, empty(owner) ? '@' : owner, '--'], dir)
                                      if line2 > 0 && empty(arg) && commit =~# '^\x\{40,\}$'
                                        let blame_list = tempname()
                                        call writefile([commit, ''], blame_list, 'b')
                                        let blame_in = tempname()
                                        silent exe 'noautocmd keepalt %write' blame_in
                                        let [blame, exec_error] = s:LinesError(['-c', 'blame.coloring=none', 'blame', '--contents', blame_in, '-L', line1.','.line2, '-S', blame_list, '-s', '--show-number', './' . path], dir)
                                        if !exec_error
                                          let blame_regex = '^\^\x\+\s\+\zs\d\+\ze\s'
                                          if get(blame, 0) =~# blame_regex && get(blame, -1) =~# blame_regex
                                            let line1 = +matchstr(blame[0], blame_regex)
                                            let line2 = +matchstr(blame[-1], blame_regex)
                                          else
                                            throw "fugitive: can't browse to uncommitted change"
                                          endif
                                        endif
                                      endif
                                    endif
                                  endif
                                  if empty(commit)
                                    let commit = readfile(fugitive#Find('.git/HEAD', dir), '', 1)[0]
                                  endif
                                  let i = 0
                                  while commit =~# '^ref: ' && i < 10
                                    let ref_file = refdir[0 : -5] . commit[5:-1]
                                    if getfsize(ref_file) > 0
                                      let commit = readfile(ref_file, '', 1)[0]
                                    else
                                      let commit = fugitive#RevParse(commit[5:-1], dir)
                                    endif
                                    let i -= 1
                                  endwhile
                                endif
                            
                                if empty(remote) || remote ==# '.'
                                  let remote = s:Remote(dir)
                                endif
                                if remote =~# ':'
                                  let remote_url = remote
                                else
                                  let remote_url = fugitive#RemoteUrl(remote, dir)
                                endif
                                let raw = empty(remote_url) ? remote : remote_url
                                let git_dir = s:GitDir(dir)
                            
                                let opts = {
                                      \ 'git_dir': git_dir,
                                      \ 'repo': {'git_dir': git_dir},
                                      \ 'remote': raw,
                                      \ 'remote_name': remote,
                                      \ 'commit': commit,
                                      \ 'path': path,
                                      \ 'type': type,
                                      \ 'line1': line1,
                                      \ 'line2': line2}
                            
                                let url = ''
                                for Handler in get(g:, 'fugitive_browse_handlers', [])
                                  let url = call(Handler, [copy(opts)])
                                  if !empty(url)
                                    break
                                  endif
                                endfor
                            
                                if empty(url)
                                  throw "fugitive: no GBrowse handler installed for '".raw."'"
                                endif
                            
                                return s:BrowserOpen(url, a:mods, a:bang)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
                            " Section: Go to file
                            
    1              0.000004 let s:ref_header = '\%(Merge\|Rebase\|Upstream\|Pull\|Push\)'
                            
    1              0.000028 nnoremap <SID>: :<C-U><C-R>=v:count ? v:count : ''<CR>
    1              0.000001 function! fugitive#MapCfile(...) abort
                              exe 'cnoremap <buffer> <expr> <Plug><cfile>' (a:0 ? a:1 : 'fugitive#Cfile()')
                              let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|sil! exe "cunmap <buffer> <Plug><cfile>"'
                              if !exists('g:fugitive_no_maps')
                                call s:Map('n', 'gf',          '<SID>:find <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W>f',     '<SID>:sfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W><C-F>', '<SID>:sfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W>gf',  '<SID>:tabfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('c', '<C-R><C-F>', '<Plug><cfile>', '<silent><unique>', 1)
                              endif
                            endfunction
                            
    1              0.000001 function! s:ContainingCommit() abort
                              let commit = s:Owner(@%)
                              return empty(commit) ? '@' : commit
                            endfunction
                            
    1              0.000001 function! s:SquashArgument(...) abort
                              if &filetype == 'fugitive'
                                let commit = matchstr(getline('.'), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\{4,\}\ze \|^' . s:ref_header . ': \zs\S\+')
                              elseif has_key(s:temp_files, s:cpath(expand('%:p')))
                                let commit = matchstr(getline('.'), '\S\@<!\x\{4,\}\>')
                              else
                                let commit = s:Owner(@%)
                              endif
                              return len(commit) && a:0 ? printf(a:1, commit) : commit
                            endfunction
                            
    1              0.000001 function! s:RebaseArgument() abort
                              return s:SquashArgument(' %s^')
                            endfunction
                            
    1              0.000001 function! s:NavigateUp(count) abort
                              let rev = substitute(s:DirRev(@%)[1], '^$', ':', 'g')
                              let c = a:count
                              while c
                                if rev =~# ':.*/.'
                                  let rev = matchstr(rev, '.*\ze/.\+', '')
                                elseif rev =~# '.:.'
                                  let rev = matchstr(rev, '^.[^:]*:')
                                elseif rev =~# '^:'
                                  let rev = '@^{}'
                                elseif rev =~# ':$'
                                  let rev = rev[0:-2]
                                else
                                  return rev.'~'.c
                                endif
                                let c -= 1
                              endwhile
                              return rev
                            endfunction
                            
    1              0.000001 function! s:MapMotion(lhs, rhs) abort
                              let maps = [
                                    \ s:Map('n', a:lhs, ":<C-U>" . a:rhs . "<CR>", "<silent>"),
                                    \ s:Map('o', a:lhs, ":<C-U>" . a:rhs . "<CR>", "<silent>"),
                                    \ s:Map('x', a:lhs, ":<C-U>exe 'normal! gv'<Bar>" . a:rhs . "<CR>", "<silent>")]
                              call filter(maps, '!empty(v:val)')
                              return join(maps, '|')
                            endfunction
                            
    1              0.000001 function! fugitive#MapJumps(...) abort
                              if !&modifiable
                                if get(b:, 'fugitive_type', '') ==# 'blob'
                                  let blame_map = 'Git blame<C-R>=v:count ? " --reverse" : ""<CR><CR>'
                                  call s:Map('n', '<2-LeftMouse>', ':<C-U>0,1' . blame_map, '<silent>')
                                  call s:Map('n', '<CR>', ':<C-U>0,1' . blame_map, '<silent>')
                                  call s:Map('n', 'o',    ':<C-U>0,2' . blame_map, '<silent>')
                                  call s:Map('n', 'p',    ':<C-U>0,3' . blame_map, '<silent>')
                                  call s:Map('n', 'gO',   ':<C-U>0,4' . blame_map, '<silent>')
                                  call s:Map('n', 'O',    ':<C-U>0,5' . blame_map, '<silent>')
                            
                                  call s:Map('n', 'D', ":echoerr 'fugitive: D has been removed in favor of dd'<CR>", '<silent><unique>')
                                  call s:Map('n', 'dd', ":<C-U>call fugitive#DiffClose()<Bar>Gdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'dh', ":<C-U>call fugitive#DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'ds', ":<C-U>call fugitive#DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'dv', ":<C-U>call fugitive#DiffClose()<Bar>Gvdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'd?', ":<C-U>help fugitive_d<CR>", '<silent>')
                            
                                else
                                  call s:Map('n', '<2-LeftMouse>', ':<C-U>exe <SID>GF("edit")<CR>', '<silent>')
                                  call s:Map('n', '<CR>', ':<C-U>exe <SID>GF("edit")<CR>', '<silent>')
                                  call s:Map('n', 'o',    ':<C-U>exe <SID>GF("split")<CR>', '<silent>')
                                  call s:Map('n', 'gO',   ':<C-U>exe <SID>GF("vsplit")<CR>', '<silent>')
                                  call s:Map('n', 'O',    ':<C-U>exe <SID>GF("tabedit")<CR>', '<silent>')
                                  call s:Map('n', 'p',    ':<C-U>exe <SID>GF("pedit")<CR>', '<silent>')
                            
                                  if !exists('g:fugitive_no_maps')
                                    call s:Map('n', '<C-P>', ':exe <SID>PreviousItem(v:count1)<Bar>echohl WarningMsg<Bar>echo "CTRL-P is deprecated in favor of ("<Bar>echohl NONE<CR>', '<unique>')
                                    call s:Map('n', '<C-N>', ':exe <SID>NextItem(v:count1)<Bar>echohl WarningMsg<Bar>echo "CTRL-N is deprecated in favor of )"<Bar>echohl NONE<CR>', '<unique>')
                                  endif
                                  call s:MapMotion('(', 'exe <SID>PreviousItem(v:count1)')
                                  call s:MapMotion(')', 'exe <SID>NextItem(v:count1)')
                                  call s:MapMotion('K', 'exe <SID>PreviousHunk(v:count1)')
                                  call s:MapMotion('J', 'exe <SID>NextHunk(v:count1)')
                                  call s:MapMotion('[c', 'exe <SID>PreviousHunk(v:count1)')
                                  call s:MapMotion(']c', 'exe <SID>NextHunk(v:count1)')
                                  call s:MapMotion('[/', 'exe <SID>PreviousFile(v:count1)')
                                  call s:MapMotion(']/', 'exe <SID>NextFile(v:count1)')
                                  call s:MapMotion('[m', 'exe <SID>PreviousFile(v:count1)')
                                  call s:MapMotion(']m', 'exe <SID>NextFile(v:count1)')
                                  call s:MapMotion('[[', 'exe <SID>PreviousSection(v:count1)')
                                  call s:MapMotion(']]', 'exe <SID>NextSection(v:count1)')
                                  call s:MapMotion('[]', 'exe <SID>PreviousSectionEnd(v:count1)')
                                  call s:MapMotion('][', 'exe <SID>NextSectionEnd(v:count1)')
                                  call s:Map('nxo', '*', '<SID>PatchSearchExpr(0)', '<expr>')
                                  call s:Map('nxo', '#', '<SID>PatchSearchExpr(1)', '<expr>')
                                endif
                                call s:Map('n', 'S',    ':<C-U>echoerr "Use gO"<CR>', '<silent><unique>')
                                call s:Map('n', 'dq', ":<C-U>call fugitive#DiffClose()<CR>", '<silent>')
                                call s:Map('n', '-', ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>NavigateUp(v:count1))<Bar> if getline(1) =~# '^tree \x\{40,\}$' && empty(getline(2))<Bar>call search('^'.escape(expand('#:t'),'.*[]~\').'/\=$','wc')<Bar>endif<CR>", '<silent>')
                                call s:Map('n', 'P',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit().'^'.v:count1.<SID>Relative(':'))<CR>", '<silent>')
                                call s:Map('n', '~',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit().'~'.v:count1.<SID>Relative(':'))<CR>", '<silent>')
                                call s:Map('n', 'C',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'cp',    ":<C-U>echoerr 'Use gC'<CR>", '<silent><unique>')
                                call s:Map('n', 'gC',    ":<C-U>exe 'Gpedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'gc',    ":<C-U>exe 'Gpedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'gi',    ":<C-U>exe 'Gsplit' (v:count ? '.gitignore' : '.git/info/exclude')<CR>", '<silent>')
                                call s:Map('x', 'gi',    ":<C-U>exe 'Gsplit' (v:count ? '.gitignore' : '.git/info/exclude')<CR>", '<silent>')
                            
                                call s:Map('n', 'c<Space>', ':Git commit<Space>')
                                call s:Map('n', 'c<CR>', ':Git commit<CR>')
                                call s:Map('n', 'cv<Space>', ':tab Git commit -v<Space>')
                                call s:Map('n', 'cv<CR>', ':tab Git commit -v<CR>')
                                call s:Map('n', 'ca', ':<C-U>Git commit --amend<CR>', '<silent>')
                                call s:Map('n', 'cc', ':<C-U>Git commit<CR>', '<silent>')
                                call s:Map('n', 'ce', ':<C-U>Git commit --amend --no-edit<CR>', '<silent>')
                                call s:Map('n', 'cw', ':<C-U>Git commit --amend --only<CR>', '<silent>')
                                call s:Map('n', 'cva', ':<C-U>tab Git commit -v --amend<CR>', '<silent>')
                                call s:Map('n', 'cvc', ':<C-U>tab Git commit -v<CR>', '<silent>')
                                call s:Map('n', 'cRa', ':<C-U>Git commit --reset-author --amend<CR>', '<silent>')
                                call s:Map('n', 'cRe', ':<C-U>Git commit --reset-author --amend --no-edit<CR>', '<silent>')
                                call s:Map('n', 'cRw', ':<C-U>Git commit --reset-author --amend --only<CR>', '<silent>')
                                call s:Map('n', 'cf', ':<C-U>Git commit --fixup=<C-R>=<SID>SquashArgument()<CR>')
                                call s:Map('n', 'cF', ':<C-U><Bar>Git -c sequence.editor=true rebase --interactive --autosquash<C-R>=<SID>RebaseArgument()<CR><Home>Git commit --fixup=<C-R>=<SID>SquashArgument()<CR>')
                                call s:Map('n', 'cs', ':<C-U>Git commit --no-edit --squash=<C-R>=<SID>SquashArgument()<CR>')
                                call s:Map('n', 'cS', ':<C-U><Bar>Git -c sequence.editor=true rebase --interactive --autosquash<C-R>=<SID>RebaseArgument()<CR><Home>Git commit --no-edit --squash=<C-R>=<SID>SquashArgument()<CR>')
                                call s:Map('n', 'cA', ':<C-U>Git commit --edit --squash=<C-R>=<SID>SquashArgument()<CR>')
                                call s:Map('n', 'c?', ':<C-U>help fugitive_c<CR>', '<silent>')
                            
                                call s:Map('n', 'cr<Space>', ':Git revert<Space>')
                                call s:Map('n', 'cr<CR>', ':Git revert<CR>')
                                call s:Map('n', 'crc', ':<C-U>Git revert <C-R>=<SID>SquashArgument()<CR><CR>', '<silent>')
                                call s:Map('n', 'crn', ':<C-U>Git revert --no-commit <C-R>=<SID>SquashArgument()<CR><CR>', '<silent>')
                                call s:Map('n', 'cr?', ':<C-U>help fugitive_cr<CR>', '<silent>')
                            
                                call s:Map('n', 'cm<Space>', ':Git merge<Space>')
                                call s:Map('n', 'cm<CR>', ':Git merge<CR>')
                                call s:Map('n', 'cmt', ':Git mergetool')
                                call s:Map('n', 'cm?', ':<C-U>help fugitive_cm<CR>', '<silent>')
                            
                                call s:Map('n', 'cz<Space>', ':Git stash<Space>')
                                call s:Map('n', 'cz<CR>', ':Git stash<CR>')
                                call s:Map('n', 'cza', ':<C-U>Git stash apply --quiet --index stash@{<C-R>=v:count<CR>}<CR>')
                                call s:Map('n', 'czA', ':<C-U>Git stash apply --quiet stash@{<C-R>=v:count<CR>}<CR>')
                                call s:Map('n', 'czp', ':<C-U>Git stash pop --quiet --index stash@{<C-R>=v:count<CR>}<CR>')
                                call s:Map('n', 'czP', ':<C-U>Git stash pop --quiet stash@{<C-R>=v:count<CR>}<CR>')
                                call s:Map('n', 'czv', ':<C-U>exe "Gedit" fugitive#RevParse("stash@{" . v:count . "}")<CR>', '<silent>')
                                call s:Map('n', 'czw', ':<C-U>Git stash --keep-index<C-R>=v:count > 1 ? " --all" : v:count ? " --include-untracked" : ""<CR><CR>')
                                call s:Map('n', 'czz', ':<C-U>Git stash <C-R>=v:count > 1 ? " --all" : v:count ? " --include-untracked" : ""<CR><CR>')
                                call s:Map('n', 'cz?', ':<C-U>help fugitive_cz<CR>', '<silent>')
                            
                                call s:Map('n', 'co<Space>', ':Git checkout<Space>')
                                call s:Map('n', 'co<CR>', ':Git checkout<CR>')
                                call s:Map('n', 'coo', ':<C-U>Git checkout <C-R>=substitute(<SID>SquashArgument(),"^$",get(<SID>TempState(),"filetype","") ==# "git" ? expand("<cfile>") : "","")<CR> --<CR>')
                                call s:Map('n', 'co?', ':<C-U>help fugitive_co<CR>', '<silent>')
                            
                                call s:Map('n', 'cb<Space>', ':Git branch<Space>')
                                call s:Map('n', 'cb<CR>', ':Git branch<CR>')
                                call s:Map('n', 'cb?', ':<C-U>help fugitive_cb<CR>', '<silent>')
                            
                                call s:Map('n', 'r<Space>', ':Git rebase<Space>')
                                call s:Map('n', 'r<CR>', ':Git rebase<CR>')
                                call s:Map('n', 'ri', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><CR>', '<silent>')
                                call s:Map('n', 'rf', ':<C-U>Git -c sequence.editor=true rebase --interactive --autosquash<C-R>=<SID>RebaseArgument()<CR><CR>', '<silent>')
                                call s:Map('n', 'ru', ':<C-U>Git rebase --interactive @{upstream}<CR>', '<silent>')
                                call s:Map('n', 'rp', ':<C-U>Git rebase --interactive @{push}<CR>', '<silent>')
                                call s:Map('n', 'rw', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/reword/e<CR>', '<silent>')
                                call s:Map('n', 'rm', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/edit/e<CR>', '<silent>')
                                call s:Map('n', 'rd', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>', '<silent>')
                                call s:Map('n', 'rk', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>', '<silent>')
                                call s:Map('n', 'rx', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>', '<silent>')
                                call s:Map('n', 'rr', ':<C-U>Git rebase --continue<CR>', '<silent>')
                                call s:Map('n', 'rs', ':<C-U>Git rebase --skip<CR>', '<silent>')
                                call s:Map('n', 're', ':<C-U>Git rebase --edit-todo<CR>', '<silent>')
                                call s:Map('n', 'ra', ':<C-U>Git rebase --abort<CR>', '<silent>')
                                call s:Map('n', 'r?', ':<C-U>help fugitive_r<CR>', '<silent>')
                            
                                call s:Map('n', '.',     ":<C-U> <C-R>=<SID>fnameescape(fugitive#Real(@%))<CR><Home>")
                                call s:Map('x', '.',     ":<C-U> <C-R>=<SID>fnameescape(fugitive#Real(@%))<CR><Home>")
                                call s:Map('n', 'g?',    ":<C-U>help fugitive-map<CR>", '<silent>')
                                call s:Map('n', '<F1>',  ":<C-U>help fugitive-map<CR>", '<silent>')
                              endif
                            
                              let old_browsex = maparg('<Plug>NetrwBrowseX', 'n')
                              let new_browsex = substitute(old_browsex, '\Cnetrw#CheckIfRemote(\%(netrw#GX()\)\=)', '0', 'g')
                              let new_browsex = substitute(new_browsex, 'netrw#GX()\|expand((exists("g:netrw_gx")? g:netrw_gx : ''<cfile>''))', 'fugitive#GX()', 'g')
                              if new_browsex !=# old_browsex
                                exe 'nnoremap <silent> <buffer> <Plug>NetrwBrowseX' new_browsex
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#GX() abort
                              try
                                let results = &filetype ==# 'fugitive' ? s:CfilePorcelain() : &filetype ==# 'git' ? s:cfile() : []
                                if len(results) && len(results[0])
                                  return FugitiveReal(s:Generate(results[0]))
                                endif
                              catch /^fugitive:/
                              endtry
                              return expand(get(g:, 'netrw_gx', expand('<cfile>')))
                            endfunction
                            
    1              0.000001 function! s:CfilePorcelain(...) abort
                              let tree = s:Tree()
                              if empty(tree)
                                return ['']
                              endif
                              let lead = s:cpath(tree, getcwd()) ? './' : tree . '/'
                              let info = s:StageInfo()
                              let line = getline('.')
                              if len(info.sigil) && len(info.section) && len(info.paths)
                                if info.section ==# 'Unstaged' && info.sigil !=# '-'
                                  return [lead . info.relative[0], info.offset, 'normal!zv']
                                elseif info.section ==# 'Staged' && info.sigil ==# '-'
                                  return ['@:' . info.relative[0], info.offset, 'normal!zv']
                                else
                                  return [':0:' . info.relative[0], info.offset, 'normal!zv']
                                endif
                              elseif len(info.paths)
                                return [lead . info.relative[0]]
                              elseif len(info.commit)
                                return [info.commit]
                              elseif line =~# '^' . s:ref_header . ': \|^Head: '
                                return [matchstr(line, ' \zs.*')]
                              else
                                return ['']
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#PorcelainCfile() abort
                              let file = fugitive#Find(s:CfilePorcelain()[0])
                              return empty(file) ? fugitive#Cfile() : s:fnameescape(file)
                            endfunction
                            
    1              0.000001 function! s:StatusCfile(...) abort
                              let tree = s:Tree()
                              if empty(tree)
                                return ''
                              endif
                              let lead = s:cpath(tree, getcwd()) ? './' : tree . '/'
                              if getline('.') =~# '^.\=\trenamed:.* -> '
                                return [lead . matchstr(getline('.'),' -> \zs.*')]
                              elseif getline('.') =~# '^.\=\t\(\k\| \)\+\p\?: *.'
                                return [lead . matchstr(getline('.'),': *\zs.\{-\}\ze\%( ([^()[:digit:]]\+)\)\=$')]
                              elseif getline('.') =~# '^.\=\t.'
                                return [lead . matchstr(getline('.'),'\t\zs.*')]
                              elseif getline('.') =~# ': needs merge$'
                                return [lead . matchstr(getline('.'),'.*\ze: needs merge$')]
                              elseif getline('.') =~# '^\%(. \)\=Not currently on any branch.$'
                                return ['HEAD']
                              elseif getline('.') =~# '^\%(. \)\=On branch '
                                return ['refs/heads/'.getline('.')[12:]]
                              elseif getline('.') =~# "^\\%(. \\)\=Your branch .*'"
                                return [matchstr(getline('.'),"'\\zs\\S\\+\\ze'")]
                              else
                                return []
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#MessageCfile() abort
                              let file = fugitive#Find(get(s:StatusCfile(), 0, ''))
                              return empty(file) ? fugitive#Cfile() : s:fnameescape(file)
                            endfunction
                            
    1              0.000001 function! s:cfile() abort
                              let temp_state = s:TempState()
                              let name = substitute(get(get(temp_state, 'args', []), 0, ''), '\%(^\|-\)\(\l\)', '\u\1', 'g')
                              if exists('*s:' . name . 'Cfile')
                                return s:{name}Cfile(temp_state)
                              endif
                              if empty(FugitiveGitDir())
                                return []
                              endif
                              try
                                let myhash = s:DirRev(@%)[1]
                                if len(myhash)
                                  try
                                    let myhash = fugitive#RevParse(myhash)
                                  catch /^fugitive:/
                                    let myhash = ''
                                  endtry
                                endif
                                if empty(myhash) && get(temp_state, 'filetype', '') ==# 'git'
                                  let lnum = line('.')
                                  while lnum > 0
                                    if getline(lnum) =~# '^\%(commit\|tag\) \w'
                                      let myhash = matchstr(getline(lnum),'^\w\+ \zs\S\+')
                                      break
                                    endif
                                    let lnum -= 1
                                  endwhile
                                endif
                            
                                let showtree = (getline(1) =~# '^tree ' && getline(2) == "")
                            
                                let treebase = substitute(s:DirCommitFile(@%)[1], '^\d$', ':&', '') . ':' .
                                      \ s:Relative('') . (s:Relative('') =~# '^$\|/$' ? '' : '/')
                            
                                if getline('.') =~# '^\d\{6\} \l\{3,8\} \x\{40,\}\t'
                                  return [treebase . s:sub(matchstr(getline('.'),'\t\zs.*'),'/$','')]
                                elseif showtree
                                  return [treebase . s:sub(getline('.'),'/$','')]
                            
                                else
                            
                                  let dcmds = []
                            
                                  " Index
                                  if getline('.') =~# '^\d\{6\} \x\{40,\} \d\t'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let file = ':'.s:sub(matchstr(getline('.'),'\d\t.*'),'\t',':')
                                    return [file]
                                  endif
                            
                                  if getline('.') =~# '^ref: '
                                    let ref = strpart(getline('.'),5)
                            
                                  elseif getline('.') =~# '^\%([|/\\_ ]*\*[|/\\_ ]*\)\=commit \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    return [ref]
                            
                                  elseif getline('.') =~# '^parent \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let line = line('.')
                                    let parent = 0
                                    while getline(line) =~# '^parent '
                                      let parent += 1
                                      let line -= 1
                                    endwhile
                                    return [ref]
                            
                                  elseif getline('.') =~# '^tree \x\{40,\}$'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    if len(myhash) && fugitive#RevParse(myhash.':') ==# ref
                                      let ref = myhash.':'
                                    endif
                                    return [ref]
                            
                                  elseif getline('.') =~# '^object \x\{40,\}$' && getline(line('.')+1) =~ '^type \%(commit\|tree\|blob\)$'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let type = matchstr(getline(line('.')+1),'type \zs.*')
                            
                                  elseif getline('.') =~# '^\l\{3,8\} '.myhash.'$'
                                    let ref = s:DirRev(@%)[1]
                            
                                  elseif getline('.') =~# '^\l\{3,8\} \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    echoerr "warning: unknown context ".matchstr(getline('.'),'^\l*')
                            
                                  elseif getline('.') =~# '^[+-]\{3\} [abciow12]\=/'
                                    let ref = getline('.')[4:]
                            
                                  elseif getline('.') =~# '^[+-]' && search('^@@ -\d\+\%(,\d\+\)\= +\d\+','bnW')
                                    let type = getline('.')[0]
                                    let lnum = line('.') - 1
                                    let offset = 0
                                    while getline(lnum) !~# '^@@ -\d\+\%(,\d\+\)\= +\d\+'
                                      if getline(lnum) =~# '^[ '.type.']'
                                        let offset += 1
                                      endif
                                      let lnum -= 1
                                    endwhile
                                    let offset += matchstr(getline(lnum), type.'\zs\d\+')
                                    let ref = getline(search('^'.type.'\{3\} [abciow12]/','bnW'))[4:-1]
                                    let dcmds = [offset, 'normal!zv']
                            
                                  elseif getline('.') =~# '^rename from '
                                    let ref = 'a/'.getline('.')[12:]
                                  elseif getline('.') =~# '^rename to '
                                    let ref = 'b/'.getline('.')[10:]
                            
                                  elseif getline('.') =~# '^@@ -\d\+\%(,\d\+\)\= +\d\+'
                                    let diff = getline(search('^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)', 'bcnW'))
                                    let offset = matchstr(getline('.'), '+\zs\d\+')
                            
                                    let dref = matchstr(diff, '\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(diff, '\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit! +'.offset
                            
                                  elseif getline('.') =~# '^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)'
                                    let dref = matchstr(getline('.'),'\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(getline('.'),'\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit!'
                            
                                  elseif getline('.') =~# '^index ' && getline(line('.')-1) =~# '^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)'
                                    let line = getline(line('.')-1)
                                    let dref = matchstr(line,'\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(line,'\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit!'
                            
                                  elseif line('$') == 1 && getline('.') =~ '^\x\{40,\}$'
                                    let ref = getline('.')
                            
                                  elseif expand('<cword>') =~# '^\x\{7,\}\>'
                                    return [expand('<cword>')]
                            
                                  else
                                    let ref = ''
                                  endif
                            
                                  let prefixes = {
                                        \ '1': '',
                                        \ '2': '',
                                        \ 'b': ':0:',
                                        \ 'i': ':0:',
                                        \ 'o': '',
                                        \ 'w': ''}
                            
                                  if len(myhash)
                                    let prefixes.a = myhash.'^:'
                                    let prefixes.b = myhash.':'
                                  endif
                                  let ref = substitute(ref, '^\(\w\)/', '\=get(prefixes, submatch(1), "@:")', '')
                                  if exists('dref')
                                    let dref = substitute(dref, '^\(\w\)/', '\=get(prefixes, submatch(1), "@:")', '')
                                  endif
                            
                                  if ref ==# '/dev/null'
                                    " Empty blob
                                    let ref = 'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391'
                                  endif
                            
                                  if exists('dref')
                                    return [ref, dcmd . ' >' . s:fnameescape(dref)] + dcmds
                                  elseif ref != ""
                                    return [ref] + dcmds
                                  endif
                            
                                endif
                                return []
                              endtry
                            endfunction
                            
    1              0.000001 function! s:GF(mode) abort
                              try
                                let results = &filetype ==# 'fugitive' ? s:CfilePorcelain() : &filetype ==# 'gitcommit' ? s:StatusCfile() : s:cfile()
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if len(results) > 1
                                return 'G' . a:mode .
                                      \ (empty(results[1]) ? '' : ' +' . escape(results[1], ' |')) . ' ' .
                                      \ s:fnameescape(results[0]) . join(map(results[2:-1], '"|" . v:val'), '')
                              elseif len(results) && len(results[0])
                                return 'G' . a:mode . ' ' . s:fnameescape(results[0])
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#Cfile() abort
                              let pre = ''
                              let results = s:cfile()
                              if empty(results)
                                let cfile = expand('<cfile>')
                                if &includeexpr =~# '\<v:fname\>'
                                  sandbox let cfile = eval(substitute(&includeexpr, '\C\<v:fname\>', '\=string(cfile)', 'g'))
                                endif
                                return cfile
                              elseif len(results) > 1
                                let pre = '+' . join(map(results[1:-1], 'escape(v:val, " ")'), '\|') . ' '
                              endif
                              return pre . s:fnameescape(s:Generate(results[0]))
                            endfunction
                            
                            " Section: Statusline
                            
    1              0.000001 function! fugitive#Statusline(...) abort
                              let dir = s:Dir(bufnr(''))
                              if empty(dir)
                                return ''
                              endif
                              let status = ''
                              let commit = s:DirCommitFile(@%)[1]
                              if len(commit)
                                let status .= ':' . commit[0:6]
                              endif
                              let status .= '('.FugitiveHead(7, dir).')'
                              return '[Git'.status.']'
                            endfunction
                            
    1              0.000001 function! fugitive#statusline(...) abort
                              return fugitive#Statusline()
                            endfunction
                            
    1              0.000001 function! fugitive#head(...) abort
                              if empty(s:Dir())
                                return ''
                              endif
                            
                              return fugitive#Head(a:0 ? a:1 : 0)
                            endfunction
                            
                            " Section: Folding
                            
    1              0.000001 function! fugitive#Foldtext() abort
                              if &foldmethod !=# 'syntax'
                                return foldtext()
                              endif
                            
                              let line_foldstart = getline(v:foldstart)
                              if line_foldstart =~# '^diff '
                                let [add, remove] = [-1, -1]
                                let filename = ''
                                for lnum in range(v:foldstart, v:foldend)
                                  let line = getline(lnum)
                                  if filename ==# '' && line =~# '^[+-]\{3\} [abciow12]/'
                                    let filename = line[6:-1]
                                  endif
                                  if line =~# '^+'
                                    let add += 1
                                  elseif line =~# '^-'
                                    let remove += 1
                                  elseif line =~# '^Binary '
                                    let binary = 1
                                  endif
                                endfor
                                if filename ==# ''
                                  let filename = matchstr(line_foldstart, '^diff .\{-\} [abciow12]/\zs.*\ze [abciow12]/')
                                endif
                                if filename ==# ''
                                  let filename = line_foldstart[5:-1]
                                endif
                                if exists('binary')
                                  return 'Binary: '.filename
                                else
                                  return '+-' . v:folddashes . ' ' . (add<10&&remove<100?' ':'') . add . '+ ' . (remove<10&&add<100?' ':'') . remove . '- ' . filename
                                endif
                              elseif line_foldstart =~# '^@@\+ .* @@'
                                return '+-' . v:folddashes . ' ' . line_foldstart
                              elseif &filetype ==# 'gitcommit' && line_foldstart =~# '^# .*:$'
                                let lines = getline(v:foldstart, v:foldend)
                                call filter(lines, 'v:val =~# "^#\t"')
                                cal map(lines, "s:sub(v:val, '^#\t%(modified: +|renamed: +)=', '')")
                                cal map(lines, "s:sub(v:val, '^([[:alpha:] ]+): +(.*)', '\\2 (\\1)')")
                                return line_foldstart.' '.join(lines, ', ')
                              endif
                              return foldtext()
                            endfunction
                            
    1              0.000001 function! fugitive#foldtext() abort
                              return fugitive#Foldtext()
                            endfunction
                            
                            " Section: Initialization
                            
    1              0.000001 function! fugitive#Init() abort
                              throw 'Third party code is using fugitive#Init() which has been removed. Contact the author if you have a reason to still use it'
                            endfunction
                            
    1              0.000001 function! fugitive#is_git_dir(path) abort
                              throw 'Third party code is using fugitive#is_git_dir() which has been removed. Change it to FugitiveIsGitDir()'
                            endfunction
                            
    1              0.000001 function! fugitive#extract_git_dir(path) abort
                              throw 'Third party code is using fugitive#extract_git_dir() which has been removed. Change it to FugitiveExtractGitDir()'
                            endfunction
                            
    1              0.000001 function! fugitive#detect(path) abort
                              throw 'Third party code is using fugitive#detect() which has been removed. Contact the author if you have a reason to still use it'
                            endfunction
                            
                            " Section: End

SCRIPT  /home/root99/.vim/plugged/vim-airline/autoload/airline/async.vim
Sourced 1 time
Total time:   0.000173
 Self time:   0.000173

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2021 Christian Brabandt et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000002 scriptencoding utf-8
                            
    1              0.000002 let s:untracked_jobs = {}
    1              0.000001 let s:mq_jobs        = {}
    1              0.000001 let s:po_jobs        = {}
    1              0.000001 let s:clean_jobs     = {}
                            
                            " Generic functions handling on exit event of the various async functions
    1              0.000002 function! s:untracked_output(dict, buf)
                              if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                              else
                                let a:dict.cfg.untracked[a:dict.file] = ''
                              endif
                            endfunction
                            
                            " also called from branch extension (for non-async vims)
    1              0.000002 function! airline#async#mq_output(buf, file)
                              let buf=a:buf
                              if !empty(a:buf)
                                if a:buf =~# 'no patches applied' ||
                                  \ a:buf =~# "unknown command 'qtop'" ||
                                  \ a:buf =~# "abort"
                                  let buf = ''
                                elseif exists("b:mq") && b:mq isnot# buf
                                  " make sure, statusline is updated
                                  unlet! b:airline_head
                                endif
                                let b:mq = buf
                              endif
                              if has_key(s:mq_jobs, a:file)
                                call remove(s:mq_jobs, a:file)
                              endif
                            endfunction
                            
    1              0.000001 function! s:po_output(buf, file)
                              if !empty(a:buf)
                                let b:airline_po_stats = printf("%s", a:buf)
                              else
                                let b:airline_po_stats = ''
                              endif
                              if has_key(s:po_jobs, a:file)
                                call remove(s:po_jobs, a:file)
                              endif
                            endfunction
                            
    1              0.000001 function! s:valid_dir(dir)
                              if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
                              endif
                              return a:dir
                            endfunction
                            
    1              0.000001 function! airline#async#vcs_untracked(config, file, vcs)
                              if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_untracked(a:config, a:file)
                              else
                                " nvim async or vim without job-feature
                                noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000001 function! s:set_clean_variables(file, vcs, val)
                              let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
                              if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') &&
                                    \ type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
                                let var[a:vcs].dirty=a:val
                                try
                                  call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
                                  unlet! b:airline_head
                                catch
                                endtry
                              endif
                            endfunction
                            
    1              0.000001 function! s:set_clean_jobs_variable(vcs, file, id)
                              if !has_key(s:clean_jobs, a:vcs)
                                let s:clean_jobs[a:vcs] = {}
                              endif
                              let s:clean_jobs[a:vcs][a:file]=a:id
                            endfunction
                            
    1              0.000001 function! s:on_exit_clean(...) dict abort
                              let buf=self.buf
                              call s:set_clean_variables(self.file, self.vcs, !empty(buf))
                              if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
                                call remove(s:clean_jobs[self.vcs], self.file)
                              endif
                            endfunction
                            
    1              0.000001 function! airline#async#vcs_clean(cmd, file, vcs)
                              if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
                              elseif has("nvim")
                                " nvim async
                                noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
                              else
                                " Vim pre 8 using system()
                                call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000005 if v:version >= 800 && has("job")
                              " Vim 8.0 with Job feature
                              " TODO: Check if we need the cwd option for the job_start() functions
                              "       (only works starting with Vim 8.0.0902)
                            
                              function! s:on_stdout(channel, msg) dict abort
                                let self.buf .= a:msg
                              endfunction
                            
                              function! s:on_exit_mq(channel) dict abort
                                call airline#async#mq_output(self.buf, self.file)
                              endfunction
                            
                              function! s:on_exit_untracked(channel) dict abort
                                call s:untracked_output(self, self.buf)
                                if has_key(s:untracked_jobs, self.file)
                                  call remove(s:untracked_jobs, self.file)
                                endif
                              endfunction
                            
                              function! s:on_exit_po(channel) dict abort
                                call s:po_output(self.buf, self.file)
                                call airline#extensions#po#shorten()
                              endfunction
                            
                              function! airline#async#get_mq_async(cmd, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                let options = {'cmd': a:cmd, 'buf': '', 'file': a:file}
                                if has_key(s:mq_jobs, a:file)
                                  if job_status(get(s:mq_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:mq_jobs, a:file)
                                    call remove(s:mq_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_mq', options)})
                                let s:mq_jobs[a:file] = id
                              endfunction
                            
                              function! airline#async#get_msgfmt_stat(cmd, file)
                                if !executable('msgfmt')
                                  " no msgfmt
                                  return
                                endif
                                if g:airline#init#is_windows
                                  let cmd = 'cmd /C ' . a:cmd. shellescape(a:file)
                                else
                                  let cmd = ['sh', '-c', a:cmd. shellescape(a:file)]
                                endif
                            
                                let options = {'buf': '', 'file': a:file}
                                if has_key(s:po_jobs, a:file)
                                  if job_status(get(s:po_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:po_jobs, a:file)
                                    call remove(s:po_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_po', options)})
                                let s:po_jobs[a:file] = id
                              endfunction
                            
                              function! airline#async#vim_vcs_clean(cmd, file, vcs)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                let options = {'buf': '', 'vcs': a:vcs, 'file': a:file}
                                let jobs = get(s:clean_jobs, a:vcs, {})
                                if has_key(jobs, a:file)
                                  if job_status(get(jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(jobs, a:file)
                                    " still running
                                    return
                                    " jobs dict should be cleaned on exit, so not needed here
                                    " call remove(jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'null',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_clean', options)})
                                call s:set_clean_jobs_variable(a:vcs, a:file, id)
                              endfunction
                            
                              function! airline#async#vim_vcs_untracked(config, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:config['cmd'] . shellescape(a:file)
                                else
                                  let cmd = [&shell, &shellcmdflag, a:config['cmd'] . shellescape(a:file)]
                                endif
                            
                                let options = {'cfg': a:config, 'buf': '', 'file': a:file}
                                if has_key(s:untracked_jobs, a:file)
                                  if job_status(get(s:untracked_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:untracked_jobs, a:file)
                                    call remove(s:untracked_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_untracked', options)})
                                let s:untracked_jobs[a:file] = id
                              endfunction
                            
    1              0.000002 elseif has("nvim")
                              " NVim specific functions
                            
    1              0.000002   function! s:nvim_output_handler(job_id, data, event) dict
                                if a:event == 'stdout' || a:event == 'stderr'
                                  let self.buf .=  join(a:data)
                                endif
                              endfunction
                            
    1              0.000001   function! s:nvim_untracked_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:untracked_output(self, self.buf)
                                  if has_key(s:untracked_jobs, self.file)
                                    call remove(s:untracked_jobs, self.file)
                                  endif
                                endif
                              endfunction
                            
    1              0.000001   function! s:nvim_mq_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call airline#async#mq_output(self.buf, self.file)
                                endif
                              endfunction
                            
    1              0.000001   function! s:nvim_po_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:po_output(self.buf, self.file)
                                  call airline#extensions#po#shorten()
                                endif
                              endfunction
                            
    1              0.000001   function! airline#async#nvim_get_mq_async(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_mq_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                if has_key(s:mq_jobs, a:file)
                                  call remove(s:mq_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:mq_jobs[a:file] = id
                              endfunction
                            
    1              0.000001   function! airline#async#nvim_get_msgfmt_stat(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_po_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  " no msgfmt on windows?
                                  return
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd. shellescape(a:file)]
                                endif
                            
                                if has_key(s:po_jobs, a:file)
                                  call remove(s:po_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:po_jobs[a:file] = id
                              endfunction
                            
    1              0.000001   function! airline#async#nvim_vcs_clean(cmd, file, vcs)
                                let config = {
                                \ 'buf': '',
                                \ 'vcs': a:vcs,
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:on_exit_clean')}
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                if !has_key(s:clean_jobs, a:vcs)
                                  let s:clean_jobs[a:vcs] = {}
                                endif
                                if has_key(s:clean_jobs[a:vcs], a:file)
                                  " still running
                                  return
                                  " jobs dict should be cleaned on exit, so not needed here
                                  " call remove(s:clean_jobs[a:vcs], a:file)
                                endif
                                let id = jobstart(cmd, config)
                                call s:set_clean_jobs_variable(a:vcs, a:file, id)
                              endfunction
                            
    1              0.000001 endif
                            
                            " Should work in either Vim pre 8 or Nvim
    1              0.000001 function! airline#async#nvim_vcs_untracked(cfg, file, vcs)
                              let cmd = a:cfg.cmd . shellescape(a:file)
                              let id = -1
                              let config = {
                              \ 'buf': '',
                              \ 'vcs': a:vcs,
                              \ 'cfg': a:cfg,
                              \ 'file': a:file,
                              \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h'))
                              \ }
                              if has("nvim")
                                call extend(config, {
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_untracked_job_handler')})
                                if has_key(s:untracked_jobs, config.file)
                                  " still running
                                  return
                                endif
                                try
                                let id = jobstart(cmd, config)
                                catch
                                  " catch-all, jobstart() failed, fall back to system()
                                  let id=-1
                                endtry
                                let s:untracked_jobs[a:file] = id
                              endif
                              " vim without job feature or nvim jobstart failed
                              if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000001 function! airline#async#vim7_vcs_clean(cmd, file, vcs)
                              " Vim pre 8, fallback using system()
                              " don't want to to see error messages
                              if g:airline#init#is_windows && &shell =~ 'cmd'
                                let cmd = a:cmd .' 2>nul'
                              elseif g:airline#init#is_windows && &shell =~ 'powerline'
                                let cmd = a:cmd .' 2> $null'
                              else
                                let cmd = a:cmd .' 2>/dev/null'
                              endif
                              let output=system(cmd)
                              call s:set_clean_variables(a:file, a:vcs, !empty(output))
                            endfunction

SCRIPT  /home/root99/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim
Sourced 1 time
Total time:   0.000452
 Self time:   0.000452

count  total (s)   self (s)
    1              0.000007 let s:winid = 0
    1              0.000004 let s:preview_bufnr = 0
    1              0.000006 let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''
                            
    1              0.000004 function! gitgutter#hunk#set_hunks(bufnr, hunks) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
                              call s:reset_summary(a:bufnr)
                            endfunction
                            
    1              0.000002 function! gitgutter#hunk#hunks(bufnr) abort
                              return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])
                            endfunction
                            
    1              0.000002 function! gitgutter#hunk#reset(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
                              call s:reset_summary(a:bufnr)
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#hunk#summary(bufnr) abort
                              return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])
                            endfunction
                            
    1              0.000003 function! s:reset_summary(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])
                            endfunction
                            
    1              0.000003 function! gitgutter#hunk#increment_lines_added(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[0] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
    1              0.000002 function! gitgutter#hunk#increment_lines_modified(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[1] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
    1              0.000002 function! gitgutter#hunk#increment_lines_removed(bufnr, count) abort
                              let summary = gitgutter#hunk#summary(a:bufnr)
                              let summary[2] += a:count
                              call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#hunk#next_hunk(count) abort
                              let bufnr = bufnr('')
                              if !gitgutter#utility#is_active(bufnr) | return | endif
                            
                              let hunks = gitgutter#hunk#hunks(bufnr)
                              if empty(hunks)
                                call gitgutter#utility#warn('No hunks in file')
                                return
                              endif
                            
                              let current_line = line('.')
                              let hunk_count = 0
                              for hunk in hunks
                                if hunk[2] > current_line
                                  let hunk_count += 1
                                  if hunk_count == a:count
                                    execute 'normal!' hunk[2] . 'Gzv'
                                    if g:gitgutter_show_msg_on_hunk_jumping
                                      redraw | echo printf('Hunk %d of %d', index(hunks, hunk) + 1, len(hunks))
                                    endif
                                    if gitgutter#hunk#is_preview_window_open()
                                      call gitgutter#hunk#preview()
                                    endif
                                    return
                                  endif
                                endif
                              endfor
                              call gitgutter#utility#warn('No more hunks')
                            endfunction
                            
    1              0.000002 function! gitgutter#hunk#prev_hunk(count) abort
                              let bufnr = bufnr('')
                              if !gitgutter#utility#is_active(bufnr) | return | endif
                            
                              let hunks = gitgutter#hunk#hunks(bufnr)
                              if empty(hunks)
                                call gitgutter#utility#warn('No hunks in file')
                                return
                              endif
                            
                              let current_line = line('.')
                              let hunk_count = 0
                              for hunk in reverse(copy(hunks))
                                if hunk[2] < current_line
                                  let hunk_count += 1
                                  if hunk_count == a:count
                                    let target = hunk[2] == 0 ? 1 : hunk[2]
                                    execute 'normal!' target . 'Gzv'
                                    if g:gitgutter_show_msg_on_hunk_jumping
                                      redraw | echo printf('Hunk %d of %d', index(hunks, hunk) + 1, len(hunks))
                                    endif
                                    if gitgutter#hunk#is_preview_window_open()
                                      call gitgutter#hunk#preview()
                                    endif
                                    return
                                  endif
                                endif
                              endfor
                              call gitgutter#utility#warn('No previous hunks')
                            endfunction
                            
                            " Returns the hunk the cursor is currently in or an empty list if the cursor
                            " isn't in a hunk.
    1              0.000002 function! s:current_hunk() abort
                              let bufnr = bufnr('')
                              let current_hunk = []
                            
                              for hunk in gitgutter#hunk#hunks(bufnr)
                                if gitgutter#hunk#cursor_in_hunk(hunk)
                                  let current_hunk = hunk
                                  break
                                endif
                              endfor
                            
                              return current_hunk
                            endfunction
                            
                            " Returns truthy if the cursor is in two hunks (which can only happen if the
                            " cursor is on the first line and lines above have been deleted and lines
                            " immediately below have been deleted) or falsey otherwise.
    1              0.000002 function! s:cursor_in_two_hunks()
                              let hunks = gitgutter#hunk#hunks(bufnr(''))
                            
                              if line('.') == 1 && len(hunks) > 1 && hunks[0][2:3] == [0, 0] && hunks[1][2:3] == [1, 0]
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
                            " A line can be in 0 or 1 hunks, with the following exception: when the first
                            " line(s) of a file has been deleted, and the new second line (and
                            " optionally below) has been deleted, the new first line is in two hunks.
    1              0.000002 function! gitgutter#hunk#cursor_in_hunk(hunk) abort
                              let current_line = line('.')
                            
                              if current_line == 1 && a:hunk[2] == 0
                                return 1
                              endif
                            
                              if current_line >= a:hunk[2] && current_line < a:hunk[2] + (a:hunk[3] == 0 ? 1 : a:hunk[3])
                                return 1
                              endif
                            
                              return 0
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#hunk#in_hunk(lnum)
                              " Hunks are sorted in the order they appear in the buffer.
                              for hunk in gitgutter#hunk#hunks(bufnr(''))
                                " if in a hunk on first line of buffer
                                if a:lnum == 1 && hunk[2] == 0
                                  return 1
                                endif
                            
                                " if in a hunk generally
                                if a:lnum >= hunk[2] && a:lnum < hunk[2] + (hunk[3] == 0 ? 1 : hunk[3])
                                  return 1
                                endif
                            
                                " if hunk starts after the given line
                                if a:lnum < hunk[2]
                                  return 0
                                endif
                              endfor
                            
                              return 0
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#hunk#text_object(inner) abort
                              let hunk = s:current_hunk()
                            
                              if empty(hunk)
                                return
                              endif
                            
                              let [first_line, last_line] = [hunk[2], hunk[2] + hunk[3] - 1]
                            
                              if ! a:inner
                                let lnum = last_line
                                let eof = line('$')
                                while lnum < eof && empty(getline(lnum + 1))
                                  let lnum +=1
                                endwhile
                                let last_line = lnum
                              endif
                            
                              execute 'normal! 'first_line.'GV'.last_line.'G'
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#hunk#stage(...) abort
                              if !s:in_hunk_preview_window() && !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
                            
                              if a:0 && (a:1 != 1 || a:2 != line('$'))
                                call s:hunk_op(function('s:stage'), a:1, a:2)
                              else
                                call s:hunk_op(function('s:stage'))
                              endif
                              silent! call repeat#set("\<Plug>(GitGutterStageHunk)", -1)
                            endfunction
                            
    1              0.000002 function! gitgutter#hunk#undo() abort
                              if !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
                            
                              call s:hunk_op(function('s:undo'))
                              silent! call repeat#set("\<Plug>(GitGutterUndoHunk)", -1)
                            endfunction
                            
    1              0.000001 function! gitgutter#hunk#preview() abort
                              if !gitgutter#utility#has_repo_path(bufnr('')) | return | endif
                            
                              call s:hunk_op(function('s:preview'))
                              silent! call repeat#set("\<Plug>(GitGutterPreviewHunk)", -1)
                            endfunction
                            
                            
    1              0.000002 function! s:hunk_op(op, ...)
                              let bufnr = bufnr('')
                            
                              if s:in_hunk_preview_window()
                                if string(a:op) =~ '_stage'
                                  " combine hunk-body in preview window with updated hunk-header
                                  let hunk_body = getline(1, '$')
                            
                                  let [removed, added] = [0, 0]
                                  for line in hunk_body
                                    if line[0] == '-'
                                      let removed += 1
                                    elseif line[0] == '+'
                                      let added += 1
                                    endif
                                  endfor
                            
                                  let hunk_header = b:hunk_header
                                  " from count
                                  let hunk_header[4] = substitute(hunk_header[4], '\(-\d\+\)\(,\d\+\)\?', '\=submatch(1).",".removed', '')
                                  " to count
                                  let hunk_header[4] = substitute(hunk_header[4], '\(+\d\+\)\(,\d\+\)\?', '\=submatch(1).",".added', '')
                            
                                  let hunk_diff = join(hunk_header + hunk_body, "\n")."\n"
                            
                                  call s:goto_original_window()
                                  call gitgutter#hunk#close_hunk_preview_window()
                                  call s:stage(hunk_diff)
                                endif
                            
                                return
                              endif
                            
                              if gitgutter#utility#is_active(bufnr)
                                " Get a (synchronous) diff.
                                let [async, g:gitgutter_async] = [g:gitgutter_async, 0]
                                let diff = gitgutter#diff#run_diff(bufnr, g:gitgutter_diff_relative_to, 1)
                                let g:gitgutter_async = async
                            
                                call gitgutter#hunk#set_hunks(bufnr, gitgutter#diff#parse_diff(diff))
                                call gitgutter#diff#process_hunks(bufnr, gitgutter#hunk#hunks(bufnr))  " so the hunk summary is updated
                            
                                if empty(s:current_hunk())
                                  call gitgutter#utility#warn('Cursor is not in a hunk')
                                elseif s:cursor_in_two_hunks()
                                  let choice = input('Choose hunk: upper or lower (u/l)? ')
                                  " Clear input
                                  normal! :<ESC>
                                  if choice =~ 'u'
                                    call a:op(gitgutter#diff#hunk_diff(bufnr, diff, 0))
                                  elseif choice =~ 'l'
                                    call a:op(gitgutter#diff#hunk_diff(bufnr, diff, 1))
                                  else
                                    call gitgutter#utility#warn('Did not recognise your choice')
                                  endif
                                else
                                  let hunk_diff = gitgutter#diff#hunk_diff(bufnr, diff)
                            
                                  if a:0
                                    let hunk_first_line = s:current_hunk()[2]
                                    let hunk_diff = s:part_of_diff(hunk_diff, a:1-hunk_first_line, a:2-hunk_first_line)
                                  endif
                            
                                  call a:op(hunk_diff)
                                endif
                              endif
                            endfunction
                            
                            
    1              0.000002 function! s:stage(hunk_diff)
                              let bufnr = bufnr('')
                              let diff = s:adjust_header(bufnr, a:hunk_diff)
                              " Apply patch to index.
                              call gitgutter#utility#system(
                                    \ gitgutter#utility#cd_cmd(bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' apply --cached --unidiff-zero - '),
                                    \ diff)
                              if v:shell_error
                                call gitgutter#utility#warn('Patch does not apply')
                              else
                                if exists('#User#GitGutterStage')
                                  execute 'doautocmd' s:nomodeline 'User GitGutterStage'
                                endif
                              endif
                            
                              " Refresh gitgutter's view of buffer.
                              call gitgutter#process_buffer(bufnr, 1)
                            endfunction
                            
                            
    1              0.000002 function! s:undo(hunk_diff)
                              " Apply reverse patch to buffer.
                              let hunk  = gitgutter#diff#parse_hunk(split(a:hunk_diff, '\n')[4])
                              let lines = map(split(a:hunk_diff, '\r\?\n')[5:], 'v:val[1:]')
                              let lnum  = hunk[2]
                              let added_only   = hunk[1] == 0 && hunk[3]  > 0
                              let removed_only = hunk[1]  > 0 && hunk[3] == 0
                            
                              if removed_only
                                call append(lnum, lines)
                              elseif added_only
                                execute lnum .','. (lnum+len(lines)-1) .'d _'
                              else
                                call append(lnum-1, lines[0:hunk[1]])
                                execute (lnum+hunk[1]) .','. (lnum+hunk[1]+hunk[3]) .'d _'
                              endif
                            endfunction
                            
                            
    1              0.000002 function! s:preview(hunk_diff)
                              let lines = split(a:hunk_diff, '\r\?\n')
                              let header = lines[0:4]
                              let body = lines[5:]
                            
                              call s:open_hunk_preview_window()
                              call s:populate_hunk_preview_window(header, body)
                              call s:enable_staging_from_hunk_preview_window()
                              if &previewwindow
                                call s:goto_original_window()
                              endif
                            endfunction
                            
                            
                            " Returns a new hunk diff using the specified lines from the given one.
                            " Assumes all lines are additions.
                            " a:first, a:last - 0-based indexes into the body of the hunk.
    1              0.000002 function! s:part_of_diff(hunk_diff, first, last)
                              let diff_lines = split(a:hunk_diff, '\n', 1)
                            
                              " adjust 'to' line count in header
                              let diff_lines[4] = substitute(diff_lines[4], '\(+\d\+\)\(,\d\+\)\?', '\=submatch(1).",".(a:last-a:first+1)', '')
                            
                              return join(diff_lines[0:4] + diff_lines[5+a:first:5+a:last], "\n")."\n"
                            endfunction
                            
                            
    1              0.000002 function! s:adjust_header(bufnr, hunk_diff)
                              let filepath = gitgutter#utility#repo_path(a:bufnr, 0)
                              return s:adjust_hunk_summary(s:fix_file_references(filepath, a:hunk_diff))
                            endfunction
                            
                            
                            " Replaces references to temp files with the actual file.
    1              0.000002 function! s:fix_file_references(filepath, hunk_diff)
                              let lines = split(a:hunk_diff, '\n')
                            
                              let left_prefix  = matchstr(lines[2], '[abciow12]').'/'
                              let right_prefix = matchstr(lines[3], '[abciow12]').'/'
                              let quote        = lines[0][11] == '"' ? '"' : ''
                            
                              let left_file  = quote.left_prefix.a:filepath.quote
                              let right_file = quote.right_prefix.a:filepath.quote
                            
                              let lines[0] = 'diff --git '.left_file.' '.right_file
                              let lines[2] = '--- '.left_file
                              let lines[3] = '+++ '.right_file
                            
                              return join(lines, "\n")."\n"
                            endfunction
                            
    1              0.000007 if $VIM_GITGUTTER_TEST
                              function! gitgutter#hunk#fix_file_references(filepath, hunk_diff)
                                return s:fix_file_references(a:filepath, a:hunk_diff)
                              endfunction
    1              0.000001 endif
                            
                            
    1              0.000002 function! s:adjust_hunk_summary(hunk_diff) abort
                              let line_adjustment = s:line_adjustment_for_current_hunk()
                              let diff = split(a:hunk_diff, '\n', 1)
                              let diff[4] = substitute(diff[4], '+\zs\(\d\+\)', '\=submatch(1)+line_adjustment', '')
                              return join(diff, "\n")
                            endfunction
                            
                            
                            " Returns the number of lines the current hunk is offset from where it would
                            " be if any changes above it in the file didn't exist.
    1              0.000002 function! s:line_adjustment_for_current_hunk() abort
                              let bufnr = bufnr('')
                              let adj = 0
                              for hunk in gitgutter#hunk#hunks(bufnr)
                                if gitgutter#hunk#cursor_in_hunk(hunk)
                                  break
                                else
                                  let adj += hunk[1] - hunk[3]
                                endif
                              endfor
                              return adj
                            endfunction
                            
                            
    1              0.000002 function! s:in_hunk_preview_window()
                              if g:gitgutter_preview_win_floating
                                return win_id2win(s:winid) == winnr()
                              else
                                return &previewwindow
                              endif
                            endfunction
                            
                            
                            " Floating window: does not move cursor to floating window.
                            " Preview window: moves cursor to preview window.
    1              0.000002 function! s:open_hunk_preview_window()
                              if g:gitgutter_preview_win_floating
                                if exists('*nvim_open_win')
                                  call gitgutter#hunk#close_hunk_preview_window()
                            
                                  let buf = nvim_create_buf(v:false, v:false)
                                  " Set default width and height for now.
                                  let s:winid = nvim_open_win(buf, v:false, {
                                        \ 'relative': 'cursor',
                                        \ 'row': 1,
                                        \ 'col': 0,
                                        \ 'width': 42,
                                        \ 'height': &previewheight,
                                        \ 'style': 'minimal'
                                        \ })
                                  call nvim_buf_set_option(buf, 'filetype',  'diff')
                                  call nvim_buf_set_option(buf, 'buftype',   'acwrite')
                                  call nvim_buf_set_option(buf, 'bufhidden', 'delete')
                                  call nvim_buf_set_option(buf, 'swapfile',  v:false)
                                  call nvim_buf_set_name(buf, 'gitgutter://hunk-preview')
                            
                                  " Assumes cursor is in original window.
                                  autocmd CursorMoved <buffer> ++once call gitgutter#hunk#close_hunk_preview_window()
                            
                                  if g:gitgutter_close_preview_on_escape
                                    " Map <Esc> to close the floating preview.
                                    nnoremap <buffer> <silent> <Esc> :<C-U>call gitgutter#hunk#close_hunk_preview_window()<CR>
                                    " Ensure that when the preview window is closed, the map is removed.
                                    autocmd User GitGutterPreviewClosed silent! nunmap <buffer> <Esc>
                                    autocmd CursorMoved <buffer> ++once silent! nunmap <buffer> <Esc>
                                    execute "autocmd WinClosed <buffer=".winbufnr(s:winid)."> doautocmd" s:nomodeline "User GitGutterPreviewClosed"
                                  endif
                            
                                  return
                                endif
                            
                                if exists('*popup_create')
                                  let opts = {
                                        \ 'line': 'cursor+1',
                                        \ 'col': 'cursor',
                                        \ 'moved': 'any',
                                        \ }
                                  if g:gitgutter_close_preview_on_escape
                                    let opts.filter = function('s:close_popup_on_escape')
                                  endif
                            
                                  let s:winid = popup_create('', opts)
                            
                                  call setbufvar(winbufnr(s:winid), '&filetype', 'diff')
                            
                                  return
                                endif
                              endif
                            
                              " Specifying where to open the preview window can lead to the cursor going
                              " to an unexpected window when the preview window is closed (#769).
                              silent! noautocmd execute g:gitgutter_preview_win_location 'pedit gitgutter://hunk-preview'
                              silent! wincmd P
                              setlocal statusline=%{''}
                              doautocmd WinEnter
                              if exists('*win_getid')
                                let s:winid = win_getid()
                              else
                                let s:preview_bufnr = bufnr('')
                              endif
                              setlocal filetype=diff buftype=acwrite bufhidden=delete
                              " Reset some defaults in case someone else has changed them.
                              setlocal noreadonly modifiable noswapfile
                              if g:gitgutter_close_preview_on_escape
                                " Ensure cursor goes to the expected window.
                                nnoremap <buffer> <silent> <Esc> :<C-U>wincmd p<Bar>pclose<CR>
                              endif
                            endfunction
                            
                            
    1              0.000002 function! s:close_popup_on_escape(winid, key)
                              if a:key == "\<Esc>"
                                call popup_close(a:winid)
                                return 1
                              endif
                              return 0
                            endfunction
                            
                            
                            " Floating window: does not care where cursor is.
                            " Preview window: assumes cursor is in preview window.
    1              0.000002 function! s:populate_hunk_preview_window(header, body)
                              let body_length = len(a:body)
                            
                              if g:gitgutter_preview_win_floating
                                if exists('*nvim_open_win')
                                  let height = min([body_length, &previewheight])
                            
                                  " Assumes cursor is not in previewing window.
                                  call nvim_buf_set_var(winbufnr(s:winid), 'hunk_header', a:header)
                            
                                  let [_scrolloff, &scrolloff] = [&scrolloff, 0]
                            
                                  let width = max(map(copy(a:body), 'strdisplaywidth(v:val)'))
                                  call nvim_win_set_width(s:winid, width)
                                  call nvim_win_set_height(s:winid, height)
                            
                                  let &scrolloff=_scrolloff
                            
                                  call nvim_buf_set_lines(winbufnr(s:winid), 0, -1, v:false, [])
                                  call nvim_buf_set_lines(winbufnr(s:winid), 0, -1, v:false, a:body)
                                  call nvim_buf_set_option(winbufnr(s:winid), 'modified', v:false)
                            
                                  let ns_id = nvim_create_namespace('GitGutter')
                                  call nvim_buf_clear_namespace(winbufnr(s:winid), ns_id, 0, -1)
                                  for region in gitgutter#diff_highlight#process(a:body)
                                    let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
                                    call nvim_buf_add_highlight(winbufnr(s:winid), ns_id, group, region[0]-1, region[2]-1, region[3])
                                  endfor
                            
                                  call nvim_win_set_cursor(s:winid, [1,0])
                                endif
                            
                                if exists('*popup_create')
                                  call popup_settext(s:winid, a:body)
                            
                                  for region in gitgutter#diff_highlight#process(a:body)
                                    let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
                                    call win_execute(s:winid, "call matchaddpos('".group."', [[".region[0].", ".region[2].", ".(region[3]-region[2]+1)."]])")
                                  endfor
                                endif
                            
                              else
                                let b:hunk_header = a:header
                            
                                %delete _
                                call setline(1, a:body)
                                setlocal nomodified
                            
                                normal! G$
                                let hunk_height = max([body_length, winline()])
                                let height = min([hunk_height, &previewheight])
                                execute 'resize' height
                                1
                            
                                call clearmatches()
                                for region in gitgutter#diff_highlight#process(a:body)
                                  let group = region[1] == '+' ? 'GitGutterAddIntraLine' : 'GitGutterDeleteIntraLine'
                                  call matchaddpos(group, [[region[0], region[2], region[3]-region[2]+1]])
                                endfor
                            
                                1
                              endif
                            endfunction
                            
                            
    1              0.000002 function! s:enable_staging_from_hunk_preview_window()
                              augroup gitgutter_hunk_preview
                                autocmd!
                                let bufnr = s:winid != 0 ? winbufnr(s:winid) : s:preview_bufnr
                                execute 'autocmd BufWriteCmd <buffer='.bufnr.'> GitGutterStageHunk'
                              augroup END
                            endfunction
                            
                            
    1              0.000002 function! s:goto_original_window()
                              noautocmd wincmd p
                              doautocmd WinEnter
                            endfunction
                            
                            
    1              0.000002 function! gitgutter#hunk#close_hunk_preview_window()
                              let bufnr = s:winid != 0 ? winbufnr(s:winid) : s:preview_bufnr
                              call setbufvar(bufnr, '&modified', 0)
                            
                              if g:gitgutter_preview_win_floating
                                if win_id2win(s:winid) > 0
                                  execute win_id2win(s:winid).'wincmd c'
                                endif
                              else
                                pclose
                              endif
                            
                              let s:winid = 0
                              let s:preview_bufnr = 0
                            endfunction
                            
                            
    1              0.000002 function gitgutter#hunk#is_preview_window_open()
                              if g:gitgutter_preview_win_floating
                                if win_id2win(s:winid) > 0
                                  execute win_id2win(s:winid).'wincmd c'
                                endif
                              else
                                for i in range(1, winnr('$'))
                                  if getwinvar(i, '&previewwindow')
                                    return 1
                                  endif
                                endfor
                              endif
                              return 0
                            endfunction

FUNCTION  FugitiveExtractGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:341
Called 1 time
Total time:   0.000253
 Self time:   0.000166

count  total (s)   self (s)
    1              0.000002   if type(a:path) ==# type({})
                                return get(a:path, 'git_dir', '')
    1              0.000002   elseif type(a:path) == type(0)
                                let path = s:Slash(a:path >= 0 ? bufname(a:path) : bufname(''))
    1              0.000000   else
    1   0.000006   0.000005     let path = s:Slash(a:path)
    1              0.000000   endif
    1              0.000003   if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
    1              0.000001   elseif empty(path)
                                return ''
    1              0.000004   elseif isdirectory(path)
                                let path = fnamemodify(path, ':p:s?/$??')
    1              0.000000   else
    1              0.000006     let path = fnamemodify(path, ':p:h:s?/$??')
    1              0.000000   endif
    1              0.000006   let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
    1              0.000002   if len(pre) && exists('*' . pre . 'Real')
                                let path = s:Slash({pre}Real(path))
    1              0.000000   endif
    1              0.000015   let root = resolve(path)
    1              0.000001   if root !=# path
                                silent! exe (haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd') '.'
    1              0.000000   endif
    1              0.000001   let previous = ""
    1              0.000006   let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
    1   0.000013   0.000005   call s:Tree(env_git_dir)
    2              0.000002   while root !=# previous
    2              0.000008     if root =~# '\v^//%([^/]+/?)?$'
                                  break
    2              0.000001     endif
    2   0.000055   0.000011     if index(s:CeilingDirectories(), root) >= 0
                                  break
    2              0.000001     endif
    2              0.000006     if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
    2              0.000003     elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
    2              0.000001     endif
    2              0.000010     let dir = substitute(root, '[\/]$', '', '') . '/.git'
    2              0.000009     let type = getftype(dir)
    2   0.000025   0.000006     if type ==# 'dir' && FugitiveIsGitDir(dir)
    1              0.000001       return dir
    1              0.000001     elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
    1              0.000001     elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                  if file_dir !~# '^/\|^\a:' && FugitiveIsGitDir(root . '/' . file_dir)
                                    return simplify(root . '/' . file_dir)
                                  elseif len(file_dir) && FugitiveIsGitDir(file_dir)
                                    return file_dir
                                  endif
    1   0.000024   0.000008     elseif FugitiveIsGitDir(root)
                                  return root
    1              0.000000     endif
    1              0.000001     let previous = root
    1              0.000002     let root = fnamemodify(root, ':h')
    1              0.000000   endwhile
                              return ''

FUNCTION  <SNR>146_map_keys()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:195
Called 6 times
Total time:   0.003566
 Self time:   0.003566

count  total (s)   self (s)
    6              0.000064   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
    6              0.000022   if bidx_mode > 0
    6              0.000016     if bidx_mode == 1
   66              0.000204       for i in range(1, 10)
   60              0.002514         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i%10, i-1)
   66              0.000106       endfor
                                else
                                  let start_idx = bidx_mode == 2 ? 11 : 1
                                  for i in range(start_idx, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%02d :call <SID>select_tab(%d)<CR>', i, i-start_idx)
                                  endfor
    6              0.000009     endif
    6              0.000230     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
    6              0.000166     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                " Enable this for debugging
                                " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
    6              0.000010   endif

FUNCTION  airline#extensions#undotree#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/undotree.vim:11
Called 3 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    3              0.000013   if exists('t:undotree')
                                if &ft == 'undotree'
                                  if exists('*t:undotree.GetStatusLine')
                                    call airline#extensions#apply_left_override('undo', '%{exists("t:undotree") ? t:undotree.GetStatusLine() : ""}')
                                  else
                                    call airline#extensions#apply_left_override('undotree', '%f')
                                  endif
                                endif
                            
                                if &ft == 'diff' && exists('*t:diffpanel.GetStatusLine')
                                  call airline#extensions#apply_left_override('diff', '%{exists("t:diffpanel") ? t:diffpanel.GetStatusLine() : ""}')
                                endif
    3              0.000002   endif

FUNCTION  <SNR>137_sh_autocmd_handler()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:353
Called 2 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    2              0.000018   if exists('#airline')
    2              0.000018     unlet! b:airline_head b:airline_do_mq_check
    2              0.000004   endif

FUNCTION  <SNR>134_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:32
Called 189 times
Total time:   0.001553
 Self time:   0.001553

count  total (s)   self (s)
  189              0.000670     if index(a:list, a:name) == -1
  189              0.000545       call add(a:list, a:name)
  189              0.000199       return 1
                                else
                                  if &vbs
                                    echomsg printf("airline: group: %s already done, skipping", a:name)
                                  endif
                                  return 0
                                endif

FUNCTION  <SNR>134_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:108
Called 287 times
Total time:   0.003643
 Self time:   0.003643

count  total (s)   self (s)
                                " Checks, whether the definition of the colors is valid and is not empty or NONE
                                " e.g. if the colors would expand to this:
                                " hi airline_c ctermfg=NONE ctermbg=NONE
                                " that means to clear that highlighting group, therefore, fallback to Normal
                                " highlighting group for the cterm values
                            
                                " This only works, if the Normal highlighting group is actually defined, so
                                " return early, if it has been cleared
  287              0.000875     if !exists("g:airline#highlighter#normal_fg_hi")
                                  let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  287              0.000136     endif
  287              0.000683     if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
  287              0.000317       return a:colors
                                endif
                            
                                for val in a:colors
                                  if !empty(val) && val !=# 'NONE'
                                    return a:colors
                                  endif
                                endfor
                                " this adds the bold attribute to the term argument of the :hi command,
                                " but at least this makes sure, the group will be defined
                                let fg = g:airline#highlighter#normal_fg_hi
                                let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                                if empty(bg) || bg < 0
                                  " in case there is no background color defined for Normal
                                  let bg = a:colors[3]
                                endif
                                return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:93
Called 3 times
Total time:   0.005202
 Self time:   0.000762

count  total (s)   self (s)
   33              0.000076     for Fn in a:list
   33   0.004968   0.000528       let code = call(Fn, a:000)
   33              0.000052       if code != 0
    3              0.000002         return code
   30              0.000019       endif
   30              0.000026     endfor
                                return 0

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:21
Called 7 times
Total time:   0.014720
 Self time:   0.000775

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    7   0.002250   0.000122   if gitgutter#utility#is_active(a:bufnr)
                            
    3              0.000024     if has('patch-7.4.1559')
    3              0.000030       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
    3              0.000002     endif
    3   0.011923   0.000105     let how = s:setup_path(a:bufnr, l:Callback)
    3              0.000024     if [how] == ['async']  " avoid string-to-number conversion if how is a number
    3              0.000005       return
                                endif
                            
                                if a:force || s:has_fresh_changes(a:bufnr)
                            
                                  let diff = 'NOT SET'
                                  try
                                    let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
                                  if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
                                endif
    4              0.000006   endif

FUNCTION  <SNR>35_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim:33
Called 1 time
Total time:   0.006909
 Self time:   0.002398

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000004   syn clear
    1              0.000004   if exists("b:current_syntax")
                                unlet b:current_syntax
    1              0.000001   endif
                            
    1              0.000004   let s = expand("<amatch>")
    1              0.000002   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    1              0.000001   elseif s == "OFF"
                                let s = ""
    1              0.000000   endif
                            
    1              0.000001   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    2              0.000010     for name in split(s, '\.')
    1              0.000002       if !empty(name)
    1   0.005489   0.000978         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    1              0.001363         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
    1              0.000002       endif
    2              0.000002     endfor
    1              0.000001   endif

FUNCTION  <SNR>171_cancel_cur_job()
    Defined: ~/.vim/plugged/vim-hexokinase/autoload/hexokinase/v2/scraper.vim:83
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000001     try
    1              0.000002         if has('nvim')
    1              0.000002             let b:hexokinase_job_id = get(b:, 'hexokinase_job_id', -1)
    1              0.000004             call chanclose(b:hexokinase_job_id)
                                    else
                                        if has_key(b:, 'hexokinase_job')
                                            call ch_close(b:hexokinase_job)
                                        endif
                                    endif
    1              0.000005     catch /E90[06]/
    1              0.000001     endtry

FUNCTION  <SNR>84_init()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:15
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   if s:airline_initialized
    1              0.000001     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  if g:airline_theme is# 'random'
                                    let g:airline_theme=s:random_theme()
                                  endif
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  call airline#util#warning(printf('Could not resolve airline theme "%s". Themes have been migrated to github.com/vim-airline/vim-airline-themes.', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                endtry
                                try
                                  silent call airline#switch_theme(g:airline_theme)
                                catch
                                  call airline#util#warning(printf('Could not find airline theme "%s".', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                  silent call airline#switch_theme(g:airline_theme)
                                endtry
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              call airline#util#doautocmd('AirlineAfterInit')

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:207
Called 31 times
Total time:   0.000889
 Self time:   0.000889

count  total (s)   self (s)
   31              0.000413   if has_key(s:contexts, a:winnr)
   31              0.000398     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:216
Called 31 times
Total time:   0.111215
 Self time:   0.007785

count  total (s)   self (s)
   31              0.000211   if !has_key(s:contexts, a:winnr)
                                return ''
   31              0.000050   endif
   31              0.000178   let context = s:contexts[a:winnr]
                            
   31              0.000167   if get(w:, 'airline_active', 1)
   31              0.000139     let m = mode(1)
   31              0.000096     if m ==# "i"
                                  let mode = ['insert']
   31              0.000097     elseif m[0] ==# "i"
                                  let mode = ['insert']
   31              0.000054     elseif m ==# "Rv"
                                  let mode =['replace']
   31              0.000057     elseif m[0] ==# "R"
                                  let mode = ['replace']
   31              0.000464     elseif m[0] =~# '\v(v|V||s|S|)'
                                  let mode = ['visual']
   31              0.000051     elseif m ==# "t"
                                  let mode = ['terminal']
   31              0.000054     elseif m[0] ==# "c"
    4              0.000016       let mode = ['commandline']
   27              0.000044     elseif m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let mode = ['normal']
   27              0.000072     elseif m[0:1] ==# 'ni'
                                  let mode = ['insert']
                                  let m = 'ni'
   27              0.000030     else
   27              0.000097       let mode = ['normal']
   31              0.000031     endif
   31   0.001073   0.000638     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let m = 'multi'
   31              0.000036     endif
   31              0.000333     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], m) == -1
   31              0.000108       let m = m[0]
   31              0.000032     endif
   31              0.000265     let w:airline_current_mode = get(g:airline_mode_map, m, m)
                              else
                                let mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
   31              0.000034   endif
                            
   31              0.000198   if g:airline_detect_modified && &modified
                                call add(mode, 'modified')
   31              0.000031   endif
                            
   31              0.000096   if g:airline_detect_paste && &paste
                                call add(mode, 'paste')
   31              0.000027   endif
                            
   31              0.000535   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(mode, 'crypt')
   31              0.000029   endif
                            
   31              0.000121   if g:airline_detect_spell && &spell
                                call add(mode, 'spell')
   31              0.000030   endif
                            
   31              0.000104   if &readonly || ! &modifiable
   16              0.000110     call add(mode, 'readonly')
   31              0.000031   endif
                            
   31              0.000250   let mode_string = join(mode)
   31              0.000227   if get(w:, 'airline_lastmode', '') != mode_string
    7   0.005819   0.000198     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    7   0.097181   0.000238     call airline#highlighter#highlight(mode, string(context.bufnr))
    7   0.000508   0.000078     call airline#util#doautocmd('AirlineModeChanged')
    7              0.000014     let w:airline_lastmode = mode_string
   31              0.000024   endif
                            
   31              0.000051   return ''

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:49
Called 105 times
Total time:   0.001117
 Self time:   0.001117

count  total (s)   self (s)
  105              0.000268   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  105              0.000055   endif
  105              0.000331   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  105              0.000312   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#extensions#vimtex#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/vimtex.vim:44
Called 3 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    3              0.000013   if exists("b:vimtex")
                                let w:airline_section_x = get(w:, 'airline_section_x', g:airline_section_x)
                                let w:airline_section_x.=s:spc.g:airline_left_alt_sep.s:spc.'%{airline#extensions#vimtex#get_scope()}'
    3              0.000003   endif

FUNCTION  airline#extensions#tabline#add_label()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:30
Called 2 times
Total time:   0.000103
 Self time:   0.000050

count  total (s)   self (s)
    2              0.000009   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
    2   0.000088   0.000035     call a:dict.add_section_spaced('airline_tablabel'. (a:right ? '_right' : ''), get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
    2              0.000002   endif

FUNCTION  <SNR>123_Disable()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:309
Called 1 time
Total time:   0.000026
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000023   0.000005     if s:Filter() == 0
                                    call s:IndentLinesDisable()
                                    call s:LeadingSpaceDisable()
    1              0.000000     endif

FUNCTION  airline#util#try_focusgained()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:207
Called 2 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
                              " Ignore lasts for at most one second and is cleared on the first
                              " focusgained. We use ignore to prevent system() calls from triggering
                              " FocusGained (which occurs 100% on win32 and seem to sometimes occur under
                              " tmux).
    2              0.000026   let dt = localtime() - s:focusgained_ignore_time
    2              0.000011   let s:focusgained_ignore_time = 0
    2              0.000012   return dt >= 1

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:190
Called 13 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
   13              0.000038   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
   13              0.000044   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
    1              0.000004     let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
    1              0.000001     unlet! b:airline_head
   13              0.000005   endif

FUNCTION  <SNR>185_Tree()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:478
Called 15 times
Total time:   0.001030
 Self time:   0.000157

count  total (s)   self (s)
   15   0.001025   0.000151   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim:35
Called 182 times
Total time:   0.021382
 Self time:   0.001582

count  total (s)   self (s)
  182   0.021319   0.001518     return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:296
Called 7 times
Total time:   0.000128
 Self time:   0.000098

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    7              0.000056   let g:airline#visual_active = (mode() =~? '[vs]')
    7   0.000062   0.000032   call airline#update_tabline()

FUNCTION  <SNR>183_on_exit_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:72
Called 3 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    3              0.000008   if !a:exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    3              0.000002   endif

FUNCTION  FugitiveWorkTree()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:264
Called 15 times
Total time:   0.000874
 Self time:   0.000190

count  total (s)   self (s)
   15   0.000834   0.000151   let tree = s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))
   15              0.000019   if tree isnot# 0 || a:0 > 1
   15              0.000012     return tree
                              else
                                return ''
                              endif

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:15
Called 15 times
Total time:   0.000689
 Self time:   0.000631

count  total (s)   self (s)
   15              0.000038   if !exists('b:fugitive_name')
    2              0.000005     let b:fugitive_name = ''
    2              0.000001     try
    2              0.000012       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
    2              0.000008       elseif exists('b:git_dir') && exists('*fugitive#repo')
    2              0.000005         if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
    2              0.000001         endif
                                  elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
    2              0.000001       endif
                                catch
    2              0.000001     endtry
   15              0.000006   endif
                            
   15   0.000148   0.000090   let fmod = s:ModifierFlags()
   15              0.000022   if empty(b:fugitive_name)
   15              0.000030     if empty(bufname('%'))
                                  return &buftype ==# 'nofile' ? '[Scratch]' : '[No Name]'
   15              0.000006     endif
   15              0.000095     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  <SNR>90_on_refresh_event()
    Defined: ~/.vim/plugged/vim-hexokinase/autoload/hexokinase/v2.vim:54
Called 1 time
Total time:   0.001126
 Self time:   0.000048

count  total (s)   self (s)
    1              0.000003     let b:hexokinase_is_on = get(b:, 'hexokinase_is_on', 0)
    1              0.000002     let b:hexokinase_is_disabled = get(b:, 'hexokinase_is_disabled', 0)
    1              0.000001     if b:hexokinase_is_on
                                    call hexokinase#v2#scraper#on()
                                    return
    1              0.000000     endif
                            
    1              0.000001     if b:hexokinase_is_disabled
                                    return
    1              0.000000     endif
                            
    1              0.000001     if g:Hexokinase_termDisabled && &buftype ==# 'terminal'
                                    return
    1              0.000000     endif
                            
    1              0.000001     if !empty(g:Hexokinase_ftDisabled)
                                    if index(g:Hexokinase_ftDisabled, &filetype) > -1
                                        return
                                    endif
    1              0.000001     elseif has_key(g:, 'Hexokinase_ftEnabled')
                                    if index(g:Hexokinase_ftEnabled, &filetype) == -1
                                        return
                                    endif
    1              0.000000     endif
                            
    1   0.001105   0.000027     call hexokinase#v2#scraper#on()

FUNCTION  <SNR>175_tabline_evaluated_length()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:223
Called 10 times
Total time:   0.001179
 Self time:   0.000088

count  total (s)   self (s)
   10   0.001175   0.000085   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  airline#extensions#nvimlsp#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:17
Called 30 times
Total time:   0.001244
 Self time:   0.001244

count  total (s)   self (s)
   30              0.001185   if luaeval('vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
   30              0.000036     return ''
                              endif
                            
                              let error_symbol = get(g:, 'airline#extensions#nvimlsp#error_symbol', 'E:')
                              let warning_symbol = get(g:, 'airline#extensions#nvimlsp#warning_symbol', 'W:')
                            
                              let is_err = a:type ==# 'Error'
                            
                              let symbol = is_err ? error_symbol : warning_symbol
                            
                              if luaeval("pcall(require, 'vim.lsp.diagnostic')")
                                let num = v:lua.vim.lsp.diagnostic.get_count(0, a:type)
                              else
                                let num = v:lua.vim.lsp.util.buf_diagnostics_count(a:type)
                              endif
                            
                              return s:airline_nvimlsp_count(num, symbol)

FUNCTION  <SNR>183_on_stderr_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:66
Called 6 times
Total time:   0.000152
 Self time:   0.000057

count  total (s)   self (s)
    6              0.000017   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
    3   0.000122   0.000028     call self.handler.err(self.buffer)
    6              0.000003   endif

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:139
Called 3 times
Total time:   0.011518
 Self time:   0.000481

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
    3   0.000100   0.000034   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    3   0.001050   0.000090   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' ls-files --error-unmatch --full-name -z -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    3   0.000383   0.000148   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
    3              0.000022     let handler = copy(s:set_path_handler)
    3              0.000015     let handler.continuation = a:continuation
    3   0.009905   0.000128     call gitgutter#async#execute(cmd, a:bufnr, handler)
    3              0.000019     return 'async'
                              endif
                            
                              let path = gitgutter#utility#system(cmd)
                              if v:shell_error
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                              endif

FUNCTION  <SNR>185_ExpireStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:3972
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000002   if a:bufnr is# -2 || a:bufnr is# 0
    1              0.000009     let s:head_cache = {}
    1              0.000002     let s:last_time = reltime()
    1              0.000001     return ''
                              endif
                              let dir = s:Dir(a:bufnr)
                              if len(dir)
                                let s:last_times[s:cpath(dir)] = reltime()
                                if has_key(s:head_cache, dir)
                                  call remove(s:head_cache, dir)
                                endif
                              endif
                              return ''

FUNCTION  airline#extensions#tabline#buffers#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:51
Called 6 times
Total time:   0.016256
 Self time:   0.001034

count  total (s)   self (s)
    6              0.000020   try
    6   0.003707   0.000141     call <sid>map_keys()
                              catch
                                " no-op
    6              0.000015   endtry
    6              0.000050   let cur = bufnr('%')
    6              0.000054   if cur == s:current_bufnr && &columns == s:column_width
    4              0.000065     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
    4              0.000024       return s:current_tabline
                                endif
    2              0.000002   endif
                            
    2   0.000378   0.000053   let b = airline#extensions#tabline#new_builder()
    2              0.000016   let tab_bufs = tabpagebuflist(tabpagenr())
    2              0.000009   let show_buf_label_first = 0
                            
    2              0.000013   if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
    2              0.000003   endif
    2              0.000005   if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 0)
    2              0.000002   endif
                            
    2              0.000011   let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
    2              0.000007   let b.overflow_group = 'airline_tabhid'
    2   0.000605   0.000044   let b.buffers = airline#extensions#tabline#buflist#list()
    2              0.000008   if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
    2              0.000002   endif
                            
    2              0.000010   function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
    2              0.000015   if has("tablineat")
    2              0.000005     function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
    2              0.000004     function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
    2              0.000002   endif
                            
    2              0.000004   function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
    2              0.000021   let current_buffer = max([index(b.buffers, cur), 0])
    2              0.000010   let last_buffer = len(b.buffers) - 1
    2   0.000101   0.000031   call b.insert_titles(current_buffer, 0, last_buffer)
                            
    2   0.000034   0.000018   call b.add_section('airline_tabfill', '')
    2   0.000028   0.000012   call b.split()
    2   0.000025   0.000014   call b.add_section('airline_tabfill', '')
    2              0.000005   if !show_buf_label_first
    2   0.000144   0.000041     call airline#extensions#tabline#add_label(b, 'buffers', 1)
    2              0.000001   endif
                            
    2   0.000092   0.000035   call airline#extensions#tabline#add_tab_label(b)
                            
    2              0.000007   let s:current_bufnr = cur
    2              0.000007   let s:column_width = &columns
    2   0.010515   0.000019   let s:current_tabline = b.build()
    2              0.000005   let s:current_visible_buffers = copy(b.buffers)
                              " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                              "if b._right_title <= last_buffer
                              "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              "endif
                              "if b._left_title > 0
                              "  call remove(s:current_visible_buffers, 0, b._left_title)
                              "endif
    2              0.000002   return s:current_tabline

FUNCTION  <SNR>137_update_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:180
Called 15 times
Total time:   0.014560
 Self time:   0.000724

count  total (s)   self (s)
   45              0.000113   for vcs in keys(s:vcs_config)
   30   0.014122   0.000286     call {s:vcs_config[vcs].update_branch}()
   30              0.000094     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
    1              0.000002       let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
    1              0.000001       unlet! b:airline_head
   30              0.000013     endif
   45              0.000030   endfor

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:143
Called 17 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
   17              0.000039   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*fugitive#head') || exists('*FugitiveHead')
   17              0.000006   endif
   17              0.000019   return s:has_fugitive

FUNCTION  airline#highlighter#add_accent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:180
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003     let s:accents[a:accent] = 1

FUNCTION  startify#open_buffers()
    Defined: ~/.vim/plugged/vim-startify/autoload/startify.vim:404
Called 1 time
Total time:   0.037014
 Self time:   0.000122

count  total (s)   self (s)
    1              0.000036   if exists('a:1')  " used in mappings
    1              0.000019     let entry = b:startify.entries[a:1]
    1              0.000011     if !empty(s:batchmode) && entry.type == 'file'
                                  call startify#set_mark(s:batchmode, a:1)
    1              0.000003     else
    1   0.036930   0.000039       call s:open_buffer(entry)
    1              0.000000     endif
    1              0.000000     return
                              endif
                            
                              let marked = filter(copy(b:startify.entries), 'v:val.marked')
                              if empty(marked)  " open current entry
                                call s:open_buffer(b:startify.entries[line('.')])
                                return
                              endif
                            
                              enew
                              setlocal nobuflisted
                            
                              " Open all marked entries.
                              for entry in sort(values(marked), 's:sort_by_tick')
                                call s:open_buffer(entry)
                              endfor
                            
                              wincmd =
                            
                              if exists('#User#StartifyAllBuffersOpened')
                                doautocmd <nomodeline> User StartifyAllBuffersOpened
                              endif

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:102
Called 15 times
Total time:   0.000315
 Self time:   0.000210

count  total (s)   self (s)
   15   0.000307   0.000202   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  <SNR>33_LoadIndent()
    Defined: /usr/share/nvim/runtime/indent.vim:13
Called 1 time
Total time:   0.001123
 Self time:   0.000940

count  total (s)   self (s)
    1              0.000004     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    1              0.000001     endif
    1              0.000005     let s = expand("<amatch>")
    1              0.000002     if s != ""
    1              0.000002       if exists("b:did_indent")
                            	unlet b:did_indent
    1              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000008       for name in split(s, '\.')
    1   0.000664   0.000481         exe 'runtime! indent/' . name . '.vim'
    1              0.000424         exe 'runtime! indent/' . name . '.lua'
    2              0.000003       endfor
    1              0.000001     endif

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:82
Called 15 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
   15              0.000052   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   15              0.000008   endif
   15              0.000012   return ''

FUNCTION  <SNR>153_get_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:155
Called 20 times
Total time:   0.016012
 Self time:   0.000350

count  total (s)   self (s)
   20   0.005227   0.000135   if airline#builder#should_change_group(a:prev_group, a:group)
   19   0.010768   0.000198     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
    1              0.000000   else
    1              0.000002     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:290
Called 11 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
   11              0.000025   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
   11              0.000004   endif

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:14
Called 3 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    3              0.000035   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    3              0.000002   endif

FUNCTION  <SNR>134_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:99
Called 249 times
Total time:   0.002557
 Self time:   0.002557

count  total (s)   self (s)
  249              0.000713     if !hlexists(a:group)
                                  return 0
  249              0.001047     elseif empty(synIDattr(synIDtrans(hlID(a:group)), 'fg'))
                                  return 0
  249              0.000101     endif
  249              0.000166     return 1

FUNCTION  hexokinase#highlighters#backgroundfull#highlightv2()
    Defined: ~/.vim/plugged/vim-hexokinase/autoload/hexokinase/highlighters/backgroundfull.vim:34
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000003     for it in getbufvar(a:bufnr, 'hexokinase_colours', [])
                                    let it['hlname'] = hexokinase#utils#create_bg_hl(it.hex)
                                    if s:isNvim040
                                        call nvim_buf_add_highlight(     a:bufnr,     s:namespace,     it.hlname,     str2nr(it.lnum)-1,     str2nr(it.start)-1,     str2nr(it.end) )
                                    else
                                        let it['positions'] = [[it.lnum, it.start, it.end - it.start + 1]]
                                        let it['bgfull_check'] = 1
                                    endif
    1              0.000001     endfor
                            
    1              0.000002     if a:bufnr == bufnr('%') && !s:isNvim040
                                    call s:showhl()
    1              0.000000     endif

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 3 times
Total time:   0.009777
 Self time:   0.009502

count  total (s)   self (s)
    3   0.000362   0.000112   call gitgutter#debug#log('[async] '.a:cmd)
                            
    3              0.000026   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    3   0.000063   0.000038   let command = s:build_command(a:cmd)
                            
    3              0.000013   if has('nvim')
    3              0.009184     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
    3              0.000007   endif

FUNCTION  airline#extensions#tabline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:227
Called 2 times
Total time:   0.000184
 Self time:   0.000083

count  total (s)   self (s)
    2   0.000131   0.000031   let builder = airline#builder#new(a:context)
    2              0.000013   let builder._build = builder.build
    2              0.000030   call extend(builder, s:prototype, 'force')
    2              0.000007   return builder

FUNCTION  <SNR>137_config_fugitive_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:99
Called 15 times
Total time:   0.012462
 Self time:   0.000304

count  total (s)   self (s)
   15   0.012201   0.000151   let s:vcs_config['git'].branch = exists('*FugitiveHead') ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
   15   0.000223   0.000114   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
   15              0.000006   endif

FUNCTION  <SNR>183_on_stdout_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:56
Called 3 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    3              0.000007   if empty(self.stdoutbuffer)
    3              0.000007     let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
    3              0.000001   endif

FUNCTION  <SNR>185_Slash()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:138
Called 15 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
   15              0.000023     return a:path

FUNCTION  <SNR>127_check_defined_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:47
Called 3 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    3              0.000024   if !exists('w:airline_section_{a:name}')
    3              0.000023     let w:airline_section_{a:name} = g:airline_section_{a:name}
    3              0.000003   endif

FUNCTION  <SNR>84_on_window_changed()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:51
Called 3 times
Total time:   0.006547
 Self time:   0.000110

count  total (s)   self (s)
                              " don't trigger for Vim popup windows
    3              0.000008   if &buftype is# 'popup'
                                return
    3              0.000001   endif
                            
    3              0.000007   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                " do not trigger for previewwindows
                                return
    3              0.000001   endif
    3              0.000008   let s:active_winnr = winnr()
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    3              0.000026   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
    3              0.000029   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    2              0.000001     return
    1              0.000000   endif
    1              0.000002   let g:airline_last_window_changed = l:key
    1   0.000008   0.000006   call s:init()
    1   0.006438   0.000005   call airline#update_statusline()

FUNCTION  airline#extensions#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:71
Called 3 times
Total time:   0.000842
 Self time:   0.000308

count  total (s)   self (s)
    3              0.000025   let filetype_overrides = get(s:, 'filetype_overrides', {})
    3              0.000033   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
    3   0.000271   0.000044   if s:is_excluded_window()
                                return -1
    3              0.000002   endif
                            
    3              0.000010   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
    3              0.000002   endif
                            
    3              0.000012   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
    3              0.000002   endif
                            
    3              0.000044   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
    1              0.000013     let args = filetype_overrides[&ft]
    1   0.000335   0.000028     call airline#extensions#apply_left_override(args[0], args[1])
    3              0.000001   endif
                            
    3              0.000004   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
    3              0.000001   endif
                            
    3              0.000011   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
    3              0.000002   endfor

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:102
Called 3 times
Total time:   0.000150
 Self time:   0.000044

count  total (s)   self (s)
    3   0.000148   0.000042   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  airline#extensions#tabline#buflist#list()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:39
Called 7 times
Total time:   0.000591
 Self time:   0.000436

count  total (s)   self (s)
    7              0.000027   if exists('s:current_buffer_list')
    5              0.000008     return s:current_buffer_list
    2              0.000002   endif
                            
    2              0.000012   let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
    2              0.000010   let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
    2              0.000009   let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
    2              0.000021   let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
    2              0.000004   let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
    6              0.000017   for nr in list
    4              0.000014     if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
    2              0.000009       if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
    2              0.000012       elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
    2   0.000145   0.000032       elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
    2   0.000081   0.000039       elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
    2              0.000002       endif
                            
    2              0.000011       call add(buffers, nr)
    4              0.000004     endif
    6              0.000012   endfor
                            
    2              0.000008   let s:current_buffer_list = buffers
    2              0.000005   return buffers

FUNCTION  <SNR>186_nvim_output_handler()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:232
Called 5 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    5              0.000009     if a:event == 'stdout' || a:event == 'stderr'
    5              0.000013       let self.buf .=  join(a:data)
    5              0.000002     endif

FUNCTION  airline#builder#get_next_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:49
Called 2 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000002   let x = a:i + 1
    2              0.000003   let l = len(a:sections)
    4              0.000003   while x < l
    4              0.000006     let group = a:sections[x][0]
    4              0.000005     if group != '' && group != '|'
    2              0.000001       return group
    2              0.000001     endif
    2              0.000002     let x = x + 1
    2              0.000001   endwhile
                              return ''

FUNCTION  <SNR>175_evaluate_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:209
Called 10 times
Total time:   0.001064
 Self time:   0.000334

count  total (s)   self (s)
   10              0.000011   let tabline = a:tabline
   10   0.000804   0.000074   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
   10              0.000077   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
   10              0.000039   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
   10              0.000027   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
   10              0.000023   let tabline = substitute(tabline, '%=', '', 'g')
   10              0.000022   let tabline = substitute(tabline, '%\d*\*', '', 'g')
   10              0.000019   if has('tablineat')
   10              0.000022     let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
   10              0.000004   endif
   10              0.000007   return tabline

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/po.vim:64
Called 3 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    3              0.000024   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * call s:autocmd_handler()
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
    3              0.000002   endif

FUNCTION  <SNR>140_ws_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:186
Called 5 times
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
    5              0.000057   if !exists('#airline')
                                " airline disabled
                                return
    5              0.000008   endif
    5              0.000065   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    4              0.000009     return
    1              0.000002   endif
    1              0.000021   unlet! b:airline_whitespace_check
    1              0.000016   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
    1              0.000002   endif
    1              0.000014   let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>123_IndentLinesDisable()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:209
Called 1 time
Total time:   0.000140
 Self time:   0.000131

count  total (s)   self (s)
    1              0.000001     if g:indentLine_newVersion
    1              0.000005         if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
   21              0.000012             for id in w:indentLine_indentLineId
   20              0.000007                 try
   20              0.000056                     call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
   20              0.000007                 endtry
   21              0.000008             endfor
    1              0.000008             let w:indentLine_indentLineId = []
    1              0.000000         endif
                            
    1   0.000019   0.000010         call s:ResetConcealOption()
    1              0.000001         return
                                endif
                            
                                let b:indentLine_enabled = 0
                                try
                                    syntax clear IndentLine
                                    syntax clear IndentLineSpace
                                catch /^Vim\%((\a\+)\)\=:E28/	" catch error E28
                                endtry

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:164
Called 3 times
Total time:   0.000725
 Self time:   0.000134

count  total (s)   self (s)
    3   0.000352   0.000088   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    3   0.000370   0.000043   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>155_setup_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:156
Called 3 times
Total time:   0.011817
 Self time:   0.000149

count  total (s)   self (s)
    3   0.000186   0.000036   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
    3   0.011614   0.000095   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  <SNR>133_create()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:17
Called 1 time
Total time:   0.000253
 Self time:   0.000227

count  total (s)   self (s)
    1              0.000004   let _ = ''
    2              0.000011   for idx in range(len(a:parts))
    1   0.000032   0.000021     let part = airline#parts#get(a:parts[idx])
    1              0.000003     let val = ''
    1              0.000007     let add_sep = get(l:, 'add_sep', 0)
                            
    1              0.000006     if exists('part.function')
    1              0.000007       let func = (part.function).'()'
                                elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let t = ''
                                    if !add_sep
                                      let t = s:spc.g:airline_right_alt_sep.s:spc
                                    endif
                                    let val = t.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
    1              0.000001     endif
                            
    1              0.000007     let minwidth = get(part, 'minwidth', 0)
                            
    1              0.000005     if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
    1              0.000021     elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
    1              0.000000     else
    1              0.000004       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
    1              0.000001       let add_sep = 0
    1              0.000000     endif
                            
    1              0.000001     if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
    1              0.000000     endif
                            
    1   0.000022   0.000007     let val .= s:wrap_accent(part, partval)
    1              0.000002     let _ .= val
    2              0.000002   endfor
    1              0.000001   return _

FUNCTION  <SNR>137_update_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:87
Called 15 times
Total time:   0.013063
 Self time:   0.000371

count  total (s)   self (s)
   15   0.000237   0.000106   call airline#util#ignore_next_focusgain()
   15   0.000178   0.000079   if airline#util#has_fugitive()
   15   0.012558   0.000096     call s:config_fugitive_branch()
                              elseif airline#util#has_gina()
                                call s:config_gina_branch()
                              else
                                let s:vcs_config['git'].branch = ''
                                return
   15              0.000006   endif

FUNCTION  320()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:18
Called 2 times
Total time:   0.000070
 Self time:   0.000059

count  total (s)   self (s)
    2              0.000009   let self._first_title = a:first " lowest index
    2              0.000006   let self._last_title = a:last " highest index
    2              0.000005   let self._left_title = a:current " next index to add on the left
    2              0.000007   let self._right_title = a:current + 1 " next index to add on the right
    2   0.000034   0.000022   let self._left_position = self.get_position() " left end of titles
    2              0.000006   let self._right_position = self._left_position " right end of the titles

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:19
Called 187 times
Total time:   0.001862
 Self time:   0.001862

count  total (s)   self (s)
  187              0.000620   let nr = get(a:000, 0, 0)
  187              0.000396   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
  187              0.000115   else
  187              0.000389     return winwidth(nr)
                              endif

FUNCTION  322()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:96
Called 2 times
Total time:   0.010496
 Self time:   0.000338

count  total (s)   self (s)
    2              0.000013   if has_key(self, '_left_position') && self._first_title <= self._last_title
    2   0.003949   0.000037     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
    2              0.000005     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
    2   0.000073   0.000012     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
    2   0.000067   0.000010     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
    2   0.000028   0.000012     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
    2   0.000041   0.000013     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
    2              0.000006     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
    2   0.000075   0.000011     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
    2              0.000002     if self._left_title > self._first_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
    2              0.000001     endif
    2              0.000002     if self._left_title < self._last_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
    2              0.000001     endif
                            
                                " Add the current title
    2   0.000071   0.000008     let group = self.get_group(self._left_title)
    2              0.000002     if self._left_title == self._first_title
    2   0.000055   0.000014       let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
                                else
                                  let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    2              0.000001     endif
    2              0.000002     if self._left_title == self._last_title
    2   0.000472   0.000012       let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
                                else
                                  let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    2              0.000001     endif
    2              0.000002     let left_group = group
    2              0.000002     let right_group = group
    2   0.001135   0.000014     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
    2              0.000004     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
    2              0.000001     endif
                            
    2              0.000003     if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
                                  let group = self.get_group(self._right_title)
                                  if self._right_title == self._last_title
                                    let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                  else
                                    let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                  endif
                                  let right_group = group
                                  let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
    2              0.000001     endif
                            
    2              0.000002     while self._remaining_space > 0
    2              0.000002       let done = 0
    2              0.000002       if self._left_title >= self._first_title
                                    " Insert next title to the left
                                    let group = self.get_group(self._left_title)
                                    if self._left_title == self._first_title
                                      let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let left_group = group
                                    let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
                                    let self._left_title -= done
    2              0.000001       endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
    2              0.000003       if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
                                    let group = self.get_group(self._right_title)
                                    if self._right_title == self._last_title
                                      let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let right_group = group
                                    let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
                                    let self._right_title += done
    2              0.000001       endif
    2              0.000001       if !done
    2              0.000001         break
                                  endif
    2              0.000002     endwhile
                            
    2              0.000002     if self._left_title >= self._first_title
                                  if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
                                  call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                  let self._right_position += 1
    2              0.000001     endif
                            
    2              0.000002     if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
    2              0.000001     endif
    2              0.000001   endif
                            
    2   0.004343   0.000009   return self._build()

FUNCTION  <SNR>73_DevIconsGetArtifactFix()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:546
Called 5 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    5              0.000010   if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
    5              0.000003   else
    5              0.000008     let artifactFix = ''
    5              0.000003   endif
                            
    5              0.000008   return artifactFix

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:42
Called 136 times
Total time:   0.001129
 Self time:   0.000881

count  total (s)   self (s)
  136   0.000751   0.000503   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
   15              0.000017     return ''
  121              0.000064   endif
  121              0.000130   return a:text

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:176
Called 10 times
Total time:   0.001153
 Self time:   0.000342

count  total (s)   self (s)
   10              0.000061   if !exists('#airline') && a:event !=? 'AirlineToggledOff'
                                " airline disabled
                                return
   10              0.000008   endif
   10   0.001054   0.000244   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  <SNR>156_check_user_options()
    Defined: ~/.vim/plugged/vim-startify/autoload/startify.vim:955
Called 1 time
Total time:   0.000066
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000003   let session = a:path . s:sep .'Session.vim'
                            
    1              0.000003   if get(g:, 'startify_session_autoload') && filereadable(glob(session))
                                execute 'silent bwipeout' a:path
                                call startify#session_delete_buffers()
                                execute 'source' session
                                return
    1              0.000000   endif
                            
    1              0.000002   if get(g:, 'startify_change_to_vcs_root') && s:cd_to_vcs_root(a:path)
                                return
    1              0.000000   endif
                            
    1              0.000001   if get(g:, 'startify_change_to_dir', 1)
    1              0.000008     if isdirectory(a:path)
                                  execute s:cd_cmd() a:path
    1              0.000000     else
    1              0.000002       let dir = fnamemodify(a:path, ':h')
    1              0.000003       if isdirectory(dir)
    1   0.000032   0.000017         execute s:cd_cmd() dir
                                  else
                                    " Do nothing. E.g. a:path == `scp://foo/bar`
    1              0.000000       endif
    1              0.000000     endif
    1              0.000000   endif

FUNCTION  FugitiveIsGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:273
Called 2 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000005   if !a:0 || type(a:1) !=# type('')
                                return !empty(call('FugitiveGitDir', a:000))
    2              0.000001   endif
    2              0.000008   let path = substitute(a:1, '[\/]$', '', '') . '/'
    2              0.000017   return len(path) && getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  nerdtree#checkForBrowse()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:61
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000009     if !isdirectory(a:dir)
    1              0.000001         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  <SNR>171_on_exit()
    Defined: ~/.vim/plugged/vim-hexokinase/autoload/hexokinase/v2/scraper.vim:129
Called 1 time
Total time:   0.000091
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000015     call delete(self.tmpname)
    1   0.000038   0.000007     call s:clear_hl(self.bufnr)
    1              0.000001     if a:status
                                    return
    1              0.000000     endif
    1              0.000003     call setbufvar(self.bufnr, 'hexokinase_colours', self.colours)
    2              0.000003     for F in g:Hexokinase_highlightCallbacks
    1   0.000028   0.000010         call F(self.bufnr)
    2              0.000001     endfor

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:37
Called 46 times
Total time:   0.000533
 Self time:   0.000533

count  total (s)   self (s)
   46              0.000084   let x = a:i - 1
   56              0.000062   while x >= 0
   45              0.000090     let group = a:sections[x][0]
   45              0.000085     if group != '' && group != '|'
   35              0.000033       return group
   10              0.000005     endif
   10              0.000010     let x = x - 1
   21              0.000018   endwhile
   11              0.000010   return ''

FUNCTION  <SNR>138_sh_autocmd_handler()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:46
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000011   if exists('#airline')
    2              0.000008     unlet! b:fugitive_name
    2              0.000003   endif

FUNCTION  <SNR>186_set_clean_jobs_variable()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:80
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000007   if !has_key(s:clean_jobs, a:vcs)
                                let s:clean_jobs[a:vcs] = {}
    1              0.000001   endif
    1              0.000005   let s:clean_jobs[a:vcs][a:file]=a:id

FUNCTION  airline#extensions#tabline#get_buffer_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:228
Called 5 times
Total time:   0.002212
 Self time:   0.000238

count  total (s)   self (s)
    5   0.000089   0.000060     let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
    5              0.000023     let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
    5   0.002095   0.000150     return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  <SNR>185_ReloadWinStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:3988
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   if get(b:, 'fugitive_type', '') !=# 'index' || &modified
    1              0.000001     return
                              endif
                              if !exists('b:fugitive_reltime')
                                exe s:ReloadStatusBuffer()
                                return
                              endif
                              let t = b:fugitive_reltime
                              if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' || reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatusBuffer()
                              endif

FUNCTION  <SNR>108_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:40
Called 2 times
Total time:   0.000130
 Self time:   0.000120

count  total (s)   self (s)
                              " Remove any previous match.
    2   0.000020   0.000010   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    2              0.000007   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
    2              0.000001   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    2              0.000005   let c_lnum = line('.')
    2              0.000006   let c_col = col('.')
    2              0.000002   let before = 0
                            
    2              0.000005   let text = getline(c_lnum)
    2              0.000024   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    2              0.000003   if empty(matches)
                                let [c_before, c] = ['', '']
    2              0.000001   else
    2              0.000006     let [c_before, c] = matches[1:2]
    2              0.000001   endif
    2              0.000012   let plist = split(&matchpairs, '.\zs[:,]')
    2              0.000004   let i = index(plist, c)
    2              0.000001   if i < 0
                                " not found, in Insert mode try character before the cursor
    2              0.000006     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
    2              0.000001     endif
    2              0.000001     if i < 0
                                  " not found, nothing to do
    2              0.000001       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>156_open_buffer()
    Defined: ~/.vim/plugged/vim-startify/autoload/startify.vim:527
Called 1 time
Total time:   0.036891
 Self time:   0.002232

count  total (s)   self (s)
    1              0.000010   if a:entry.type == 'special'
                                execute a:entry.cmd
    1              0.000005   elseif a:entry.type == 'session'
                                execute a:entry.cmd a:entry.path
    1              0.000004   elseif a:entry.type == 'file'
    1              0.000010     if line2byte('$') == -1
                                  execute 'edit' a:entry.path
    1              0.000002     else
    1              0.000004       if a:entry.cmd == 'tabnew'
                                    wincmd =
    1              0.000002       endif
    1   0.036752   0.002158       execute a:entry.cmd a:entry.path
    1              0.000000     endif
    1   0.000076   0.000010     call s:check_user_options(a:entry.path)
    1              0.000000   endif
    1              0.000005   if exists('#User#StartifyBufferOpened')
                                doautocmd <nomodeline> User StartifyBufferOpened
    1              0.000000   endif

FUNCTION  <SNR>140_check_mixed_indent_file()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:34
Called 2 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    2              0.000011   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    2              0.000009   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
    2              0.000001   else
    2              0.000003     let head_spc = '\v(^ +)'
    2              0.000001   endif
    2              0.000013   let indent_tabs = search('\v(^\t+)', 'nw')
    2              0.000019   let indent_spc  = search(head_spc, 'nw')
    2              0.000003   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
    2              0.000001   else
    2              0.000002     return ''
                              endif

FUNCTION  <SNR>134_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:44
Called 2052 times
Total time:   0.032239
 Self time:   0.032239

count  total (s)   self (s)
 2052              0.002198     let color = ''
 2052              0.004666     if hlexists(a:group)
 2044              0.007961       let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
 2052              0.000946     endif
 2052              0.003277     if empty(color) || color == -1
                                  " should always exist
    8              0.000044       let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                  " however, just in case
    8              0.000009       if empty(color) || color == -1
    6              0.000004         let color = 'NONE'
    8              0.000003       endif
 2052              0.000692     endif
 2052              0.001724     return color

FUNCTION  <SNR>140_check_mixed_indent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:17
Called 2 times
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
    2              0.000006   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    2              0.000002   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
    2              0.000002   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw', 0, 500)
    2              0.000001   else
    2              0.000127     return search('\v(^\t+ +)|(^ +\t+)', 'nw', 0, 500)
                              endif

FUNCTION  <SNR>77_filename()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:219
Called 3 times
Total time:   0.000199
 Self time:   0.000028

count  total (s)   self (s)
    3   0.000197   0.000027   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  <SNR>153_section_is_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:182
Called 44 times
Total time:   0.000445
 Self time:   0.000445

count  total (s)   self (s)
   44              0.000064   let start=1
                            
                              " do not check for inactive windows or the tabline
   44              0.000064   if a:self._context.active == 0
                                return 0
   44              0.000110   elseif get(a:self._context, 'tabline', 0)
   22              0.000015     return 0
   22              0.000009   endif
                            
                              " only check, if airline#skip_empty_sections == 1
   22              0.000040   if get(g:, 'airline_skip_empty_sections', 0) == 0
   22              0.000013     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  airline#extensions#tabline#new_builder()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:234
Called 2 times
Total time:   0.000325
 Self time:   0.000141

count  total (s)   self (s)
    2              0.000040     let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
    2              0.000007     if get(g:, 'airline_powerline_fonts', 0)
                                  let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
                                  let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
    2              0.000002     else
    2              0.000015       let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
    2              0.000012       let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
    2              0.000002     endif
                            
    2   0.000220   0.000036     return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  <SNR>77_exists_file()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:223
Called 7 times
Total time:   0.000970
 Self time:   0.000177

count  total (s)   self (s)
    7   0.000965   0.000172   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  airline#section#create()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:74
Called 1 time
Total time:   0.000274
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000273   0.000020   return s:create(a:parts, 0)

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:79
Called 3 times
Total time:   0.002673
 Self time:   0.000181

count  total (s)   self (s)
    3              0.000007   let winnr = a:context.winnr
    3              0.000004   let active = a:context.active
                            
    3   0.000035   0.000022   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    3   0.000936   0.000031     call s:build_sections(a:builder, a:context, s:layout[0])
                              else
                                let text = !empty(s:get_section(winnr, 'c')) ? s:get_section(winnr, 'c') : ' %f%m '
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    3              0.000001   endif
                            
    3   0.000168   0.000046   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    3   0.000024   0.000017   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    2   0.001464   0.000021     call s:build_sections(a:builder, a:context, s:layout[1])
    3              0.000001   endif
                            
    3              0.000002   return 1

FUNCTION  airline#util#stl_disabled()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:189
Called 6 times
Total time:   0.000632
 Self time:   0.000437

count  total (s)   self (s)
                              " setting the statusline is disabled,
                              " either globally, per window, or per buffer
                              " w:airline_disabled is deprecated!
    6   0.000605   0.000409   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  FugitiveVimPath()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:433
Called 15 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
   15              0.000043   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
   15              0.000007   else
   15              0.000014     return a:path
                              endif

FUNCTION  <SNR>84_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:83
Called 2 times
Total time:   0.000033
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000008   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
    2              0.000001   endif
    2   0.000021   0.000010   call airline#update_tabline()

FUNCTION  <SNR>143_update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:127
Called 1 time
Total time:   0.008462
 Self time:   0.000168

count  total (s)   self (s)
    1              0.000013     if get(g:, 'airline#extensions#tabline#disable_refresh', 0)
                                  return
    1              0.000002     endif
                                " loading a session file
                                " On SessionLoadPost, g:SessionLoad variable is still set :/
    1              0.000009     if !a:forceit && get(g:, 'SessionLoad', 0)
                                  return
    1              0.000001     endif
    1              0.000020     let match = expand('<afile>')
    1              0.000005     if pumvisible()
                                  return
    1              0.000007     elseif !get(g:, 'airline#extensions#tabline#enabled', 0)
                                  return
                                " return, if buffer matches ignore pattern or is directory (netrw)
    1   0.000162   0.000045     elseif empty(match) || airline#util#ignore_buf(match) || isdirectory(match)
                                  return
    1              0.000002     endif
    1   0.000266   0.000024     call airline#util#doautocmd('BufMRUChange')
    1   0.007955   0.000020     call airline#extensions#tabline#redraw()

FUNCTION  hexokinase#utils#get_background_hex()
    Defined: ~/.vim/plugged/vim-hexokinase/autoload/hexokinase/utils.vim:51
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000002     if !empty(get(g:, 'Hexokinase_alpha_bg', ''))
                                    return g:Hexokinase_alpha_bg
    1              0.000003     elseif len(g:Hexokinase_highlighters) == 1 && g:Hexokinase_highlighters[0] ==# 'sign_column'
                                    return synIDattr(hlID('SignColumn'), 'bg')
    1              0.000000     else
    1              0.000010         return synIDattr(hlID('Normal'), 'bg')
                                endif

FUNCTION  FugitiveGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:18
Called 60 times
Total time:   0.002249
 Self time:   0.002183

count  total (s)   self (s)
   60              0.000074   if v:version < 703
                                return ''
   60              0.000233   elseif !a:0 || type(a:1) == type(0) && a:1 < 0 || a:1 is# get(v:, 'true', -1)
   15              0.000028     if exists('g:fugitive_event')
                                  return g:fugitive_event
   15              0.000007     endif
   15              0.000041     let dir = get(b:, 'git_dir', '')
   15              0.000043     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|terminal\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
   15              0.000151     elseif (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && empty(&buftype)
                                  let b:git_dir = FugitiveExtractGitDir(expand('%:p'))
                                  return b:git_dir
   15              0.000006     endif
   15              0.000075     return dir =~# s:bad_git_dir ? '' : dir
   45              0.000077   elseif type(a:1) == type(0) && a:1 isnot# 0
                                if a:1 == bufnr('') && (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && empty(&buftype)
                                  let b:git_dir = FugitiveExtractGitDir(expand('%:p'))
                                endif
                                let dir = getbufvar(a:1, 'git_dir')
                                return dir =~# s:bad_git_dir ? '' : dir
   45              0.000065   elseif type(a:1) == type('')
   45   0.000444   0.000379     return substitute(s:Slash(a:1), '/$', '', '')
                              elseif type(a:1) == type({})
                                return get(a:1, 'git_dir', '')
                              else
                                return ''
                              endif

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 3 times
Total time:   0.000175
 Self time:   0.000175

count  total (s)   self (s)
    3              0.000009   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
    3              0.000003   endif

FUNCTION  <SNR>134_GetHiCmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:140
Called 38 times
Total time:   0.003109
 Self time:   0.003109

count  total (s)   self (s)
                                " a:list needs to have 5 items!
   38              0.000052     let res = ''
   38              0.000062     let i = -1
  228              0.000186     while i < 4
  190              0.000174       let i += 1
  190              0.000340       let item = get(a:list, i, '')
  190              0.000164       if item is ''
   30              0.000021         continue
  160              0.000051       endif
  160              0.000103       if i == 0
   38              0.000088         let res .= ' guifg='.item
  122              0.000071       elseif i == 1
   38              0.000056         let res .= ' guibg='.item
   84              0.000045       elseif i == 2
   38              0.000057         let res .= ' ctermfg='.item
   46              0.000023       elseif i == 3
   38              0.000054         let res .= ' ctermbg='.item
    8              0.000005       elseif i == 4
    8              0.000034         let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
  160              0.000058       endif
  198              0.000128     endwhile
   38              0.000049     return res

FUNCTION  <SNR>77_unc_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:169
Called 3 times
Total time:   0.000212
 Self time:   0.000035

count  total (s)   self (s)
    3   0.000210   0.000034   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>77_is_file_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:63
Called 7 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    7              0.000082   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  186()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:37
Called 5 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    5              0.000020     return 'NERD_tree_'

FUNCTION  AutoPairsDefaultPairs()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:20
Called 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000002   if exists('b:autopairs_defaultpairs')
                                return b:autopairs_defaultpairs
    1              0.000000   end
    1              0.000005   let r = copy(g:AutoPairs)
    1              0.000005   let allPairs = { 'vim': {'\v^\s*\zs"': ''}, 'rust': {'\w\zs<': '>', '&\zs''': ''}, 'php': {'<?': '?>//k]', '<?php': '?>//k]'} }
    4              0.000008   for [filetype, pairs] in items(allPairs)
    3              0.000004     if &filetype == filetype
                                  for [open, close] in items(pairs)
                                    let r[open] = close
                                  endfor
    3              0.000001     end
    4              0.000002   endfor
    1              0.000001   let b:autopairs_defaultpairs = r
    1              0.000001   return r

FUNCTION  airline#util#getwinvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:82
Called 42 times
Total time:   0.000235
 Self time:   0.000235

count  total (s)   self (s)
   42              0.000213     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  FugitiveDetect()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:404
Called 1 time
Total time:   0.000277
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000002   if v:version < 703
                                return ''
    1              0.000000   endif
    1              0.000002   if exists('b:git_dir') && b:git_dir =~# '^$\|' . s:bad_git_dir
                                unlet b:git_dir
    1              0.000000   endif
    1              0.000001   if !exists('b:git_dir')
    1   0.000262   0.000009     let b:git_dir = FugitiveExtractGitDir(a:0 ? a:1 : bufnr(''))
    1              0.000000   endif
    1              0.000006   if empty(b:git_dir) || !exists('#User#Fugitive')
    1              0.000001     return ''
                              endif
                              if v:version >= 704 || (v:version == 703 && has('patch442'))
                                doautocmd <nomodeline> User Fugitive
                              elseif &modelines > 0
                                let modelines = &modelines
                                try
                                  set modelines=0
                                  doautocmd User Fugitive
                                finally
                                  let &modelines = modelines
                                endtry
                              else
                                doautocmd User Fugitive
                              endif
                              return ''

FUNCTION  airline#extensions#tabline#buffers#invalidate()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:47
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000007   let s:current_bufnr = -1

FUNCTION  <SNR>136_get_hunks_gitgutter()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:60
Called 15 times
Total time:   0.001818
 Self time:   0.000316

count  total (s)   self (s)
   15   0.000287   0.000161   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
    3              0.000002     return ''
   12              0.000008   endif
   12   0.001497   0.000122   return GitGutterGetHunkSummary()

FUNCTION  <SNR>137_update_hg_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:145
Called 15 times
Total time:   0.000773
 Self time:   0.000686

count  total (s)   self (s)
   15   0.000169   0.000082   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
   15              0.000006   else
   15              0.000033     let s:vcs_config['mercurial'].branch = ''
   15              0.000006   endif

FUNCTION  airline#extensions#tabline#formatters#webdevicons#format()
    Defined: ~/.vim/plugged/vim-devicons/autoload/airline/extensions/tabline/formatters/webdevicons.vim:6
Called 5 times
Total time:   0.001907
 Self time:   0.000334

count  total (s)   self (s)
                              " Call original formatter.
    5   0.000829   0.000238   let originalFormatter = airline#extensions#tabline#formatters#{g:_webdevicons_airline_orig_formatter}#format(a:bufnr, a:buffers)
    5   0.001070   0.000087   return originalFormatter . g:WebDevIconsTabAirLineBeforeGlyphPadding . WebDevIconsGetFileTypeSymbol(bufname(a:bufnr)) . g:WebDevIconsTabAirLineAfterGlyphPadding

FUNCTION  AutoPairsInit()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:471
Called 1 time
Total time:   0.000965
 Self time:   0.000676

count  total (s)   self (s)
    1              0.000003   let b:autopairs_loaded  = 1
    1              0.000002   if !exists('b:autopairs_enabled')
    1              0.000001     let b:autopairs_enabled = 1
    1              0.000000   end
                            
    1              0.000001   if !exists('b:AutoPairs')
    1   0.000054   0.000013     let b:AutoPairs = AutoPairsDefaultPairs()
    1              0.000000   end
                            
    1              0.000002   if !exists('b:AutoPairsMoveCharacter')
    1              0.000004     let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
    1              0.000000   end
                            
    1              0.000001   let b:autopairs_return_pos = 0
    1              0.000002   let b:autopairs_saved_pair = [0, 0]
    1              0.000001   let b:AutoPairsList = []
                            
                              " buffer level map pairs keys
                              " n - do not map the first charactor of closed pair to close key
                              " m - close key jumps through multi line
                              " s - close key jumps only in the same line
   10              0.000019   for [open, close] in items(b:AutoPairs)
    9              0.000013     let o = open[-1:-1]
    9              0.000008     let c = close[0]
    9              0.000017     let opt = {'mapclose': 1, 'multiline':1}
    9              0.000012     let opt['key'] = c
    9              0.000007     if o == c
    6              0.000008       let opt['multiline'] = 0
    9              0.000003     end
    9              0.000047     let m = matchlist(close, '\v(.*)//(.*)$')
    9              0.000010     if len(m) > 0 
                                  if m[2] =~ 'n'
                                    let opt['mapclose'] = 0
                                  end
                                  if m[2] =~ 'm'
                                    let opt['multiline'] = 1
                                  end
                                  if m[2] =~ 's'
                                    let opt['multiline'] = 0
                                  end
                                  let ks = matchlist(m[2], '\vk(.)')
                                  if len(ks) > 0
                                    let opt['key'] = ks[1]
                                    let c = opt['key']
                                  end
                                  let close = m[1]
    9              0.000002     end
    9   0.000196   0.000039     call AutoPairsMap(o)
    9              0.000014     if o != c && c != '' && opt['mapclose']
    3   0.000060   0.000011       call AutoPairsMap(c)
    9              0.000003     end
    9              0.000023     let b:AutoPairsList += [[open, close, opt]]
   10              0.000005   endfor
                            
                              " sort pairs by length, longer pair should have higher priority
    1   0.000093   0.000052   let b:AutoPairsList = sort(b:AutoPairsList, "s:sortByLength")
                            
   10              0.000006   for item in b:AutoPairsList
    9              0.000010     let [open, close, opt] = item
    9              0.000007     if open == "'" && open == close
    1              0.000001       let item[0] = '\v(^|\W)\zs'''
    9              0.000002     end
   10              0.000003   endfor
                            
                            
    9              0.000014   for key in split(b:AutoPairsMoveCharacter, '\s*')
    8              0.000021     let escaped_key = substitute(key, "'", "''", 'g')
    8              0.000076     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
    9              0.000004   endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
    1              0.000001   if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
    1              0.000007     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsMapCh
    1              0.000008     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
    1              0.000000   endif
                            
    1              0.000001   if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
    1              0.000001     let do_abbrev = ""
    1              0.000002     if v:version == 703 && has("patch489") || v:version > 703
    1              0.000001       let do_abbrev = "<C-]>"
    1              0.000000     endif
    1              0.000008     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutFastWrap != ''
    1              0.000007     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutBackInsert != ''
    1              0.000008     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
    1              0.000007     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
    1              0.000008     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
    1              0.000000   end
                            
    1              0.000001   if g:AutoPairsShortcutJump != ''
    1              0.000010     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
    1              0.000007     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
    1              0.000000   end
                            
    1              0.000003   if &keymap != ''
                                let l:imsearch = &imsearch
                                let l:iminsert = &iminsert
                                let l:imdisable = &imdisable
                                execute 'setlocal keymap=' . &keymap
                                execute 'setlocal imsearch=' . l:imsearch
                                execute 'setlocal iminsert=' . l:iminsert
                                if l:imdisable
                                  execute 'setlocal imdisable'
                                else
                                  execute 'setlocal noimdisable'
                                end
    1              0.000000   end
                            

FUNCTION  <SNR>186_set_clean_variables()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:67
Called 1 time
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    1              0.000018   let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
    1              0.000016   if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') && type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
    1              0.000005     let var[a:vcs].dirty=a:val
    1              0.000001     try
    1              0.000011       call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
    1              0.000002       unlet! b:airline_head
                                catch
    1              0.000001     endtry
    1              0.000001   endif

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:76
Called 15 times
Total time:   0.002353
 Self time:   0.000535

count  total (s)   self (s)
   15              0.000074   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    1              0.000002     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
    1              0.000002     elseif exists('*GitGutterGetHunkSummary')
    1              0.000001       let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
                                else
                                  let b:source_func = 's:get_hunks_empty'
    1              0.000000     endif
   15              0.000008   endif
   15   0.002002   0.000184   return {b:source_func}()

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:34
Called 5 times
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
    5              0.000020     let buf_nr_format = get(g:, 'airline#extensions#tabline#buffer_nr_format', '%s: ')
    5              0.000016     let buf_nr_show = get(g:, 'airline#extensions#tabline#buffer_nr_show', 0)
                            
    5              0.000017     let _ = buf_nr_show ? printf(buf_nr_format, a:bufnr) : ''
    5              0.000035     let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
    5              0.000019     if getbufvar(a:bufnr, '&modified') == 1
                                  let _ .= g:airline_symbols.modified
    5              0.000003     endif
    5              0.000007     return _

FUNCTION  airline#async#nvim_vcs_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:336
Called 2 times
Total time:   0.001086
 Self time:   0.001072

count  total (s)   self (s)
    2              0.000009   let cmd = a:cfg.cmd . shellescape(a:file)
    2              0.000002   let id = -1
    2   0.000041   0.000026   let config = { 'buf': '', 'vcs': a:vcs, 'cfg': a:cfg, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')) }
    2              0.000005   if has("nvim")
    2              0.000023     call extend(config, { 'on_stdout': function('s:nvim_output_handler'), 'on_exit': function('s:nvim_untracked_job_handler')})
    2              0.000004     if has_key(s:untracked_jobs, config.file)
                                  " still running
    1              0.000001       return
    1              0.000000     endif
    1              0.000001     try
    1              0.000976     let id = jobstart(cmd, config)
                                catch
                                  " catch-all, jobstart() failed, fall back to system()
                                  let id=-1
    1              0.000001     endtry
    1              0.000004     let s:untracked_jobs[a:file] = id
    1              0.000001   endif
                              " vim without job feature or nvim jobstart failed
    1              0.000001   if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
    1              0.000000   endif

FUNCTION  hexokinase#highlighters#backgroundfull#tearDownv2()
    Defined: ~/.vim/plugged/vim-hexokinase/autoload/hexokinase/highlighters/backgroundfull.vim:57
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000001     if s:isNvim040
    1              0.000002         if !bufexists(a:bufnr)
                                        return
    1              0.000000         endif
                            
    1              0.000002         if exists('*nvim_buf_clear_namespace')
    1              0.000004             call nvim_buf_clear_namespace(a:bufnr, s:namespace, 0, -1)
    1              0.000000         endif
                                else
                                    let b:hexokinase_colours = []
                                    if a:bufnr == bufnr('%')
                                        call s:hidehl()
                                    endif
    1              0.000000     endif

FUNCTION  <SNR>153_get_transitioned_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:140
Called 25 times
Total time:   0.014077
 Self time:   0.000765

count  total (s)   self (s)
   25              0.000031   let line = ''
   25              0.000086   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
   25              0.000011   else
   25   0.013514   0.000202     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   25              0.000097     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   25              0.000079     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   25              0.000039     let line .= '%#'.a:group.'#'
   25              0.000011   endif
   25              0.000024   return line

FUNCTION  <SNR>129_invoke_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:194
Called 3 times
Total time:   0.023469
 Self time:   0.000261

count  total (s)   self (s)
    3   0.000258   0.000051   let builder = airline#builder#new(a:context)
    3   0.005300   0.000099   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    3              0.000003   if err == 1
    3   0.017834   0.000036     let a:context.line = builder.build()
    3              0.000020     let s:contexts[a:context.winnr] = a:context
    3              0.000009     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
    3              0.000035     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
    3              0.000002   endif

FUNCTION  <SNR>154_get_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:20
Called 26 times
Total time:   0.001224
 Self time:   0.000942

count  total (s)   self (s)
   26              0.000089   if has_key(s:section_truncate_width, a:key)
   17   0.000325   0.000141     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
    2              0.000005       return ''
   15              0.000006     endif
   24              0.000010   endif
   24              0.000047   let spc = g:airline_symbols.space
   24              0.000090   if !exists('g:airline_section_{a:key}')
                                return ''
   24              0.000010   endif
   24   0.000330   0.000232   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   24              0.000145   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   24              0.000075   return empty(text) ? '' : prefix.text.suffix

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:173
Called 3 times
Total time:   0.000588
 Self time:   0.000262

count  total (s)   self (s)
    3   0.000389   0.000063   if airline#util#stl_disabled(winnr())
                                return
    3              0.000004   endif
    3              0.000017   for nr in a:range
                                if airline#util#stl_disabled(nr)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
                                endif
                                call s:invoke_funcrefs(context, g:airline_inactive_funcrefs)
    3              0.000013   endfor

FUNCTION  <SNR>175_get_separator_change()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:68
Called 4 times
Total time:   0.000501
 Self time:   0.000029

count  total (s)   self (s)
    4   0.000500   0.000028   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  airline#extensions#tabline#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:169
Called 6 times
Total time:   0.017206
 Self time:   0.000950

count  total (s)   self (s)
    6              0.000093     let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
    6              0.000043     let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
    6              0.000041     let curtabcnt = tabpagenr('$')
    6              0.000037     if curtabcnt != s:current_tabcnt
                                  let s:current_tabcnt = curtabcnt
                                  call airline#extensions#tabline#tabs#invalidate()
                                  call airline#extensions#tabline#buffers#invalidate()
                                  call airline#extensions#tabline#ctrlspace#invalidate()
                                  call airline#extensions#tabline#tabws#invalidate()
    6              0.000011     endif
                            
    6              0.000077     if !exists('#airline#BufAdd#*')
                                  autocmd airline BufAdd * call <sid>update_tabline(0)
    6              0.000008     endif
    6              0.000048     if !exists('#airline#SessionLoadPost')
                                  autocmd airline SessionLoadPost * call <sid>update_tabline(1)
    6              0.000008     endif
    6              0.000046     if s:ctrlspace
                                  return airline#extensions#tabline#ctrlspace#get()
    6              0.000020     elseif s:tabws
                                  return airline#extensions#tabline#tabws#get()
    6              0.000038     elseif show_buffers && curtabcnt == 1 || !show_tabs
    6   0.016461   0.000205       return airline#extensions#tabline#buffers#get()
                                else
                                  return airline#extensions#tabline#tabs#get()
                                endif

FUNCTION  airline#extensions#tabline#group_of_bufnr()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:252
Called 6 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    6              0.000009     let cur = bufnr('%')
    6              0.000005     if cur == a:bufnr
    3              0.000008       if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                    let group = 'airline_tabmod'
    3              0.000001       else
    3              0.000002         let group = 'airline_tabsel'
    3              0.000001       endif
    3              0.000001     else
    3              0.000006       if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                    let group = 'airline_tabmod_unsel'
    3              0.000005       elseif index(a:tab_bufs, a:bufnr) > -1
                                    let group = 'airline_tab'
    3              0.000001       else
    3              0.000002         let group = 'airline_tabhid'
    3              0.000001       endif
    6              0.000002     endif
    6              0.000004     return group

FUNCTION  airline#async#vcs_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:57
Called 2 times
Total time:   0.001145
 Self time:   0.000059

count  total (s)   self (s)
    2              0.000002   if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_untracked(a:config, a:file)
    2              0.000001   else
                                " nvim async or vim without job-feature
    2   0.001123   0.000037     noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
    2              0.000001   endif

FUNCTION  gitgutter#all()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:3
Called 2 times
Total time:   0.006973
 Self time:   0.000393

count  total (s)   self (s)
    2              0.000026   let visible = tabpagebuflist()
                            
    7              0.000055   for bufnr in range(1, bufnr('$') + 1)
    5              0.000027     if buflisted(bufnr)
    1              0.000025       let file = expand('#'.bufnr.':p')
    1              0.000003       if !empty(file)
    1              0.000004         if index(visible, bufnr) != -1
    1   0.006598   0.000018           call gitgutter#process_buffer(bufnr, a:force)
                                    elseif a:force
                                      call s:reset_tick(bufnr)
    1              0.000001         endif
    1              0.000001       endif
    5              0.000009     endif
    7              0.000023   endfor

FUNCTION  <SNR>134_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:189
Called 91 times
Total time:   0.043601
 Self time:   0.003468

count  total (s)   self (s)
   91              0.000162     if pumvisible()
                                  return
   91              0.000035     endif
   91              0.000231     let group = a:from.'_to_'.a:to.a:suffix
   91   0.011692   0.000603     let l:from = airline#themes#get_highlight(a:from.a:suffix)
   91   0.010974   0.000680     let l:to = airline#themes#get_highlight(a:to.a:suffix)
   91              0.000077     if a:inverse
   24              0.000082       let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   67              0.000028     else
   67              0.000214       let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   91              0.000036     endif
   91              0.000229     let a:dict[group] = colors
   91   0.019493   0.000743     call airline#highlighter#exec(group, colors)

FUNCTION  airline#async#vcs_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:95
Called 2 times
Total time:   0.001058
 Self time:   0.000081

count  total (s)   self (s)
    2              0.000002   if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
    2              0.000006   elseif has("nvim")
                                " nvim async
    2   0.001027   0.000049     noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
                              else
                                " Vim pre 8 using system()
                                call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
    2              0.000001   endif

FUNCTION  288()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:29
Called 4 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    4              0.000012   call insert(self._sections, ['', a:text], a:position)

FUNCTION  <SNR>153_get_accented_line()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:163
Called 33 times
Total time:   0.001472
 Self time:   0.001472

count  total (s)   self (s)
   33              0.000047   if a:self._context.active
                                " active window
   33              0.000045     let contents = []
   33              0.000224     let content_parts = split(a:contents, '__accent')
   72              0.000117     for cpart in content_parts
   39              0.000250       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   39              0.000092       call add(contents, cpart)
   72              0.000050     endfor
   33              0.000102     let line = join(contents, a:group)
   33              0.000229     let line = substitute(line, '__restore__', a:group, 'g')
                              else
                                " inactive window
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
   33              0.000015   endif
   33              0.000033   return line

FUNCTION  <SNR>32_LoadFTPlugin()
    Defined: /usr/share/nvim/runtime/ftplugin.vim:14
Called 1 time
Total time:   0.004371
 Self time:   0.004255

count  total (s)   self (s)
    1              0.000004     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    1              0.000001     endif
                            
    1              0.000003     let s = expand("<amatch>")
    1              0.000001     if s != ""
    1              0.000008       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    1              0.000000       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000007       for name in split(s, '\.')
    1   0.002098   0.001982         exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                    " Load lua ftplugins
    1              0.002230         exe printf('runtime! ftplugin/%s.lua ftplugin/%s_*.lua ftplugin/%s/*.lua', name, name, name)
    2              0.000003       endfor
    1              0.000001     endif

FUNCTION  FugitiveHead()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:220
Called 15 times
Total time:   0.012049
 Self time:   0.000505

count  total (s)   self (s)
   15              0.000076   if a:0 && (type(a:1) ==# type({}) || type(a:1) ==# type('') && a:1 !~# '^\d\+$')
                                let dir = FugitiveGitDir(a:1)
                                let arg = get(a:, 2, 0)
   15              0.000015   elseif a:0 > 1
                                let dir = FugitiveGitDir(a:2)
                                let arg = a:1
   15              0.000007   else
   15   0.000620   0.000076     let dir = FugitiveGitDir()
   15              0.000034     let arg = get(a:, 1, 0)
   15              0.000008   endif
   15              0.000018   if empty(dir)
                                return ''
   15              0.000006   endif
   15   0.011167   0.000167   return fugitive#Head(arg, dir)

FUNCTION  <SNR>175_get_separator_change_with_end()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:76
Called 4 times
Total time:   0.000472
 Self time:   0.000060

count  total (s)   self (s)
    4              0.000004   let sep_change = 0
    4              0.000005   if !empty(a:new_end_group) " Separator between title and the end
    2   0.000426   0.000014     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
    4              0.000001   endif
    4              0.000004   if !empty(a:old_group) " Separator between the title and the one adjacent
                                let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
                                if !empty(a:old_end_group) " Remove mis-predicted separator
                                  let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
                                endif
    4              0.000001   endif
    4              0.000003   return sep_change

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:255
Called 7 times
Total time:   0.096943
 Self time:   0.015880

count  total (s)   self (s)
    7              0.000045     let bufnr = a:0 ? a:1 : ''
    7              0.000061     let p = g:airline#themes#{g:airline_theme}#palette
                            
                                " draw the base mode, followed by any overrides
    7              0.000180     let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    7              0.000040     let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    7              0.000033     let airline_grouplist = []
    7              0.000062     let buffers_in_tabpage = sort(tabpagebuflist())
    7              0.000037     if exists("*uniq")
    7              0.000058       let buffers_in_tabpage = uniq(buffers_in_tabpage)
    7              0.000009     endif
                                " mapped might be something like ['normal', 'normal_modified']
                                " if a group is in both modes available, only define the second
                                " that is how this was done previously overwrite the previous definition
   18              0.000078     for mode in reverse(mapped)
   11              0.000146       if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    7              0.000052         let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  134              0.000448         for kvp in items(dict)
  127              0.000291           let mode_colors = kvp[1]
  127              0.000204           let name = kvp[0]
  127              0.000311           if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                        let name = 'airline_c'.bufnr
  127              0.000059           endif
                                      " do not re-create highlighting for buffers that are no longer visible
                                      " in the current tabpage
  127              0.000866           if name =~# 'airline_c\d\+'
                                        let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
                                        if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                          continue
                                        endif
  127              0.000555           elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                        " group will be redefined below at exec_separator
                                        " or is not needed for tabline with '_inactive' suffix
                                        " since active flag is 1 for builder)
   64              0.000071             continue
   63              0.000028           endif
   63   0.001197   0.000608           if s:group_not_done(airline_grouplist, name.suffix)
   63   0.017306   0.000621             call airline#highlighter#exec(name.suffix, mode_colors)
   63              0.000039           endif
                            
   63              0.000148           if !has_key(p, 'accents')
                                        " work around a broken installation
                                        " shouldn't actually happen, p should always contain accents
                                        continue
   63              0.000030           endif
                            
  189              0.000414           for accent in keys(s:accents)
  126              0.000303             if !has_key(p.accents, accent)
                                          continue
  126              0.000053             endif
  126              0.000400             let colors = copy(mode_colors)
  126              0.000286             if p.accents[accent][0] != ''
   63              0.000130               let colors[0] = p.accents[accent][0]
  126              0.000057             endif
  126              0.000193             if p.accents[accent][2] != ''
   63              0.000101               let colors[2] = p.accents[accent][2]
  126              0.000050             endif
  126              0.000194             if len(colors) >= 5
  126              0.000347               let colors[4] = get(p.accents[accent], 4, '')
                                        else
                                          call add(colors, get(p.accents[accent], 4, ''))
  126              0.000054             endif
  126   0.002291   0.001328             if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  126   0.033313   0.001179               call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  126              0.000073             endif
  189              0.000116           endfor
   70              0.000036         endfor
                            
    7              0.000010         if empty(s:separators)
                                      " nothing to be done
                                      continue
    7              0.000002         endif
                                    " TODO: optimize this
   73              0.000158         for sep in items(s:separators)
                                      " we cannot check, that the group already exists, else the separators
                                      " might not be correctly defined. But perhaps we can skip above groups
                                      " that match the '_to_' name, because they would be redefined here...
   66   0.031442   0.000752           call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   73              0.000053         endfor
   11              0.000009       endif
   18              0.000025     endfor

FUNCTION  <SNR>134_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:60
Called 513 times
Total time:   0.002666
 Self time:   0.002666

count  total (s)   self (s)
  513              0.002478     return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  <SNR>71_sortByLength()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:467
Called 17 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
   17              0.000038   return len(a:i2[0])-len(a:i1[0])

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:73
Called 9 times
Total time:   0.000170
 Self time:   0.000170

count  total (s)   self (s)
    9              0.000140   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
    9              0.000017     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:136
Called 34 times
Total time:   0.001081
 Self time:   0.001081

count  total (s)   self (s)
   34              0.000320   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
   34              0.000717   return match(a:name, pat) > -1

FUNCTION  VMInfos()
    Defined: ~/.vim/plugged/vim-visual-multi/plugin/visual-multi.vim:97
Called 31 times
Total time:   0.000435
 Self time:   0.000435

count  total (s)   self (s)
   31              0.000234     if !exists('b:VM_Selection') || empty(b:VM_Selection)
   31              0.000134         return {}
                                endif
                            
                                let infos = {}
                                let VM = b:VM_Selection
                            
                                let m = g:Vm.mappings_enabled ?    'M' : 'm'
                                let s = VM.Vars.single_region ?    'S' : 's'
                                let l = VM.Vars.multiline ?        'V' : 'v'
                            
                                let infos.current = VM.Vars.index + 1
                                let infos.total = len(VM.Regions)
                                let infos.ratio = infos.current . ' / ' . infos.total
                                let infos.patterns = VM.Vars.search
                                let infos.status = m.s.l
                                return infos

FUNCTION  <SNR>123_SetConcealOption()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:96
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000001     if !g:indentLine_setConceal
                                    return
    1              0.000000     endif
    1              0.000002     if !(exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet)
    1              0.000004         let b:indentLine_ConcealOptionSet = 1
    1              0.000003         let b:indentLine_original_concealcursor = &l:concealcursor
    1              0.000002         let b:indentLine_original_conceallevel = &l:conceallevel
    1              0.000008         let &l:concealcursor = exists("g:indentLine_concealcursor") ? g:indentLine_concealcursor : "inc"
    1              0.000006         let &l:conceallevel = exists("g:indentLine_conceallevel") ? g:indentLine_conceallevel : "2"
    1              0.000000     endif

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 3 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    3              0.000009   return s:available

FUNCTION  AutoPairsMap()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:445
Called 12 times
Total time:   0.000207
 Self time:   0.000207

count  total (s)   self (s)
                              " | is special key which separate map command from text
   12              0.000012   let key = a:key
   12              0.000010   if key == '|'
                                let key = '<BAR>'
   12              0.000004   end
   12              0.000038   let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
   12              0.000125   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"

FUNCTION  321()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:41
Called 2 times
Total time:   0.001122
 Self time:   0.000089

count  total (s)   self (s)
    2   0.000165   0.000009   let title = self.get_title(a:index)
    2   0.000860   0.000013   let title_size = s:tabline_evaluated_length(title) + a:sep_size
    2              0.000003   if a:force || self._remaining_space >= title_size
    2              0.000002     let pos = a:pos
    2              0.000003     if has_key(self, "get_pretitle")
    2   0.000034   0.000016       call self.insert_raw(self.get_pretitle(a:index), pos)
    2              0.000003       let self._right_position += 1
    2              0.000002       let pos += 1
    2              0.000001     endif
                            
    2   0.000014   0.000008     call self.insert_section(a:group, title, pos)
    2              0.000002     let self._right_position += 1
    2              0.000001     let pos += 1
                            
    2              0.000003     if has_key(self, "get_posttitle")
    2   0.000017   0.000010       call self.insert_raw(self.get_posttitle(a:index), pos)
    2              0.000002       let self._right_position += 1
    2              0.000001       let pos += 1
    2              0.000001     endif
                            
    2              0.000002     let self._remaining_space -= title_size
    2              0.000001     return 1
                              endif
                              return 0

FUNCTION  WebDevIconsGetFileTypeSymbol()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:495
Called 5 times
Total time:   0.000983
 Self time:   0.000935

count  total (s)   self (s)
    5              0.000008   if a:0 == 0
                                let fileNodeExtension = !empty(expand('%:e')) ? expand('%:e') : &filetype
                                let fileNode = expand('%:t')
                                let isDirectory = 0
    5              0.000004   else
    5              0.000018     let fileNodeExtension = fnamemodify(a:1, ':e')
    5              0.000015     let fileNode = fnamemodify(a:1, ':t')
    5              0.000006     if a:0 > 1
                                  let isDirectory = a:2
    5              0.000003     else
    5              0.000007       let isDirectory = 0
    5              0.000003     endif
    5              0.000003   endif
                            
    5              0.000011   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
    5              0.000012     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
    5              0.000017     let fileNodeExtension = tolower(fileNodeExtension)
    5              0.000011     let fileNode = tolower(fileNode)
                            
   50              0.000127     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
   45              0.000279       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
   45              0.000019       endif
   50              0.000027     endfor
                            
    5              0.000015     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
    5              0.000017       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
                                    let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
    5              0.000032       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
    5              0.000019         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
                                  elseif isDirectory == 1
                                    let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
    5              0.000003       endif
    5              0.000003     endif
                            
                              else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
    5              0.000003   endif
                            
    5   0.000116   0.000069   let artifactFix = s:DevIconsGetArtifactFix()
                            
    5              0.000012   return symbol . artifactFix
                            

FUNCTION  airline#util#ignore_next_focusgain()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:199
Called 19 times
Total time:   0.000165
 Self time:   0.000165

count  total (s)   self (s)
   19              0.000098   if has('win32')
                                " Setup an ignore for platforms that trigger FocusLost on calls to
                                " system(). macvim (gui and terminal) and Linux terminal vim do not.
                                let s:focusgained_ignore_time = localtime()
   19              0.000009   endif

FUNCTION  airline#parts#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:49
Called 31 times
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
   31              0.000159   return get(s:parts, a:key, {})

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:63
Called 15 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
   15              0.000056   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>66_Tree()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:285
Called 16 times
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
   16              0.000025   let dir = a:path
   16              0.000056   if dir =~# '/\.git$'
   15              0.000043     return len(dir) ==# 5 ? '/' : dir[0:-6]
    1              0.000001   elseif dir ==# ''
    1              0.000001     return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  let wt_config = filter(copy(config),'v:val =~# "^\\s*worktree *="')
                                  if len(wt_config) == 1
                                    let worktree = FugitiveVimPath(matchstr(wt_config[0], '= *\zs.*'))
                                  else
                                    call filter(config,'v:val =~# "^\\s*bare *= *false *$"')
                                    if len(config)
                                      let s:worktree_for_dir[dir] = 0
                                    endif
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  airline#update_statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:144
Called 3 times
Total time:   0.024918
 Self time:   0.000555

count  total (s)   self (s)
    3   0.000374   0.000069   if airline#util#stl_disabled(winnr())
                                return
    3              0.000004   endif
    3              0.000064   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    3   0.000676   0.000088   call airline#update_statusline_inactive(range)
                            
    3              0.000020   unlet! w:airline_render_left w:airline_render_right
    3              0.000117   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    3              0.000014   let w:airline_active = 1
    3              0.000043   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    3   0.023573   0.000104   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  airline#update_statusline_focuslost()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:163
Called 2 times
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
    2              0.000045   if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
    2              0.000009   endif

FUNCTION  <SNR>185_function()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:14
Called 18 times
Total time:   0.000239
 Self time:   0.000239

count  total (s)   self (s)
   18              0.000235   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '.*\zs<SNR>\d\+_'),''))

FUNCTION  fugitive#CommonDir()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:445
Called 15 times
Total time:   0.000313
 Self time:   0.000313

count  total (s)   self (s)
   15              0.000025   if empty(a:dir)
                                return ''
   15              0.000006   endif
   15              0.000036   if !has_key(s:commondirs, a:dir)
    1              0.000012     if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
    1              0.000009     elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
    1              0.000000     else
    1              0.000002       let s:commondirs[a:dir] = a:dir
    1              0.000000     endif
   15              0.000005   endif
   15              0.000024   return s:commondirs[a:dir]

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:89
Called 31 times
Total time:   0.001646
 Self time:   0.000794

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
   31   0.001264   0.000412   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
   31              0.000023   endif
   31              0.000097   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
   31              0.000022   else
   31              0.000082     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:890
Called 15 times
Total time:   0.006566
 Self time:   0.000828

count  total (s)   self (s)
   15              0.000077   let dir = a:0 > 1 ? a:2 : s:Dir()
   15              0.000032   if empty(dir)
                                return ''
   15              0.000006   endif
   15   0.005853   0.000115   let file = fugitive#Find('.git/HEAD', dir)
   15              0.000151   let ftime = getftime(file)
   15              0.000017   if ftime == -1
                                return ''
   15              0.000060   elseif ftime != get(s:head_cache, file, [-1])[0]
    2              0.000046     let s:head_cache[file] = [ftime, readfile(file)[0]]
   15              0.000007   endif
   15              0.000030   let head = s:head_cache[file][1]
   15              0.000060   if head =~# '^ref: '
   15              0.000155     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  airline#extensions#tabline#redraw()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:149
Called 1 time
Total time:   0.007935
 Self time:   0.007935

count  total (s)   self (s)
                                " sometimes, the tabline is not correctly updated see #1580
                                " so force redraw here
    1              0.000007     if exists(":redrawtabline") == 2
    1              0.007921       redrawtabline
                                else
                                " Have to set a property equal to itself to get airline to re-eval.
                                " Setting `let &tabline=&tabline` destroys the cursor position so we
                                " need something less invasive.
                                  let &ro = &ro
    1              0.000000     endif

FUNCTION  <SNR>185_GitDir()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:470
Called 30 times
Total time:   0.001329
 Self time:   0.000176

count  total (s)   self (s)
   30   0.001320   0.000168   return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()

FUNCTION  <SNR>185_add_methods()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:334
Called 6 times
Total time:   0.000409
 Self time:   0.000170

count  total (s)   self (s)
   24              0.000022   for name in a:method_names
   18   0.000359   0.000120     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
   24              0.000012   endfor

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 7 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
    7              0.000016   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
    7              0.000037   let ggvars = getbufvar(buffer, 'gitgutter')
    7              0.000017   if type(ggvars) == type('')
    1              0.000001     unlet ggvars
    1              0.000001     let ggvars = {}
    1              0.000002     call setbufvar(buffer, 'gitgutter', ggvars)
    7              0.000005   endif
    7              0.000025   let ggvars[a:varname] = a:val

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:130
Called 22 times
Total time:   0.005503
 Self time:   0.000481

count  total (s)   self (s)
   22              0.000039   if a:group1 == a:group2
                                return 0
   22              0.000008   endif
   22   0.002903   0.000159   let color1 = airline#highlighter#get_highlight(a:group1)
   22   0.002439   0.000161   let color2 = airline#highlighter#get_highlight(a:group2)
   22              0.000078   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  <SNR>123_IndentLinesEnable()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:148
Called 1 time
Total time:   0.000366
 Self time:   0.000337

count  total (s)   self (s)
    1              0.000001     if g:indentLine_newVersion
    1              0.000002         if exists("b:indentLine_enabled") && b:indentLine_enabled == 0
                                        return
    1              0.000000         endif
                            
    1              0.000002         if !exists("w:indentLine_indentLineId")
                                        let w:indentLine_indentLineId = []
    1              0.000000         endif
                            
    1   0.000041   0.000012         call s:SetConcealOption()
                            
    1              0.000001         if g:indentLine_showFirstIndentLevel
                                        call add(w:indentLine_indentLineId, matchadd('Conceal', '^ ', 0, -1, {'conceal': g:indentLine_first_char}))
    1              0.000000         endif
                            
    1              0.000002         let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
    1              0.000003         let n = len(g:indentLine_char_list)
    1              0.000001         let level = 0
   21              0.000015         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
   20              0.000011             if n > 0
                                            let char = g:indentLine_char_list[level % n]
                                            let level += 1
   20              0.000006             else
   20              0.000017                 let char = g:indentLine_char
   20              0.000006             endif
   20              0.000201             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': char}))
   21              0.000010         endfor
                            
    1              0.000001         return
                                endif
                            
                                if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
                                else
                                    let b:indentLine_enabled = 1
                                endif
                            
                                call s:SetConcealOption()
                            
                                let g:mysyntaxfile = g:indentLine_mysyntaxfile
                            
                                let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
                            
                                if g:indentLine_showFirstIndentLevel
                                    execute 'syntax match IndentLine /^ / containedin=ALL conceal cchar=' . g:indentLine_first_char
                                endif
                            
                                if g:indentLine_faster
                                    execute 'syntax match IndentLineSpace /^\s\+/ containedin=ALL contains=IndentLine'
                                    execute 'syntax match IndentLine / \{'.(space-1).'}\zs / contained conceal cchar=' . g:indentLine_char
                                    execute 'syntax match IndentLine /\t\zs / contained conceal cchar=' . g:indentLine_char
                                else
                                    let pattern = line('$') < g:indentLine_maxLines ? 'v' : 'c'
                                    for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
                                        execute 'syntax match IndentLine /\%(^\s\+\)\@<=\%'.i.pattern.' / containedin=ALL conceal cchar=' . g:indentLine_char
                                    endfor
                                endif

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:219
Called 287 times
Total time:   0.072575
 Self time:   0.023611

count  total (s)   self (s)
  287              0.000450     if pumvisible()
                                  return
  287              0.000124     endif
  287              0.000414     let colors = a:colors
  287              0.000445     if len(colors) == 4
   91              0.000167       call add(colors, '')
  287              0.000116     endif
                                " colors should always be string values
  287              0.004589     let colors = map(copy(colors), 'type(v:val) != type("") ? string(v:val) : v:val')
  287              0.000342     if s:is_win32term
                                  let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                  let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  287              0.000130     endif
  287   0.042105   0.002450     let old_hi = airline#highlighter#get_highlight(a:group)
  287              0.001756     let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
  287   0.005560   0.001917     let colors = s:CheckDefined(colors)
  287   0.004609   0.002052     if old_hi != new_hi || !s:hl_group_exists(a:group)
   38   0.003442   0.000334       let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   38              0.000038       try
   38              0.000444         exe cmd
                                  catch /^Vim\%((\a\+)\)\=:E421:/ " color definition not found
                                    let group=matchstr(v:exception, '\w\+\ze=')
                                    let color=matchstr(v:exception, '=\zs\w\+')
                                    let cmd=substitute(cmd, color, 'grey', 'g')
                                    exe cmd
                                    call airline#util#warning('color definition for group ' . a:group . ' not found, using grey as fallback')
                                  catch
                                    call airline#util#warning('Error when running command: '. cmd)
   38              0.000035       endtry
   38              0.000097       if has_key(s:hl_groups, a:group)
   38              0.000089         let s:hl_groups[a:group] = colors
   38              0.000019       endif
  287              0.000104     endif

FUNCTION  <SNR>171_on_stdout()
    Defined: ~/.vim/plugged/vim-hexokinase/autoload/hexokinase/v2/scraper.vim:114
Called 1 time
Total time:   0.000030
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000003     for line in a:data
    1   0.000015   0.000008         let colour = s:parse_colour(line)
    1              0.000002         if !empty(colour)
                                        call add(self.colours, colour)
    1              0.000001         endif
    2              0.000002     endfor

FUNCTION  <SNR>137_format_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:77
Called 4 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    4              0.000004     return a:name

FUNCTION  airline#extensions#tabline#formatters#default#format()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:7
Called 5 times
Total time:   0.000541
 Self time:   0.000403

count  total (s)   self (s)
    5              0.000031     let fnametruncate = get(g:, 'airline#extensions#tabline#fnametruncate', 0)
    5              0.000020     let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
    5              0.000009     let _ = ''
                            
    5              0.000015     let name = bufname(a:bufnr)
    5              0.000010     if empty(name)
                                  let _ = '[No Name]'
    5              0.000029     elseif name =~ 'term://'
                                  " Neovim Terminal
                                  let _ = substitute(name, '\(term:\)//.*:\(.*\)', '\1 \2', '')
    5              0.000003     else
    5              0.000014       if get(g:, 'airline#extensions#tabline#fnamecollapse', 1)
                                    " Does not handle non-ascii characters like Cyrillic: 'D/Учёба/t.c'
                                    "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
    5              0.000081         let _ = pathshorten(fnamemodify(name, fmod))
                                  else
                                    let _ = fnamemodify(name, fmod)
    5              0.000003       endif
    5              0.000022       if a:bufnr != bufnr('%') && fnametruncate && strlen(_) > fnametruncate
                                    let _ = airline#util#strcharpart(_, 0, fnametruncate)
    5              0.000003       endif
    5              0.000003     endif
                            
    5   0.000216   0.000079     return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  <SNR>171_on_stderr()
    Defined: ~/.vim/plugged/vim-hexokinase/autoload/hexokinase/v2/scraper.vim:123
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000002     if get(g:, 'Hexokinase_logging', 0)
                                    echohl Error | echom string(a:data) | echohl None
    1              0.000000     endif

FUNCTION  airline#extensions#append_to_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:53
Called 3 times
Total time:   0.000124
 Self time:   0.000070

count  total (s)   self (s)
    3   0.000102   0.000047   call <sid>check_defined_section(a:name)
    3              0.000020   let w:airline_section_{a:name} .= a:value

FUNCTION  <SNR>123_ResetConcealOption()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:110
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000003     if exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet
                                    if exists("b:indentLine_original_concealcursor")
                                        let &l:concealcursor = b:indentLine_original_concealcursor
                                    endif
                                    if exists("b:indentLine_original_conceallevel")
                                        let &l:conceallevel = b:indentLine_original_conceallevel
                                    endif
                                    let b:indentLine_ConcealOptionSet = 0
    1              0.000000     endif

FUNCTION  <SNR>185_DirUrlPrefix()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:474
Called 15 times
Total time:   0.000707
 Self time:   0.000098

count  total (s)   self (s)
   15   0.000704   0.000094   return 'fugitive://' . call('s:GitDir', a:000) . '//'

FUNCTION  <SNR>123_InitColor()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:35
Called 2 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
    2              0.000004     if !g:indentLine_setColors
                                    return
    2              0.000001     endif
                            
    2              0.000004     let default_term_bg = "NONE"
    2              0.000002     let default_gui_bg  = "NONE"
    2              0.000005     if &background ==# "light"
                                    let default_term_fg = 249
                                    let default_gui_fg = "Grey70"
    2              0.000001     else
    2              0.000002         let default_term_fg = 239
    2              0.000002         let default_gui_fg = "Grey30"
    2              0.000001     endif
                            
    2              0.000004     if g:indentLine_defaultGroup != ""
                                    let default_id = synIDtrans(hlID(g:indentLine_defaultGroup))
                                    let default_term_fg = synIDattr(default_id, "fg", "cterm") == "" ? default_term_fg :  synIDattr(default_id, "fg", "cterm")
                                    let default_term_bg = synIDattr(default_id, "bg", "cterm") == "" ? default_term_bg :  synIDattr(default_id, "bg", "cterm")
                                    let default_gui_fg = synIDattr(default_id, "fg", "gui") == "" ? default_gui_fg :  synIDattr(default_id, "fg", "gui")
                                    let default_gui_bg = synIDattr(default_id, "bg", "gui") == "" ? default_gui_bg :  synIDattr(default_id, "bg", "gui")
    2              0.000001     endif
                            
    2              0.000004     if !exists("g:indentLine_color_term")
    2              0.000003         let term_color = default_term_fg
                                else
                                    let term_color = g:indentLine_color_term
    2              0.000001     endif
                            
    2              0.000003     if !exists("g:indentLine_bgcolor_term")
    2              0.000002         let term_bgcolor = default_term_bg
                                else
                                    let term_bgcolor = g:indentLine_bgcolor_term
    2              0.000001     endif
                            
    2              0.000003     if !exists("g:indentLine_color_gui")
    2              0.000002         let gui_color = default_gui_fg
                                else
                                    let gui_color = g:indentLine_color_gui
    2              0.000001     endif
                            
    2              0.000003     if !exists("g:indentLine_bgcolor_gui")
    2              0.000002         let gui_bgcolor = default_gui_bg
                                else
                                    let gui_bgcolor = g:indentLine_bgcolor_gui
    2              0.000001     endif
                            
    2              0.000050     execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
    2              0.000016     execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
                            
    2              0.000003     if &term ==# "linux"
                                    if &background ==# "light"
                                        let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                    else
                                        let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                    endif
                                    execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
    2              0.000001     endif

FUNCTION  <SNR>136_is_branch_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:55
Called 15 times
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
   15              0.000111   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>156_cd_cmd()
    Defined: ~/.vim/plugged/vim-startify/autoload/startify.vim:997
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000004   let g:startify_change_cmd = get(g:, 'startify_change_cmd', 'lcd')
    1              0.000007   if g:startify_change_cmd !~# '^[lt]\?cd$'
                                call s:warn('Invalid value for g:startify_change_cmd. Defaulting to :lcd')
                                let g:startify_change_cmd = 'lcd'
    1              0.000000   endif
    1              0.000001   return g:startify_change_cmd

FUNCTION  <SNR>154_add_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:47
Called 19 times
Total time:   0.001980
 Self time:   0.000771

count  total (s)   self (s)
   19              0.000217     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   19   0.000283   0.000100     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
   19              0.000009     endif
   19              0.000014     if condition
                                  call a:builder.add_raw('%(')
   19              0.000007     endif
   19   0.001305   0.000278     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   19              0.000022     if condition
                                  call a:builder.add_raw('%)')
   19              0.000009     endif

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 3 times
Total time:   0.000106
 Self time:   0.000053

count  total (s)   self (s)
    3   0.000085   0.000032   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
    3              0.000012   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>186_valid_dir()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:50
Called 4 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    4              0.000020   if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
    4              0.000002   endif
    4              0.000003   return a:dir

FUNCTION  <SNR>137_update_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:199
Called 15 times
Total time:   0.003850
 Self time:   0.001281

count  total (s)   self (s)
   15              0.000150   let file = expand("%:p")
   15              0.000089   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
   15              0.000006   endif
                            
   15              0.000020   let needs_update = 1
   15              0.000055   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
   45              0.000073   for vcs in keys(s:vcs_config)
   30              0.000106     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
   30              0.000012     endif
   30              0.000064     if has_key(s:vcs_config[vcs].untracked, file)
   13              0.000014       let needs_update = 0
   13   0.000270   0.000127       call airline#extensions#branch#update_untracked_config(file, vcs)
   30              0.000011     endif
   45              0.000025   endfor
                            
   15              0.000014   if !needs_update
   13              0.000009     return
    2              0.000001   endif
                            
    6              0.000016   for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
    4   0.000030   0.000019     if vcs is# 'git' && (!airline#util#has_fugitive() && !airline#util#has_gina())
                                  continue
    4   0.000038   0.000022     elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
    2              0.000002       continue
    2              0.000001     endif
    2              0.000003     let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
    2              0.000004     if index(vcs_checks, 'untracked') > -1
    2   0.001469   0.000127       call airline#async#vcs_untracked(config, file, vcs)
    2              0.000001     endif
                                " Check clean state of repo
    2              0.000005     if index(vcs_checks, 'dirty') > -1
    2   0.001089   0.000031       call airline#async#vcs_clean(config.dirty, file, vcs)
    2              0.000003     endif
    4              0.000014   endfor

FUNCTION  hexokinase#v2#scraper#on()
    Defined: ~/.vim/plugged/vim-hexokinase/autoload/hexokinase/v2/scraper.vim:13
Called 1 time
Total time:   0.001078
 Self time:   0.000990

count  total (s)   self (s)
    1   0.000024   0.000005     call s:cancel_cur_job()
                            
    1              0.000001     let b:hexokinase_is_on = 1
    1              0.000001     let b:hexokinase_is_disabled = 0
    1   0.000018   0.000005     let tmpname = hexokinase#utils#tmpname()
    1              0.000035     let fail = writefile(getbufline(bufnr('%'), 1, '$'), tmpname)
    1              0.000001     if fail
                                    let b:hexokinase_is_on = 0
    1              0.000000     else
    1              0.000002         if has('nvim')
    1              0.000010             let opts = { 'tmpname': tmpname, 'on_stdout': function('s:on_stdout'), 'on_stderr': function('s:on_stderr'), 'on_exit': function('s:on_exit'), 'bufnr': bufnr('%'), 'colours': [] }
                                    else
                                        let opts = { 'out_cb': function('s:on_stdout_vim'), 'close_cb': function('s:on_exit_vim'), }
    1              0.000000         endif
    1              0.000003         let cmd = [g:Hexokinase_executable_path, '-simplified', '-files', tmpname]
                                    " Neovim has multiple sign columns, in which case we don't want a
                                    " reversed output.
    1              0.000005         if get(g:, 'Hexokinase_prioritizeHead', 1) && get(b:, 'Hexokinase_prioritizeHead', 1) && (index(g:Hexokinase_highlighters, 'sign_column') == -1 || &signcolumn !~# '\v(auto|yes):[2-9]')
    1              0.000002             call add(cmd, '-r')
    1              0.000000         endif
    1   0.000045   0.000008         call extend(cmd, hexokinase#utils#getPatModifications())
    1              0.000001         call add(cmd, '-bg')
    1   0.000026   0.000008         call add(cmd, hexokinase#utils#get_background_hex())
    1              0.000001         if !empty(g:Hexokinase_palettes)
                                        call add(cmd, '-palettes')
                                        call add(cmd, join(g:Hexokinase_palettes, ','))
    1              0.000000         endif
    1              0.000001         if get(g:, 'Hexokinase_checkBoundary', 1)
    1              0.000001             call add(cmd, '-boundary')
    1              0.000000         endif
                            
    1              0.000002         if has('nvim')
    1              0.000871             let b:hexokinase_job_id = jobstart(cmd, opts)
                                    else
                                        let b:hexokinase_job = job_start(cmd, opts)
                                        let s:chan_infos[ch_info(job_getchannel(b:hexokinase_job)).id] = {     'tmpname': tmpname,     'colours': [],     'bufnr': bufnr('%') }
    1              0.000002         endif
    1              0.000000     endif

FUNCTION  airline#extensions#searchcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/searchcount.vim:15
Called 3 times
Total time:   0.000175
 Self time:   0.000051

count  total (s)   self (s)
    3   0.000172   0.000047   call airline#extensions#append_to_section('y', '%{v:hlsearch ? airline#extensions#searchcount#status() : ""}')

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 3 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    3              0.000050   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:67
Called 15 times
Total time:   0.000432
 Self time:   0.000432

count  total (s)   self (s)
   15              0.000191   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   15              0.000036   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   15              0.000010   endif
   15              0.000014   return ''

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:20
Called 12 times
Total time:   0.000473
 Self time:   0.000179

count  total (s)   self (s)
   12   0.000465   0.000171   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>156_leftmouse()
    Defined: ~/.vim/plugged/vim-startify/autoload/startify.vim:877
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
                                " feedkeys() triggers CursorMoved which calls s:set_cursor() which checks
                                " .leftmouse.
    1              0.000006     let b:startify.leftmouse = 1
    1              0.000013     call feedkeys("\<LeftMouse>", 'nt')

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:64
Called 15 times
Total time:   0.002551
 Self time:   0.001774

count  total (s)   self (s)
   15              0.000050   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   15              0.000090   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
   15              0.000006   endif
   15              0.000134   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   15              0.000039   if !exists('b:airline_whitespace_check')
    2              0.000004     let b:airline_whitespace_check = ''
    2              0.000009     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    2              0.000002     let trailing = 0
    2              0.000002     let check = 'trailing'
    2              0.000017     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    2              0.000002       try
    2              0.000008         let regexp = get(b:, 'airline_whitespace_trailing_regexp', get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$'))
    2              0.000074         let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
    2              0.000002       endtry
    2              0.000001     endif
                            
    2              0.000002     let mixed = 0
    2              0.000002     let check = 'indent'
    2              0.000014     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    2   0.000172   0.000017       let mixed = s:check_mixed_indent()
    2              0.000001     endif
                            
    2              0.000003     let mixed_file = ''
    2              0.000002     let check = 'mixed-indent-file'
    2              0.000015     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    2   0.000096   0.000024       let mixed_file = s:check_mixed_indent_file()
    2              0.000001     endif
                            
    2              0.000002     let long = 0
    2              0.000004     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
    2              0.000001     endif
                            
    2              0.000002     let conflicts = 0
    2              0.000003     if index(checks, 'conflicts') > -1
    2   0.000103   0.000016       let conflicts = s:conflict_marker()
    2              0.000001     endif
                            
    2              0.000008     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
    2              0.000001     endif
   15              0.000007   endif
   15   0.000583   0.000119   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>171_parse_colour()
    Defined: ~/.vim/plugged/vim-hexokinase/autoload/hexokinase/v2/scraper.vim:141
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000004     let parts = split(a:line, ':')
    1              0.000001     if len(parts) < 4
    1              0.000001          return ''
                                 endif
                                " If a system allows `:` inside the filename, then we join together all
                                " parts before the final 3 (which are guaranteed to be the form
                                " lnum:col:hex). This allows the filename to remain intact. For example,
                                " Windows can prefix the filename with the drive (e.g. C:/foo/bar.txt)
                                let parts = insert(parts[-3:], join(parts[:-4], ':'))
                            
                                return { 'lnum': parts[1], 'start': split(parts[2], '-')[0], 'end': split(parts[2], '-')[1], 'hex': parts[3] }

FUNCTION  <SNR>171_clear_hl()
    Defined: ~/.vim/plugged/vim-hexokinase/autoload/hexokinase/v2/scraper.vim:77
Called 1 time
Total time:   0.000032
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000005     for F in g:Hexokinase_tearDownCallbacks
    1   0.000024   0.000007         call F(a:bufnr)
    2              0.000001     endfor

FUNCTION  <SNR>108_Remove_Matches()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:197
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000004   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
    2              0.000001   endif

FUNCTION  <SNR>156_set_cursor()
    Defined: ~/.vim/plugged/vim-startify/autoload/startify.vim:824
Called 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000004   let b:startify.oldline = exists('b:startify.newline') ? b:startify.newline : s:fixed_column
    1              0.000001   let b:startify.newline = line('.')
                            
                              " going up (-1) or down (1)
    1              0.000003   if b:startify.oldline == b:startify.newline && col('.') != s:fixed_column && !b:startify.leftmouse
                                let movement = 2 * (col('.') > s:fixed_column) - 1
                                let b:startify.newline += movement
    1              0.000000   else
    1              0.000002     let movement = 2 * (b:startify.newline > b:startify.oldline) - 1
    1              0.000001     let b:startify.leftmouse = 0
    1              0.000000   endif
                            
                              " skip section headers lines until an entry is found
    1              0.000003   while index(b:startify.section_header_lines, b:startify.newline) != -1
                                let b:startify.newline += movement
    1              0.000001   endwhile
                            
                              " skip blank lines between lists
    1              0.000002   if empty(getline(b:startify.newline))
                                let b:startify.newline += movement
    1              0.000000   endif
                            
                              " don't go beyond first or last entry
    1              0.000004   let b:startify.newline = max([b:startify.firstline, min([b:startify.lastline, b:startify.newline])])
                            
    1              0.000002   call cursor(b:startify.newline, s:fixed_column)

FUNCTION  <SNR>186_on_exit_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:87
Called 1 time
Total time:   0.000088
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000004   let buf=self.buf
    1   0.000073   0.000014   call s:set_clean_variables(self.file, self.vcs, !empty(buf))
    1              0.000005   if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
    1              0.000004     call remove(s:clean_jobs[self.vcs], self.file)
    1              0.000001   endif

FUNCTION  <SNR>186_untracked_output()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:12
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000006   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
    1              0.000005     let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                              else
                                let a:dict.cfg.untracked[a:dict.file] = ''
    1              0.000000   endif

FUNCTION  <SNR>186_nvim_untracked_job_handler()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:238
Called 1 time
Total time:   0.000027
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000001     if a:event == 'exit'
    1   0.000020   0.000006       call s:untracked_output(self, self.buf)
    1              0.000002       if has_key(s:untracked_jobs, self.file)
    1              0.000002         call remove(s:untracked_jobs, self.file)
    1              0.000000       endif
    1              0.000000     endif

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:59
Called 15 times
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
   15              0.000179   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>76_on_bufenter()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:221
Called 1 time
Total time:   0.002128
 Self time:   0.000052

count  total (s)   self (s)
    1   0.000317   0.000021   call gitgutter#setup_maps()
                            
                              " To keep vim's start-up fast, do not process the buffer when vim is starting.
                              " Instead process it a short time later.  Normally we would rely on our
                              " CursorHold autocommand to handle this but it turns out CursorHold is not
                              " guaranteed to fire if the user has not typed anything yet; so set up a
                              " timer instead.  The disadvantage is that if CursorHold does fire, the
                              " plugin will do a round of unnecessary work; but since there will not have
                              " been any changes to the buffer since the first round, the second round
                              " will be cheap.
    1              0.000004   if has('vim_starting') && !$VIM_GITGUTTER_TEST
                                if exists('*timer_start')
                                  call timer_start(&updatetime, 'GitGutterCursorHold')
                                endif
                                return
    1              0.000000   endif
                            
    1              0.000002   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
    1              0.000000   else
    1   0.001792   0.000013     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
    1              0.000000   endif

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 15 times
Total time:   0.000612
 Self time:   0.000612

count  total (s)   self (s)
   15              0.000104   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   15              0.000063     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
   15              0.000063     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
   15              0.000041     let default = get(g:, 'airline#extensions#keymap#default', '')
   15              0.000023     if (label !=# '')
   15              0.000036       let label .= ' '
   15              0.000009     endif
   15              0.000028     let keymap = &keymap
   15              0.000039     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
   15              0.000008     endif
   15              0.000119     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  <SNR>77_not_git_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:59
Called 3 times
Total time:   0.000372
 Self time:   0.000067

count  total (s)   self (s)
    3   0.000370   0.000065   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>66_Slash()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:450
Called 50 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
   50              0.000061     return a:path

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:246
Called 15 times
Total time:   0.019741
 Self time:   0.001034

count  total (s)   self (s)
   15              0.000084   if !exists('b:buffer_vcs_config')
    1   0.000030   0.000009     call s:init_buffer()
   15              0.000008   endif
                            
   15   0.014698   0.000138   call s:update_branch()
   15   0.003978   0.000128   call s:update_untracked()
                            
   15              0.000047   if exists('b:airline_head') && !empty(b:airline_head)
   11              0.000010     return b:airline_head
    4              0.000002   endif
                            
    4              0.000009   let b:airline_head = ''
    4              0.000016   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    4              0.000005   let heads = []
   12              0.000014   for vcs in vcs_priority
    8              0.000021     if !empty(b:buffer_vcs_config[vcs].branch)
    4              0.000010       let heads += [vcs]
    8              0.000004     endif
   12              0.000007   endfor
                            
    8              0.000008   for vcs in heads
    4              0.000006     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
    4              0.000002     endif
    4              0.000007     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
    4              0.000001     endif
    4   0.000347   0.000073     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
    4              0.000010     let additional = b:buffer_vcs_config[vcs].untracked
    4              0.000016     if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
                                  let additional = g:airline_symbols['dirty']
    4              0.000002     endif
    4              0.000008     let b:airline_head .= additional
    8              0.000006   endfor
                            
    4              0.000005   if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
    4              0.000002   endif
                            
    4              0.000004   if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
    4              0.000002   endif
                            
    4              0.000011   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
    4              0.000001   endif
                            
    4              0.000006   return b:airline_head

FUNCTION  airline#extensions#tabline#buflist#clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:10
Called 1 time
Total time:   0.000080
 Self time:   0.000064

count  total (s)   self (s)
    1              0.000010   if !exists('#airline')
                                " airline disabled
                                return
    1              0.000002   endif
    1   0.000033   0.000026   call airline#extensions#tabline#buflist#invalidate()
    1   0.000029   0.000021   call airline#extensions#tabline#buffers#invalidate()

FUNCTION  <SNR>77_abs_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:205
Called 19 times
Total time:   0.001494
 Self time:   0.001494

count  total (s)   self (s)
   19              0.000781   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
   19              0.000533   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
   19              0.000105   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  223()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:140
Called 5 times
Total time:   0.000656
 Self time:   0.000626

count  total (s)   self (s)
    5              0.000042     if exists('t:NERDTreeBufName')
                                    return bufwinnr(t:NERDTreeBufName)
    5              0.000010     endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
   10              0.000112     for w in range(1,winnr('$'))
    5   0.000256   0.000225         if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
    5              0.000008         endif
   10              0.000025     endfor
                            
    5              0.000016     return -1

FUNCTION  224()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:156
Called 5 times
Total time:   0.000757
 Self time:   0.000101

count  total (s)   self (s)
    5   0.000750   0.000095     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:189
Called 12 times
Total time:   0.001375
 Self time:   0.000268

count  total (s)   self (s)
   12   0.001364   0.000256   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:55
Called 15 times
Total time:   0.000688
 Self time:   0.000185

count  total (s)   self (s)
   15   0.000671   0.000168   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>133_wrap_accent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:9
Called 1 time
Total time:   0.000015
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000002   if exists('a:part.accent')
    1   0.000009   0.000006     call airline#highlighter#add_accent(a:part.accent)
    1              0.000003     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value

FUNCTION  airline#extensions#tabline#buflist#invalidate()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:6
Called 4 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    4              0.000019   unlet! s:current_buffer_list

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 3 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
    3              0.000059   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    3              0.000004   endif

FUNCTION  airline#util#strchars()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:119
Called 10 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
   10              0.000008   if s:has_strchars
   10              0.000014     return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif

FUNCTION  fugitive#Find()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:1584
Called 15 times
Total time:   0.005738
 Self time:   0.002839

count  total (s)   self (s)
   15              0.000037   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
   15              0.000060   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
   15              0.000006   endif
   15   0.000118   0.000089   let rev = s:Slash(a:object)
   15              0.000165   if rev =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
   15              0.000061   elseif rev =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
   15              0.000006   endif
   15   0.000825   0.000106   let dir = call('s:GitDir', a:000)
   15              0.000019   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs\%(\.\.\=$\|\.\.\=/.*\|/.*\|\w:/.*\)')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return ''
                                endif
   15              0.000006   endif
   15   0.001111   0.000080   let tree = s:Tree(dir)
   15   0.000803   0.000096   let urlprefix = s:DirUrlPrefix(dir)
   15              0.000035   let base = len(tree) ? tree : urlprefix . '0'
   15              0.000015   if rev ==# '.git'
                                let f = len(tree) && len(getftype(tree . '/.git')) ? tree . '/.git' : dir
   15              0.000050   elseif rev =~# '^\.git/'
   15              0.000035     let f = strpart(rev, 5)
   15              0.000021     let fdir = dir . '/'
   15   0.000429   0.000116     let cdir = fugitive#CommonDir(dir) . '/'
   15              0.000050     if f =~# '^\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[2:-1] : fdir . f)
   15              0.000032     elseif f =~# '^\.\.\%(/\|$\)'
                                  let f = base . f[2:-1]
   15              0.000066     elseif cdir !=# fdir && ( f =~# '^\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(fdir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
   15              0.000006     else
   15              0.000041       let f = simplify(fdir . f)
   15              0.000006     endif
                              elseif rev ==# ':/'
                                let f = tree
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = urlprefix . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = urlprefix . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                let fdir = dir . '/'
                                let f = fdir . 'index'
                                if len($GIT_INDEX_FILE)
                                  let index_dir = substitute($GIT_INDEX_FILE, '[^/]\+$', '', '')
                                  if s:cpath(index_dir, fdir)
                                    let f = FugitiveVimPath($GIT_INDEX_FILE)
                                  elseif s:cpath(resolve(FugitiveVimPath(index_dir)), fdir)
                                    let f = resolve(FugitiveVimPath($GIT_INDEX_FILE))
                                  endif
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = urlprefix . '0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*')
                                  let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) ? "@" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$\|^$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                    if empty(commit) && len(file)
                                      let commit = repeat('0', 40)
                                    endif
                                  endif
                                  if len(commit)
                                    let f = urlprefix . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
   15              0.000006   endif
   15   0.000184   0.000084   return FugitiveVimPath(f)

FUNCTION  <SNR>138_ModifierFlags()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:11
Called 15 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
   15              0.000050   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:88
Called 3 times
Total time:   0.000190
 Self time:   0.000190

count  total (s)   self (s)
    3              0.000045   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    3              0.000012   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    3              0.000008   if did_filetype()
                                " correctly test for compound filetypes (e.g. markdown.pandoc)
    1              0.000005     let ft = substitute(&filetype, '\.', '\\|', 'g')
                            
                                " Select test based on type of "filetypes": new=list, old=string
    1              0.000010     if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
    1              0.000002     elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
    1              0.000000     endif
    3              0.000002   endif
                            
    3              0.000011   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    3              0.000002   endif

FUNCTION  <SNR>84_on_focus_gained()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:77
Called 2 times
Total time:   0.019961
 Self time:   0.000136

count  total (s)   self (s)
    2   0.000122   0.000058   if airline#util#try_focusgained()
    2   0.019833   0.000072     unlet! w:airline_lastmode | :call <sid>airline_refresh(1)
    2              0.000001   endif

FUNCTION  <SNR>137_display_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:122
Called 4 times
Total time:   0.000269
 Self time:   0.000170

count  total (s)   self (s)
                              " disable FocusGained autocommand, might cause loops because system() causes
                              " a refresh, which causes a system() command again #2029
    4   0.000063   0.000029   call airline#util#ignore_next_focusgain()
    4              0.000009   let name = b:buffer_vcs_config['git'].branch
    4              0.000003   try
    4   0.000111   0.000046     let commit = matchstr(FugitiveParse()[0], '^\x\+')
                            
    4              0.000009     if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
    4              0.000006     elseif !empty(commit)
                                  let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                  if ref !~ "^fatal: no tag exactly matches"
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
    4              0.000002     endif
                              catch
    4              0.000004   endtry
    4              0.000004   return name

FUNCTION  <SNR>123_Filter()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:286
Called 3 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    3              0.000011     if index(g:indentLine_fileTypeExclude, &filetype) != -1
                                    return 0
    3              0.000001     endif
                            
    3              0.000007     if index(g:indentLine_bufTypeExclude, &buftype) != -1
                                    return 0
    3              0.000001     endif
                            
    3              0.000007     if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
                                    return 0
    3              0.000001     endif
                            
    3              0.000004     for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) == bufname('')
                                        return 0
                                    endif
    3              0.000002     endfor
                            
    3              0.000002     return 1

FUNCTION  gitgutter#setup_maps()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:107
Called 1 time
Total time:   0.000296
 Self time:   0.000270

count  total (s)   self (s)
    1              0.000002   if !g:gitgutter_map_keys
                                return
    1              0.000000   endif
                            
                              " Note hasmapto() and maparg() operate on the current buffer.
                            
    1              0.000002   let bufnr = bufnr('')
                            
    1   0.000019   0.000008   if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
                                return
    1              0.000000   endif
                            
    1              0.000025   if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
    1              0.000010     nmap <buffer> [c <Plug>(GitGutterPrevHunk)
    1              0.000000   endif
    1              0.000016   if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
    1              0.000008     nmap <buffer> ]c <Plug>(GitGutterNextHunk)
    1              0.000000   endif
                            
    1              0.000016   if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
    1              0.000021     xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
    1              0.000001   endif
    1              0.000018   if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
    1              0.000008     nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
    1              0.000000   endif
    1              0.000015   if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
    1              0.000007     nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
    1              0.000000   endif
    1              0.000013   if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
    1              0.000007     nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
    1              0.000000   endif
                            
    1              0.000012   if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
    1              0.000008     omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
    1              0.000000   endif
    1              0.000012   if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
    1              0.000007     omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
    1              0.000000   endif
    1              0.000012   if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
    1              0.000007     xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
    1              0.000000   endif
    1              0.000011   if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
    1              0.000006     xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
    1              0.000000   endif
                            
    1   0.000023   0.000008   call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:184
Called 25 times
Total time:   0.013312
 Self time:   0.000402

count  total (s)   self (s)
   25              0.000134     let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   25   0.013162   0.000252     call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  airline#extensions#nvimlsp#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:38
Called 15 times
Total time:   0.000879
 Self time:   0.000116

count  total (s)   self (s)
   15   0.000873   0.000109   return airline#extensions#nvimlsp#get('Warning')

FUNCTION  <SNR>183_build_command()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 3 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    3              0.000009   if has('unix')
    3              0.000012     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  hexokinase#utils#getPatModifications()
    Defined: ~/.vim/plugged/vim-hexokinase/autoload/hexokinase/utils.vim:99
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000003     if has_key(g:Hexokinase_ftOptOutPatterns, &filetype)
                                    let dp = g:Hexokinase_ftOptOutPatterns[&filetype]
                                    if type(dp) == 1
                                        return ['-dp', substitute(dp, '\s', '', 'g')]
                                    elseif type(dp) == 3
                                        return ['-dp', join(dp, ',')]
                                    else
                                        echohl Error | echom printf('ERROR: g:Hexokinase_ftOptOutPatterns[%s] must be a string or a list', &filetype) | echohl None
                                    endif
    1              0.000002     elseif has_key(g:Hexokinase_ftOptInPatterns, &filetype)
                                    let ep = g:Hexokinase_ftOptInPatterns[&filetype]
                                    if type(ep) == 1
                                        return ['-ep', substitute(ep, '\s', '', 'g')]
                                    elseif type(ep) == 3
                                        return ['-ep', join(ep, ',')]
                                    else
                                        echohl Error | echom printf('ERROR: g:Hexokinase_ftOptInPatterns[%s] must be a string or a list', &filetype) | echohl None
                                    endif
    1              0.000001     elseif !empty(g:Hexokinase_optOutPatterns)
                                    if type(g:Hexokinase_optOutPatterns) == 1
                                        return ['-dp', substitute(g:Hexokinase_optOutPatterns, '\s', '', 'g')]
                                    elseif type(g:Hexokinase_optOutPatterns) == 3
                                        return ['-dp', join(g:Hexokinase_optOutPatterns, ',')]
                                    else
                                        echohl Error | echom 'ERROR: g:Hexokinase_optOutPatterns must be a string or a list' | echohl None
                                    endif
    1              0.000001     elseif !empty(g:Hexokinase_optInPatterns)
    1              0.000001         if type(g:Hexokinase_optInPatterns) == 1
    1              0.000005             return ['-ep', substitute(g:Hexokinase_optInPatterns, '\s', '', 'g')]
                                    elseif type(g:Hexokinase_optInPatterns) == 3
                                        return ['-ep', join(g:Hexokinase_optInPatterns, ',')]
                                    else
                                        echohl Error | echom 'ERROR: g:Hexokinase_optInPatterns must be a string or a list' | echohl None
                                    endif
                                endif
                                return []

FUNCTION  <SNR>73_CursorHoldUpdate()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:401
Called 5 times
Total time:   0.001122
 Self time:   0.000365

count  total (s)   self (s)
    5              0.000098   if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                return
    5              0.000015   endif
                            
    5   0.000938   0.000181   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
    5              0.000011     return
                              endif
                            
                              " Do not update when a special buffer is selected
                              if !empty(&l:buftype)
                                return
                              endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
                              let l:winnr = winnr()
                              let l:altwinnr = winnr('#')
                            
                              call g:NERDTree.CursorToTreeWin()
                              call b:NERDTree.root.refreshFlags()
                              call NERDTreeRender()
                            
                              exec l:altwinnr . 'wincmd w'
                              exec l:winnr . 'wincmd w'

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 7 times
Total time:   0.002128
 Self time:   0.000445

count  total (s)   self (s)
    7   0.002112   0.000429   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:158
Called 17 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
   17              0.000042   if !exists("s:has_lawrencium")
    1              0.000002     let s:has_lawrencium  = exists('*lawrencium#statusline')
   17              0.000007   endif
   17              0.000019   return s:has_lawrencium

FUNCTION  <SNR>157_ExcludeOther()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:32
Called 2 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    2              0.000033   if (getbufvar(a:nr, 'current_syntax') == 'qf') ||  (a:exclude_preview && getbufvar(a:nr, '&bufhidden') == 'wipe'  && getbufvar(a:nr, '&buftype') == 'nofile')
    2              0.000007     return 1 | endif

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:68
Called 513 times
Total time:   0.064477
 Self time:   0.029572

count  total (s)   self (s)
                                " only check for the cterm reverse attribute
                                " TODO: do we need to check all modes (gui, term, as well)?
  513              0.002863     let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
  513              0.001591     if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                  let res = s:hl_groups[a:group]
                                  return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  513              0.000268     else
  513   0.012254   0.003271       let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
  513   0.010937   0.002920       let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
  513   0.010472   0.002758       let guifg = s:get_syn(a:group, 'fg', 'gui')
  513   0.010241   0.002715       let guibg = s:get_syn(a:group, 'bg', 'gui')
  513              0.001850       let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  513              0.000439       if reverse
                                    let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
  513              0.000271       else
  513   0.006552   0.003886         let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
  513              0.000270       endif
  513              0.000185     endif
  513              0.001573     let s:hl_groups[a:group] = res
  513              0.000416     return res

FUNCTION  <SNR>154_build_sections()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:35
Called 5 times
Total time:   0.002348
 Self time:   0.000368

count  total (s)   self (s)
   24              0.000051   for key in a:keys
   19              0.000054     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
   19              0.000009     endif
   19   0.002162   0.000181     call s:add_section(a:builder, a:context, key)
   24              0.000019   endfor

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:28
Called 45 times
Total time:   0.001316
 Self time:   0.000869

count  total (s)   self (s)
   45   0.000891   0.000444   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
   45              0.000020   else
   45              0.000047     return a:text
                              endif

FUNCTION  278()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:131
Called 3 times
Total time:   0.000095
 Self time:   0.000028

count  total (s)   self (s)
    3   0.000093   0.000026   call gitgutter#utility#setbufvar(a:buffer, 'path', -2)

FUNCTION  airline#extensions#apply_left_override()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:63
Called 1 time
Total time:   0.000307
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000007   let w:airline_section_a = a:section1
    1              0.000005   let w:airline_section_b = a:section2
    1   0.000292   0.000018   let w:airline_section_c = airline#section#create(['readonly'])
    1              0.000001   let w:airline_render_left = 1
    1              0.000001   let w:airline_render_right = 0

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:205
Called 7 times
Total time:   0.005621
 Self time:   0.000616

count  total (s)   self (s)
    7              0.000061     if getbufvar(a:bufnr, '&modified')
                                  let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    7              0.000010     else
    7              0.000158       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    7              0.000010     endif
                            
    7              0.000027     if !empty(colors)
    7   0.005244   0.000239       call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    7              0.000008     endif

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:315
Called 15 times
Total time:   0.020740
 Self time:   0.000587

count  total (s)   self (s)
   15   0.019893   0.000152   let head = airline#extensions#branch#head()
   15   0.000179   0.000116   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
   15              0.000053   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
   15   0.000448   0.000099   let head = airline#util#shorten(head, winwidth, minwidth)
   15              0.000052   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   15              0.000093   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  airline#extensions#nvimlsp#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:42
Called 15 times
Total time:   0.000586
 Self time:   0.000105

count  total (s)   self (s)
   15   0.000580   0.000099   return airline#extensions#nvimlsp#get('Error')

FUNCTION  <SNR>123_LeadingSpaceDisable()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:364
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000001     if g:indentLine_newVersion
    1              0.000002         if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                        for id in w:indentLine_leadingSpaceId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_leadingSpaceId = []
    1              0.000000         endif
                            
    1              0.000000         return
                                endif
                            
                                let b:indentLine_leadingSpaceEnabled = 0
                                try
                                    syntax clear IndentLineLeadingSpace
                                catch /^Vim\%((\a\+)\)\=:E28/   " catch error E28
                                endtry

FUNCTION  <SNR>77_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:214
Called 6 times
Total time:   0.000631
 Self time:   0.000144

count  total (s)   self (s)
    6   0.000628   0.000141   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  283()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:8
Called 5 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    5              0.000025   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  284()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:12
Called 2 times
Total time:   0.000053
 Self time:   0.000040

count  total (s)   self (s)
    2              0.000015   let spc = empty(a:contents) ? '' : g:airline_symbols.space
    2   0.000035   0.000023   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  285()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:17
Called 25 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
   25              0.000121   call add(self._sections, [a:group, a:contents])

FUNCTION  287()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:25
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000005   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  289()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:33
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000009   return len(self._sections)

FUNCTION  <SNR>123_Setup()
    Defined: ~/.vim/plugged/indentLine/after/plugin/indentLine.vim:317
Called 1 time
Total time:   0.000429
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000001     if &filetype ==# ""
                                    call s:InitColor()
    1              0.000000     endif
                            
    1   0.000027   0.000006     if s:Filter() && g:indentLine_enabled || exists("b:indentLine_enabled") && b:indentLine_enabled
    1   0.000372   0.000005         call s:IndentLinesEnable()
    1              0.000000     endif
                            
    1   0.000023   0.000008     if s:Filter() && g:indentLine_leadingSpaceEnabled || exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceEnable()
    1              0.000000     endif

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:95
Called 15 times
Total time:   0.005443
 Self time:   0.002176

count  total (s)   self (s)
   15              0.000057   if !get(w:, 'airline_active', 0)
                                return ''
   15              0.000009   endif
                              " Cache values, so that it isn't called too often
   15   0.000490   0.000331   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
   15              0.000009   endif
   15   0.002504   0.000151   let hunks = airline#extensions#hunks#get_raw_hunks()
   15              0.000024   let string = ''
   15   0.000266   0.000165   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
   15              0.000033   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
   48              0.000102     for i in [0, 1, 2]
   36   0.000884   0.000410       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
                                    let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
   36              0.000027       endif
   48              0.000047     endfor
   15              0.000010   endif
   15   0.000256   0.000211   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
                                let string = string[0:-2]
   15              0.000009   endif
                            
   15              0.000038   let b:airline_hunks = string
   15              0.000037   let b:airline_changenr = b:changedtick
   15   0.000241   0.000106   let s:airline_winwidth = airline#util#winwidth()
   15              0.000019   return string

FUNCTION  <SNR>66_CeilingDirectories()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:324
Called 2 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    2              0.000004   if !exists('s:ceiling_directories')
    1              0.000001     let s:ceiling_directories = []
    1              0.000001     let resolve = 1
    2              0.000009     for dir in split($GIT_CEILING_DIRECTORIES, has('win32') ? ';' : ':', 1)
    1              0.000001       if empty(dir)
    1              0.000001         let resolve = 0
                                  elseif resolve
                                    call add(s:ceiling_directories, resolve(dir))
                                  else
                                    call add(s:ceiling_directories, dir)
    1              0.000000       endif
    2              0.000001     endfor
    2              0.000001   endif
    2              0.000005   return s:ceiling_directories + get(g:, 'ceiling_directories', [])

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/netrw.vim:11
Called 3 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
    3              0.000045   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    3              0.000002   endif

FUNCTION  290()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:62
Called 7 times
Total time:   0.025895
 Self time:   0.003942

count  total (s)   self (s)
    7              0.000013   let side = 1
    7              0.000008   let line = ''
    7              0.000008   let i = 0
    7              0.000018   let length = len(self._sections)
    7              0.000008   let split = 0
    7              0.000010   let is_empty = 0
    7              0.000012   let prev_group = ''
                            
   51              0.000081   while i < length
   44              0.000102     let section = self._sections[i]
   44              0.000073     let group = section[0]
   44              0.000068     let contents = section[1]
   44              0.000060     let pgroup = prev_group
   44   0.000915   0.000397     let prev_group = airline#builder#get_prev_group(self._sections, i)
   44              0.000104     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
   44              0.000120     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
   44              0.000109     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
   44              0.000021     endif
   44              0.000034     if is_empty
                                  let prev_group = pgroup
   44              0.000017     endif
   44   0.000788   0.000342     let is_empty = s:section_is_empty(self, contents)
                            
   44              0.000029     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
   44              0.000022     endif
                            
   44              0.000048     if group == ''
    4              0.000006       let line .= contents
   40              0.000036     elseif group == '|'
    7              0.000009       let side = 0
    7              0.000018       let line .= contents
    7              0.000009       let split = 1
   33              0.000017     else
   33              0.000031       if prev_group == ''
    7              0.000023         let line .= '%#'.group.'#'
   26              0.000015       elseif split
    6              0.000004         if !is_empty
    6   0.003555   0.000049           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    6              0.000003         endif
    6              0.000005         let split = 0
   20              0.000007       else
   20              0.000014         if !is_empty
   20   0.016219   0.000207           let line .= s:get_seperator(self, prev_group, group, side)
   20              0.000012         endif
   33              0.000017       endif
   33   0.001885   0.000413       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   44              0.000021     endif
                            
   44              0.000061     let i = i + 1
   51              0.000042   endwhile
                            
    7              0.000007   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    7              0.000003   endif
    7              0.000010   return line

FUNCTION  airline#extensions#fzf#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:28
Called 3 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    3              0.000010   if &filetype ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
    3              0.000003   endif

FUNCTION  <SNR>140_conflict_marker()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:52
Called 2 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
                              " Checks for git conflict markers
    2              0.000004   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
    2              0.000014   if match(['rst', 'markdown'], &ft) >= 0
                                " rst filetypes use '=======' as header
                                let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(>\{7\} '.annotation.'\)\)$'
    2              0.000001   else
    2              0.000009     let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
    2              0.000001   endif
    2              0.000052   return search(pattern, 'nw')

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 23 times
Total time:   0.000608
 Self time:   0.000608

count  total (s)   self (s)
   23              0.000164   let ggvars = getbufvar(a:buffer, 'gitgutter')
   23              0.000211   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
    2              0.000008     return ggvars[a:varname]
   21              0.000020   endif
   21              0.000030   if a:0
   21              0.000033     return a:1
                              endif

FUNCTION  AutoPairsTryInit()
    Defined: ~/.vim/plugged/auto-pairs/plugin/auto-pairs.vim:603
Called 1 time
Total time:   0.001079
 Self time:   0.000114

count  total (s)   self (s)
    1              0.000002   if exists('b:autopairs_loaded')
                                return
    1              0.000000   end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
    1              0.000001   if g:AutoPairsMapCR
    1              0.000002     if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
    1              0.000027       let info = maparg('<CR>', 'i', 0, 1)
    1              0.000003       if empty(info)
    1              0.000002         let old_cr = '<CR>'
    1              0.000002         let is_expr = 0
                                  else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
    1              0.000001       endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
    1              0.000001     end
                            
    1              0.000010     if old_cr !~ 'AutoPairsReturn'
    1              0.000001       if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
    1              0.000000       end
                                  " Always silent mapping
    1              0.000017       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
    1              0.000000     end
    1              0.000000   endif
    1   0.000977   0.000012   call AutoPairsInit()

FUNCTION  FugitiveParse()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:89
Called 4 times
Total time:   0.000065
 Self time:   0.000055

count  total (s)   self (s)
    4   0.000040   0.000031   let path = s:Slash(a:0 ? a:1 : @%)
    4              0.000017   if path !~# '^fugitive:'
    4              0.000005     return ['', '']
                              endif
                              let vals = matchlist(path, '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if len(vals)
                                return [(vals[2] =~# '^.$' ? ':' : '') . vals[2] . substitute(vals[3], '^/', ':', ''), vals[1]]
                              endif
                              let v:errmsg = 'fugitive: invalid Fugitive URL ' . path
                              throw v:errmsg

FUNCTION  airline#highlighter#reset_hlcache()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:64
Called 2 times
Total time:   0.000343
 Self time:   0.000343

count  total (s)   self (s)
    2              0.000336     let s:hl_groups = {}

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:63
Called 75 times
Total time:   0.000383
 Self time:   0.000383

count  total (s)   self (s)
   75              0.000134   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
   75              0.000028   endif
   75              0.000151   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>84_airline_refresh()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:216
Called 2 times
Total time:   0.019761
 Self time:   0.000443

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    2              0.000029   let fast=!empty(get(a:000, 0, 0))
    2              0.000020   if !exists("#airline")
                                " disabled
                                return
    2              0.000004   endif
    2   0.000542   0.000063   call airline#util#doautocmd('AirlineBeforeRefresh')
    2   0.000410   0.000068   call airline#highlighter#reset_hlcache()
    2              0.000015   if !fast
                                call airline#load_theme()
    2              0.000012   endif
    2   0.018661   0.000177   call airline#update_statusline()
    2   0.000036   0.000024   call airline#update_tabline()

FUNCTION  hexokinase#utils#tmpname()
    Defined: ~/.vim/plugged/vim-hexokinase/autoload/hexokinase/utils.vim:80
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000001     let l:clear_tempdir = 0
                            
    1              0.000002     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
    1              0.000000     endif
                            
    1              0.000001     try
    1              0.000002         let l:name = tempname()
    1              0.000001     finally
    1              0.000001         if l:clear_tempdir
                                        let $TMPDIR = ''
    1              0.000000         endif
    1              0.000001     endtry
                            
    1              0.000001     return l:name

FUNCTION  <SNR>127_is_excluded_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:111
Called 3 times
Total time:   0.000227
 Self time:   0.000227

count  total (s)   self (s)
    3              0.000017   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
    3              0.000005   endfor
                            
   12              0.000024   for matchw in g:airline_exclude_filenames
    9              0.000098     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
    9              0.000006     endif
   12              0.000009   endfor
                            
    3              0.000008   if g:airline_exclude_preview && &previewwindow
                                return 1
    3              0.000002   endif
                            
    3              0.000004   return 0

FUNCTION  airline#util#getbufvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:71
Called 6 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    6              0.000073     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:505
Called 15 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
   15              0.000036   return s:loaded_ext

FUNCTION  airline#async#nvim_vcs_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:305
Called 2 times
Total time:   0.000978
 Self time:   0.000942

count  total (s)   self (s)
    2   0.000063   0.000045     let config = { 'buf': '', 'vcs': a:vcs, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')), 'on_stdout': function('s:nvim_output_handler'), 'on_stderr': function('s:nvim_output_handler'), 'on_exit': function('s:on_exit_clean')}
    2              0.000003     if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
    2              0.000001     else
    2              0.000005       let cmd = [&shell, &shellcmdflag, a:cmd]
    2              0.000001     endif
                            
    2              0.000005     if !has_key(s:clean_jobs, a:vcs)
    1              0.000002       let s:clean_jobs[a:vcs] = {}
    2              0.000001     endif
    2              0.000004     if has_key(s:clean_jobs[a:vcs], a:file)
                                  " still running
    1              0.000001       return
                                  " jobs dict should be cleaned on exit, so not needed here
                                  " call remove(s:clean_jobs[a:vcs], a:file)
    1              0.000000     endif
    1              0.000825     let id = jobstart(cmd, config)
    1   0.000056   0.000039     call s:set_clean_jobs_variable(a:vcs, a:file, id)

FUNCTION  fugitive#ReloadStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:4029
Called 1 time
Total time:   0.000041
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000021   0.000008   call s:ExpireStatus(a:0 ? a:1 : -1)
    1              0.000001   if a:0 > 1 ? a:2 : 1
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
    1              0.000000   else
    1   0.000008   0.000005     call s:ReloadWinStatus()
    1              0.000000     return ''
                              endif
                              exe s:DoAutocmdChanged(a:0 ? a:1 : -1)
                              return ''

FUNCTION  <SNR>137_init_buffer()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:51
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000001   let b:buffer_vcs_config = {}
    3              0.000007   for vcs in keys(s:vcs_config)
    2              0.000007     let b:buffer_vcs_config[vcs] = {     'branch': '',     'untracked': '',     'dirty': 0,   }
    3              0.000001   endfor
    1              0.000001   unlet! b:airline_head

FUNCTION  airline#extensions#tabline#add_tab_label()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:37
Called 2 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    2              0.000012   let show_tab_count = get(g:, 'airline#extensions#tabline#show_tab_count', 1)
    2              0.000005   if show_tab_count == 2
                                call a:dict.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
    2              0.000009   elseif show_tab_count == 1 && tabpagenr('$') > 1
                                call a:dict.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
    2              0.000002   endif

FUNCTION  airline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:229
Called 5 times
Total time:   0.000309
 Self time:   0.000309

count  total (s)   self (s)
    5              0.000092   let builder = copy(s:prototype)
    5              0.000024   let builder._context = a:context
    5              0.000019   let builder._sections = []
                            
    5              0.000137   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    5              0.000021   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   31   0.111215   0.007785  airline#check_mode()
    7   0.096943   0.015880  airline#highlighter#highlight()
  287   0.072575   0.023611  airline#highlighter#exec()
  513   0.064477   0.029572  airline#highlighter#get_highlight()
   91   0.043601   0.003468  <SNR>134_exec_separator()
    1   0.037014   0.000122  startify#open_buffers()
    1   0.036891   0.002232  <SNR>156_open_buffer()
 2052   0.032239             <SNR>134_get_syn()
    7   0.025895   0.003942  290()
    3   0.024918   0.000555  airline#update_statusline()
    3   0.023469   0.000261  <SNR>129_invoke_funcrefs()
  182   0.021382   0.001582  airline#themes#get_highlight()
   15   0.020740   0.000587  airline#extensions#branch#get_head()
    2   0.019961   0.000136  <SNR>84_on_focus_gained()
    2   0.019761   0.000443  <SNR>84_airline_refresh()
   15   0.019741   0.001034  airline#extensions#branch#head()
    6   0.017206   0.000950  airline#extensions#tabline#get()
    6   0.016256   0.001034  airline#extensions#tabline#buffers#get()
   20   0.016012   0.000350  <SNR>153_get_seperator()
    7   0.014720   0.000775  gitgutter#process_buffer()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 2052              0.032239  <SNR>134_get_syn()
  513   0.064477   0.029572  airline#highlighter#get_highlight()
  287   0.072575   0.023611  airline#highlighter#exec()
    7   0.096943   0.015880  airline#highlighter#highlight()
    3   0.009777   0.009502  gitgutter#async#execute()
    1              0.007935  airline#extensions#tabline#redraw()
   31   0.111215   0.007785  airline#check_mode()
    1   0.004371   0.004255  <SNR>32_LoadFTPlugin()
    7   0.025895   0.003942  290()
  287              0.003643  <SNR>134_CheckDefined()
    6              0.003566  <SNR>146_map_keys()
   91   0.043601   0.003468  <SNR>134_exec_separator()
   38              0.003109  <SNR>134_GetHiCmd()
   15   0.005738   0.002839  fugitive#Find()
  513              0.002666  <SNR>134_get_array()
  249              0.002557  <SNR>134_hl_group_exists()
    1   0.006909   0.002398  <SNR>35_SynSet()
    1   0.036891   0.002232  <SNR>156_open_buffer()
   60   0.002249   0.002183  FugitiveGitDir()
   15   0.005443   0.002176  airline#extensions#hunks#get_hunks()

